var _____WB$wombat$assign$function_____ = function (name) {
  return (
    (self._wb_wombat &&
      self._wb_wombat.local_init &&
      self._wb_wombat.local_init(name)) ||
    self[name]
  )
}
if (!self.__WB_pmw) {
  self.__WB_pmw = function (obj) {
    this.__WB_source = obj
    return this
  }
}
{
  let window = _____WB$wombat$assign$function_____('window')
  let self = _____WB$wombat$assign$function_____('self')
  let document = _____WB$wombat$assign$function_____('document')
  let location = _____WB$wombat$assign$function_____('location')
  let top = _____WB$wombat$assign$function_____('top')
  let parent = _____WB$wombat$assign$function_____('parent')
  let frames = _____WB$wombat$assign$function_____('frames')
  let opener = _____WB$wombat$assign$function_____('opener')

  /**The MIT License

Copyright Â© 2010-2020 three.js authors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
  !(function a(o, s, c) {
    function l(e, t) {
      if (!s[e]) {
        if (!o[e]) {
          var n = 'function' == typeof require && require
          if (!t && n) return n(e, !0)
          if (h) return h(e, !0)
          var r = new Error("Cannot find module '" + e + "'")
          throw ((r.code = 'MODULE_NOT_FOUND'), r)
        }
        var i = (s[e] = { exports: {} })
        o[e][0].call(
          i.exports,
          function (t) {
            return l(o[e][1][t] || t)
          },
          i,
          i.exports,
          a,
          o,
          s,
          c,
        )
      }
      return s[e].exports
    }
    for (
      var h = 'function' == typeof require && require, t = 0;
      t < c.length;
      t++
    )
      l(c[t])
    return l
  })(
    {
      1: [
        function (t, e, n) {
          var r = Object.prototype.toString
          e.exports = function (t) {
            return (
              (t.BYTES_PER_ELEMENT &&
                '[object ArrayBuffer]' === r.call(t.buffer)) ||
              Array.isArray(t)
            )
          }
        },
        {},
      ],
      2: [
        function (t, e, n) {
          e.exports = function (t, e) {
            return 'number' == typeof t ? t : 'number' == typeof e ? e : 0
          }
        },
        {},
      ],
      3: [
        function (t, e, n) {
          'use strict'
          ;(n.byteLength = function (t) {
            var e = u(t),
              n = e[0],
              r = e[1]
            return (3 * (n + r)) / 4 - r
          }),
            (n.toByteArray = function (t) {
              var e,
                n,
                r = u(t),
                i = r[0],
                a = r[1],
                o = new h(
                  (function (t, e) {
                    return (3 * (t + e)) / 4 - e
                  })(i, a),
                ),
                s = 0,
                c = 0 < a ? i - 4 : i
              for (n = 0; n < c; n += 4)
                (e =
                  (l[t.charCodeAt(n)] << 18) |
                  (l[t.charCodeAt(n + 1)] << 12) |
                  (l[t.charCodeAt(n + 2)] << 6) |
                  l[t.charCodeAt(n + 3)]),
                  (o[s++] = (e >> 16) & 255),
                  (o[s++] = (e >> 8) & 255),
                  (o[s++] = 255 & e)
              2 === a &&
                ((e =
                  (l[t.charCodeAt(n)] << 2) | (l[t.charCodeAt(n + 1)] >> 4)),
                (o[s++] = 255 & e))
              1 === a &&
                ((e =
                  (l[t.charCodeAt(n)] << 10) |
                  (l[t.charCodeAt(n + 1)] << 4) |
                  (l[t.charCodeAt(n + 2)] >> 2)),
                (o[s++] = (e >> 8) & 255),
                (o[s++] = 255 & e))
              return o
            }),
            (n.fromByteArray = function (t) {
              for (
                var e, n = t.length, r = n % 3, i = [], a = 0, o = n - r;
                a < o;
                a += 16383
              )
                i.push(
                  (function (t, e, n) {
                    for (var r, i = [], a = e; a < n; a += 3)
                      (r =
                        ((t[a] << 16) & 16711680) +
                        ((t[a + 1] << 8) & 65280) +
                        (255 & t[a + 2])),
                        i.push(
                          (function (t) {
                            return (
                              s[(t >> 18) & 63] +
                              s[(t >> 12) & 63] +
                              s[(t >> 6) & 63] +
                              s[63 & t]
                            )
                          })(r),
                        )
                    return i.join('')
                  })(t, a, o < a + 16383 ? o : a + 16383),
                )
              1 == r
                ? ((e = t[n - 1]), i.push(s[e >> 2] + s[(e << 4) & 63] + '=='))
                : 2 == r &&
                  ((e = (t[n - 2] << 8) + t[n - 1]),
                  i.push(
                    s[e >> 10] + s[(e >> 4) & 63] + s[(e << 2) & 63] + '=',
                  ))
              return i.join('')
            })
          for (
            var s = [],
              l = [],
              h = 'undefined' != typeof Uint8Array ? Uint8Array : Array,
              r =
                'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
              i = 0,
              a = r.length;
            i < a;
            ++i
          )
            (s[i] = r[i]), (l[r.charCodeAt(i)] = i)
          function u(t) {
            var e = t.length
            if (0 < e % 4)
              throw new Error('Invalid string. Length must be a multiple of 4')
            var n = t.indexOf('=')
            return -1 === n && (n = e), [n, n === e ? 0 : 4 - (n % 4)]
          }
          ;(l['-'.charCodeAt(0)] = 62), (l['_'.charCodeAt(0)] = 63)
        },
        {},
      ],
      4: [
        function (t, e, n) {
          var r = t('buffer').Buffer
          e.exports = function (t, e) {
            if (r.isBuffer(t) && r.isBuffer(e)) {
              if ('function' == typeof t.equals) return t.equals(e)
              if (t.length !== e.length) return !1
              for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1
              return !0
            }
          }
        },
        { buffer: 5 },
      ],
      5: [
        function (t, e, P) {
          ;(function (u) {
            'use strict'
            var s = t('base64-js'),
              a = t('ieee754')
            ;(P.Buffer = u),
              (P.SlowBuffer = function (t) {
                ;+t != t && (t = 0)
                return u.alloc(+t)
              }),
              (P.INSPECT_MAX_BYTES = 50)
            var n = 2147483647
            function o(t) {
              if (n < t)
                throw new RangeError(
                  'The value "' + t + '" is invalid for option "size"',
                )
              var e = new Uint8Array(t)
              return (e.__proto__ = u.prototype), e
            }
            function u(t, e, n) {
              if ('number' != typeof t) return r(t, e, n)
              if ('string' == typeof e)
                throw new TypeError(
                  'The "string" argument must be of type string. Received type number',
                )
              return i(t)
            }
            function r(t, e, n) {
              if ('string' == typeof t)
                return (function (t, e) {
                  ;('string' == typeof e && '' !== e) || (e = 'utf8')
                  if (!u.isEncoding(e))
                    throw new TypeError('Unknown encoding: ' + e)
                  var n = 0 | p(t, e),
                    r = o(n),
                    i = r.write(t, e)
                  i !== n && (r = r.slice(0, i))
                  return r
                })(t, e)
              if (ArrayBuffer.isView(t)) return l(t)
              if (null == t)
                throw TypeError(
                  'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
                    typeof t,
                )
              if (R(t, ArrayBuffer) || (t && R(t.buffer, ArrayBuffer)))
                return (function (t, e, n) {
                  if (e < 0 || t.byteLength < e)
                    throw new RangeError('"offset" is outside of buffer bounds')
                  if (t.byteLength < e + (n || 0))
                    throw new RangeError('"length" is outside of buffer bounds')
                  var r
                  r =
                    void 0 === e && void 0 === n
                      ? new Uint8Array(t)
                      : void 0 === n
                        ? new Uint8Array(t, e)
                        : new Uint8Array(t, e, n)
                  return (r.__proto__ = u.prototype), r
                })(t, e, n)
              if ('number' == typeof t)
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number',
                )
              var r = t.valueOf && t.valueOf()
              if (null != r && r !== t) return u.from(r, e, n)
              var i = (function (t) {
                if (u.isBuffer(t)) {
                  var e = 0 | h(t.length),
                    n = o(e)
                  return 0 === n.length ? n : (t.copy(n, 0, 0, e), n)
                }
                if (void 0 !== t.length)
                  return 'number' != typeof t.length || C(t.length)
                    ? o(0)
                    : l(t)
                if ('Buffer' === t.type && Array.isArray(t.data))
                  return l(t.data)
              })(t)
              if (i) return i
              if (
                'undefined' != typeof Symbol &&
                null != Symbol.toPrimitive &&
                'function' == typeof t[Symbol.toPrimitive]
              )
                return u.from(t[Symbol.toPrimitive]('string'), e, n)
              throw new TypeError(
                'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
                  typeof t,
              )
            }
            function c(t) {
              if ('number' != typeof t)
                throw new TypeError('"size" argument must be of type number')
              if (t < 0)
                throw new RangeError(
                  'The value "' + t + '" is invalid for option "size"',
                )
            }
            function i(t) {
              return c(t), o(t < 0 ? 0 : 0 | h(t))
            }
            function l(t) {
              for (
                var e = t.length < 0 ? 0 : 0 | h(t.length), n = o(e), r = 0;
                r < e;
                r += 1
              )
                n[r] = 255 & t[r]
              return n
            }
            function h(t) {
              if (n <= t)
                throw new RangeError(
                  'Attempt to allocate Buffer larger than maximum size: 0x' +
                    n.toString(16) +
                    ' bytes',
                )
              return 0 | t
            }
            function p(t, e) {
              if (u.isBuffer(t)) return t.length
              if (ArrayBuffer.isView(t) || R(t, ArrayBuffer))
                return t.byteLength
              if ('string' != typeof t)
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                    typeof t,
                )
              var n = t.length,
                r = 2 < arguments.length && !0 === arguments[2]
              if (!r && 0 === n) return 0
              for (var i = !1; ; )
                switch (e) {
                  case 'ascii':
                  case 'latin1':
                  case 'binary':
                    return n
                  case 'utf8':
                  case 'utf-8':
                    return T(t).length
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return 2 * n
                  case 'hex':
                    return n >>> 1
                  case 'base64':
                    return A(t).length
                  default:
                    if (i) return r ? -1 : T(t).length
                    ;(e = ('' + e).toLowerCase()), (i = !0)
                }
            }
            function e(t, e, n) {
              var r,
                i,
                a,
                o = !1
              if (((void 0 === e || e < 0) && (e = 0), e > this.length))
                return ''
              if (
                ((void 0 === n || n > this.length) && (n = this.length), n <= 0)
              )
                return ''
              if ((n >>>= 0) <= (e >>>= 0)) return ''
              for (t = t || 'utf8'; ; )
                switch (t) {
                  case 'hex':
                    return (function (t, e, n) {
                      var r = t.length
                      ;(!e || e < 0) && (e = 0)
                      ;(!n || n < 0 || r < n) && (n = r)
                      for (var i = '', a = e; a < n; ++a)
                        i += (function (t) {
                          return t < 16 ? '0' + t.toString(16) : t.toString(16)
                        })(t[a])
                      return i
                    })(this, e, n)
                  case 'utf8':
                  case 'utf-8':
                    return y(this, e, n)
                  case 'ascii':
                    return (function (t, e, n) {
                      var r = ''
                      n = Math.min(t.length, n)
                      for (var i = e; i < n; ++i)
                        r += String.fromCharCode(127 & t[i])
                      return r
                    })(this, e, n)
                  case 'latin1':
                  case 'binary':
                    return (function (t, e, n) {
                      var r = ''
                      n = Math.min(t.length, n)
                      for (var i = e; i < n; ++i) r += String.fromCharCode(t[i])
                      return r
                    })(this, e, n)
                  case 'base64':
                    return (
                      (r = this),
                      (a = n),
                      0 === (i = e) && a === r.length
                        ? s.fromByteArray(r)
                        : s.fromByteArray(r.slice(i, a))
                    )
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return (function (t, e, n) {
                      for (
                        var r = t.slice(e, n), i = '', a = 0;
                        a < r.length;
                        a += 2
                      )
                        i += String.fromCharCode(r[a] + 256 * r[a + 1])
                      return i
                    })(this, e, n)
                  default:
                    if (o) throw new TypeError('Unknown encoding: ' + t)
                    ;(t = (t + '').toLowerCase()), (o = !0)
                }
            }
            function d(t, e, n) {
              var r = t[e]
              ;(t[e] = t[n]), (t[n] = r)
            }
            function f(t, e, n, r, i) {
              if (0 === t.length) return -1
              if (
                ('string' == typeof n
                  ? ((r = n), (n = 0))
                  : 2147483647 < n
                    ? (n = 2147483647)
                    : n < -2147483648 && (n = -2147483648),
                C((n = +n)) && (n = i ? 0 : t.length - 1),
                n < 0 && (n = t.length + n),
                n >= t.length)
              ) {
                if (i) return -1
                n = t.length - 1
              } else if (n < 0) {
                if (!i) return -1
                n = 0
              }
              if (('string' == typeof e && (e = u.from(e, r)), u.isBuffer(e)))
                return 0 === e.length ? -1 : m(t, e, n, r, i)
              if ('number' == typeof e)
                return (
                  (e &= 255),
                  'function' == typeof Uint8Array.prototype.indexOf
                    ? i
                      ? Uint8Array.prototype.indexOf.call(t, e, n)
                      : Uint8Array.prototype.lastIndexOf.call(t, e, n)
                    : m(t, [e], n, r, i)
                )
              throw new TypeError('val must be string, number or Buffer')
            }
            function m(t, e, n, r, i) {
              var a = 1,
                o = t.length,
                s = e.length
              if (
                void 0 !== r &&
                ('ucs2' === (r = String(r).toLowerCase()) ||
                  'ucs-2' === r ||
                  'utf16le' === r ||
                  'utf-16le' === r)
              ) {
                if (t.length < 2 || e.length < 2) return -1
                ;(o /= a = 2), (s /= 2), (n /= 2)
              }
              function c(t, e) {
                return 1 === a ? t[e] : t.readUInt16BE(e * a)
              }
              if (i)
                for (var l = -1, h = n; h < o; h++)
                  if (c(t, h) === c(e, -1 === l ? 0 : h - l)) {
                    if ((-1 === l && (l = h), h - l + 1 === s)) return l * a
                  } else -1 !== l && (h -= h - l), (l = -1)
              else
                for (o < n + s && (n = o - s), h = n; 0 <= h; h--) {
                  for (var u = !0, p = 0; p < s; p++)
                    if (c(t, h + p) !== c(e, p)) {
                      u = !1
                      break
                    }
                  if (u) return h
                }
              return -1
            }
            function v(t, e, n, r) {
              return L(
                (function (t) {
                  for (var e = [], n = 0; n < t.length; ++n)
                    e.push(255 & t.charCodeAt(n))
                  return e
                })(e),
                t,
                n,
                r,
              )
            }
            function g(t, e, n, r) {
              return L(
                (function (t, e) {
                  for (
                    var n, r, i, a = [], o = 0;
                    o < t.length && !((e -= 2) < 0);
                    ++o
                  )
                    (n = t.charCodeAt(o)),
                      (r = n >> 8),
                      (i = n % 256),
                      a.push(i),
                      a.push(r)
                  return a
                })(e, t.length - n),
                t,
                n,
                r,
              )
            }
            function y(t, e, n) {
              n = Math.min(t.length, n)
              for (var r = [], i = e; i < n; ) {
                var a,
                  o,
                  s,
                  c,
                  l = t[i],
                  h = null,
                  u = 239 < l ? 4 : 223 < l ? 3 : 191 < l ? 2 : 1
                if (i + u <= n)
                  switch (u) {
                    case 1:
                      l < 128 && (h = l)
                      break
                    case 2:
                      128 == (192 & (a = t[i + 1])) &&
                        127 < (c = ((31 & l) << 6) | (63 & a)) &&
                        (h = c)
                      break
                    case 3:
                      ;(a = t[i + 1]),
                        (o = t[i + 2]),
                        128 == (192 & a) &&
                          128 == (192 & o) &&
                          2047 <
                            (c =
                              ((15 & l) << 12) | ((63 & a) << 6) | (63 & o)) &&
                          (c < 55296 || 57343 < c) &&
                          (h = c)
                      break
                    case 4:
                      ;(a = t[i + 1]),
                        (o = t[i + 2]),
                        (s = t[i + 3]),
                        128 == (192 & a) &&
                          128 == (192 & o) &&
                          128 == (192 & s) &&
                          65535 <
                            (c =
                              ((15 & l) << 18) |
                              ((63 & a) << 12) |
                              ((63 & o) << 6) |
                              (63 & s)) &&
                          c < 1114112 &&
                          (h = c)
                  }
                null === h
                  ? ((h = 65533), (u = 1))
                  : 65535 < h &&
                    ((h -= 65536),
                    r.push(((h >>> 10) & 1023) | 55296),
                    (h = 56320 | (1023 & h))),
                  r.push(h),
                  (i += u)
              }
              return (function (t) {
                var e = t.length
                if (e <= x) return String.fromCharCode.apply(String, t)
                var n = '',
                  r = 0
                for (; r < e; )
                  n += String.fromCharCode.apply(String, t.slice(r, (r += x)))
                return n
              })(r)
            }
            ;(P.kMaxLength = n),
              (u.TYPED_ARRAY_SUPPORT = (function () {
                try {
                  var t = new Uint8Array(1)
                  return (
                    (t.__proto__ = {
                      __proto__: Uint8Array.prototype,
                      foo: function () {
                        return 42
                      },
                    }),
                    42 === t.foo()
                  )
                } catch (t) {
                  return !1
                }
              })()) ||
                'undefined' == typeof console ||
                'function' != typeof console.error ||
                console.error(
                  'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.',
                ),
              Object.defineProperty(u.prototype, 'parent', {
                enumerable: !0,
                get: function () {
                  if (u.isBuffer(this)) return this.buffer
                },
              }),
              Object.defineProperty(u.prototype, 'offset', {
                enumerable: !0,
                get: function () {
                  if (u.isBuffer(this)) return this.byteOffset
                },
              }),
              'undefined' != typeof Symbol &&
                null != Symbol.species &&
                u[Symbol.species] === u &&
                Object.defineProperty(u, Symbol.species, {
                  value: null,
                  configurable: !0,
                  enumerable: !1,
                  writable: !1,
                }),
              (u.poolSize = 8192),
              (u.from = r),
              (u.prototype.__proto__ = Uint8Array.prototype),
              (u.__proto__ = Uint8Array),
              (u.alloc = function (t, e, n) {
                return (
                  (i = e),
                  (a = n),
                  c((r = t)),
                  r <= 0 || void 0 === i
                    ? o(r)
                    : 'string' == typeof a
                      ? o(r).fill(i, a)
                      : o(r).fill(i)
                )
                var r, i, a
              }),
              (u.allocUnsafe = i),
              (u.allocUnsafeSlow = i),
              (u.isBuffer = function (t) {
                return null != t && !0 === t._isBuffer && t !== u.prototype
              }),
              (u.compare = function (t, e) {
                if (
                  (R(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)),
                  R(e, Uint8Array) && (e = u.from(e, e.offset, e.byteLength)),
                  !u.isBuffer(t) || !u.isBuffer(e))
                )
                  throw new TypeError(
                    'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array',
                  )
                if (t === e) return 0
                for (
                  var n = t.length, r = e.length, i = 0, a = Math.min(n, r);
                  i < a;
                  ++i
                )
                  if (t[i] !== e[i]) {
                    ;(n = t[i]), (r = e[i])
                    break
                  }
                return n < r ? -1 : r < n ? 1 : 0
              }),
              (u.isEncoding = function (t) {
                switch (String(t).toLowerCase()) {
                  case 'hex':
                  case 'utf8':
                  case 'utf-8':
                  case 'ascii':
                  case 'latin1':
                  case 'binary':
                  case 'base64':
                  case 'ucs2':
                  case 'ucs-2':
                  case 'utf16le':
                  case 'utf-16le':
                    return !0
                  default:
                    return !1
                }
              }),
              (u.concat = function (t, e) {
                if (!Array.isArray(t))
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers',
                  )
                if (0 === t.length) return u.alloc(0)
                if (void 0 === e)
                  for (i = e = 0; i < t.length; ++i) e += t[i].length
                for (
                  var n = u.allocUnsafe(e), r = 0, i = 0;
                  i < t.length;
                  ++i
                ) {
                  var a = t[i]
                  if ((R(a, Uint8Array) && (a = u.from(a)), !u.isBuffer(a)))
                    throw new TypeError(
                      '"list" argument must be an Array of Buffers',
                    )
                  a.copy(n, r), (r += a.length)
                }
                return n
              }),
              (u.byteLength = p),
              (u.prototype._isBuffer = !0),
              (u.prototype.swap16 = function () {
                var t = this.length
                if (t % 2 != 0)
                  throw new RangeError(
                    'Buffer size must be a multiple of 16-bits',
                  )
                for (var e = 0; e < t; e += 2) d(this, e, e + 1)
                return this
              }),
              (u.prototype.swap32 = function () {
                var t = this.length
                if (t % 4 != 0)
                  throw new RangeError(
                    'Buffer size must be a multiple of 32-bits',
                  )
                for (var e = 0; e < t; e += 4)
                  d(this, e, e + 3), d(this, e + 1, e + 2)
                return this
              }),
              (u.prototype.swap64 = function () {
                var t = this.length
                if (t % 8 != 0)
                  throw new RangeError(
                    'Buffer size must be a multiple of 64-bits',
                  )
                for (var e = 0; e < t; e += 8)
                  d(this, e, e + 7),
                    d(this, e + 1, e + 6),
                    d(this, e + 2, e + 5),
                    d(this, e + 3, e + 4)
                return this
              }),
              (u.prototype.toLocaleString = u.prototype.toString =
                function () {
                  var t = this.length
                  return 0 === t
                    ? ''
                    : 0 === arguments.length
                      ? y(this, 0, t)
                      : e.apply(this, arguments)
                }),
              (u.prototype.equals = function (t) {
                if (!u.isBuffer(t))
                  throw new TypeError('Argument must be a Buffer')
                return this === t || 0 === u.compare(this, t)
              }),
              (u.prototype.inspect = function () {
                var t = '',
                  e = P.INSPECT_MAX_BYTES,
                  t = this.toString('hex', 0, e)
                    .replace(/(.{2})/g, '$1 ')
                    .trim()
                return this.length > e && (t += ' ... '), '<Buffer ' + t + '>'
              }),
              (u.prototype.compare = function (t, e, n, r, i) {
                if (
                  (R(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)),
                  !u.isBuffer(t))
                )
                  throw new TypeError(
                    'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                      typeof t,
                  )
                if (
                  (void 0 === e && (e = 0),
                  void 0 === n && (n = t ? t.length : 0),
                  void 0 === r && (r = 0),
                  void 0 === i && (i = this.length),
                  e < 0 || n > t.length || r < 0 || i > this.length)
                )
                  throw new RangeError('out of range index')
                if (i <= r && n <= e) return 0
                if (i <= r) return -1
                if (n <= e) return 1
                if (this === t) return 0
                for (
                  var a = (i >>>= 0) - (r >>>= 0),
                    o = (n >>>= 0) - (e >>>= 0),
                    s = Math.min(a, o),
                    c = this.slice(r, i),
                    l = t.slice(e, n),
                    h = 0;
                  h < s;
                  ++h
                )
                  if (c[h] !== l[h]) {
                    ;(a = c[h]), (o = l[h])
                    break
                  }
                return a < o ? -1 : o < a ? 1 : 0
              }),
              (u.prototype.includes = function (t, e, n) {
                return -1 !== this.indexOf(t, e, n)
              }),
              (u.prototype.indexOf = function (t, e, n) {
                return f(this, t, e, n, !0)
              }),
              (u.prototype.lastIndexOf = function (t, e, n) {
                return f(this, t, e, n, !1)
              }),
              (u.prototype.write = function (t, e, n, r) {
                if (void 0 === e) (r = 'utf8'), (n = this.length), (e = 0)
                else if (void 0 === n && 'string' == typeof e)
                  (r = e), (n = this.length), (e = 0)
                else {
                  if (!isFinite(e))
                    throw new Error(
                      'Buffer.write(string, encoding, offset[, length]) is no longer supported',
                    )
                  ;(e >>>= 0),
                    isFinite(n)
                      ? ((n >>>= 0), void 0 === r && (r = 'utf8'))
                      : ((r = n), (n = void 0))
                }
                var i = this.length - e
                if (
                  ((void 0 === n || i < n) && (n = i),
                  (0 < t.length && (n < 0 || e < 0)) || e > this.length)
                )
                  throw new RangeError('Attempt to write outside buffer bounds')
                r = r || 'utf8'
                for (var a, o, s, c, l, h, u = !1; ; )
                  switch (r) {
                    case 'hex':
                      return (function (t, e, n, r) {
                        n = Number(n) || 0
                        var i = t.length - n
                        ;(!r || i < (r = Number(r))) && (r = i)
                        var a = e.length
                        a / 2 < r && (r = a / 2)
                        for (var o = 0; o < r; ++o) {
                          var s = parseInt(e.substr(2 * o, 2), 16)
                          if (C(s)) return o
                          t[n + o] = s
                        }
                        return o
                      })(this, t, e, n)
                    case 'utf8':
                    case 'utf-8':
                      return (
                        (l = e),
                        (h = n),
                        L(T(t, (c = this).length - l), c, l, h)
                      )
                    case 'ascii':
                      return v(this, t, e, n)
                    case 'latin1':
                    case 'binary':
                      return v(this, t, e, n)
                    case 'base64':
                      return (a = this), (o = e), (s = n), L(A(t), a, o, s)
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                      return g(this, t, e, n)
                    default:
                      if (u) throw new TypeError('Unknown encoding: ' + r)
                      ;(r = ('' + r).toLowerCase()), (u = !0)
                  }
              }),
              (u.prototype.toJSON = function () {
                return {
                  type: 'Buffer',
                  data: Array.prototype.slice.call(this._arr || this, 0),
                }
              })
            var x = 4096
            function b(t, e, n) {
              if (t % 1 != 0 || t < 0)
                throw new RangeError('offset is not uint')
              if (n < t + e)
                throw new RangeError('Trying to access beyond buffer length')
            }
            function _(t, e, n, r, i, a) {
              if (!u.isBuffer(t))
                throw new TypeError(
                  '"buffer" argument must be a Buffer instance',
                )
              if (i < e || e < a)
                throw new RangeError('"value" argument is out of bounds')
              if (n + r > t.length) throw new RangeError('Index out of range')
            }
            function w(t, e, n, r) {
              if (n + r > t.length) throw new RangeError('Index out of range')
              if (n < 0) throw new RangeError('Index out of range')
            }
            function M(t, e, n, r, i) {
              return (
                (e = +e),
                (n >>>= 0),
                i || w(t, 0, n, 4),
                a.write(t, e, n, r, 23, 4),
                n + 4
              )
            }
            function S(t, e, n, r, i) {
              return (
                (e = +e),
                (n >>>= 0),
                i || w(t, 0, n, 8),
                a.write(t, e, n, r, 52, 8),
                n + 8
              )
            }
            ;(u.prototype.slice = function (t, e) {
              var n = this.length
              ;(t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : n < t && (t = n),
                (e = void 0 === e ? n : ~~e) < 0
                  ? (e += n) < 0 && (e = 0)
                  : n < e && (e = n),
                e < t && (e = t)
              var r = this.subarray(t, e)
              return (r.__proto__ = u.prototype), r
            }),
              (u.prototype.readUIntLE = function (t, e, n) {
                ;(t >>>= 0), (e >>>= 0), n || b(t, e, this.length)
                for (var r = this[t], i = 1, a = 0; ++a < e && (i *= 256); )
                  r += this[t + a] * i
                return r
              }),
              (u.prototype.readUIntBE = function (t, e, n) {
                ;(t >>>= 0), (e >>>= 0), n || b(t, e, this.length)
                for (var r = this[t + --e], i = 1; 0 < e && (i *= 256); )
                  r += this[t + --e] * i
                return r
              }),
              (u.prototype.readUInt8 = function (t, e) {
                return (t >>>= 0), e || b(t, 1, this.length), this[t]
              }),
              (u.prototype.readUInt16LE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 2, this.length),
                  this[t] | (this[t + 1] << 8)
                )
              }),
              (u.prototype.readUInt16BE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 2, this.length),
                  (this[t] << 8) | this[t + 1]
                )
              }),
              (u.prototype.readUInt32LE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 4, this.length),
                  (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
                    16777216 * this[t + 3]
                )
              }),
              (u.prototype.readUInt32BE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 4, this.length),
                  16777216 * this[t] +
                    ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
                )
              }),
              (u.prototype.readIntLE = function (t, e, n) {
                ;(t >>>= 0), (e >>>= 0), n || b(t, e, this.length)
                for (var r = this[t], i = 1, a = 0; ++a < e && (i *= 256); )
                  r += this[t + a] * i
                return (i *= 128) <= r && (r -= Math.pow(2, 8 * e)), r
              }),
              (u.prototype.readIntBE = function (t, e, n) {
                ;(t >>>= 0), (e >>>= 0), n || b(t, e, this.length)
                for (var r = e, i = 1, a = this[t + --r]; 0 < r && (i *= 256); )
                  a += this[t + --r] * i
                return (i *= 128) <= a && (a -= Math.pow(2, 8 * e)), a
              }),
              (u.prototype.readInt8 = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 1, this.length),
                  128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
                )
              }),
              (u.prototype.readInt16LE = function (t, e) {
                ;(t >>>= 0), e || b(t, 2, this.length)
                var n = this[t] | (this[t + 1] << 8)
                return 32768 & n ? 4294901760 | n : n
              }),
              (u.prototype.readInt16BE = function (t, e) {
                ;(t >>>= 0), e || b(t, 2, this.length)
                var n = this[t + 1] | (this[t] << 8)
                return 32768 & n ? 4294901760 | n : n
              }),
              (u.prototype.readInt32LE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 4, this.length),
                  this[t] |
                    (this[t + 1] << 8) |
                    (this[t + 2] << 16) |
                    (this[t + 3] << 24)
                )
              }),
              (u.prototype.readInt32BE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 4, this.length),
                  (this[t] << 24) |
                    (this[t + 1] << 16) |
                    (this[t + 2] << 8) |
                    this[t + 3]
                )
              }),
              (u.prototype.readFloatLE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 4, this.length),
                  a.read(this, t, !0, 23, 4)
                )
              }),
              (u.prototype.readFloatBE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 4, this.length),
                  a.read(this, t, !1, 23, 4)
                )
              }),
              (u.prototype.readDoubleLE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 8, this.length),
                  a.read(this, t, !0, 52, 8)
                )
              }),
              (u.prototype.readDoubleBE = function (t, e) {
                return (
                  (t >>>= 0),
                  e || b(t, 8, this.length),
                  a.read(this, t, !1, 52, 8)
                )
              }),
              (u.prototype.writeUIntLE = function (t, e, n, r) {
                ;(t = +t),
                  (e >>>= 0),
                  (n >>>= 0),
                  r || _(this, t, e, n, Math.pow(2, 8 * n) - 1, 0)
                var i = 1,
                  a = 0
                for (this[e] = 255 & t; ++a < n && (i *= 256); )
                  this[e + a] = (t / i) & 255
                return e + n
              }),
              (u.prototype.writeUIntBE = function (t, e, n, r) {
                ;(t = +t),
                  (e >>>= 0),
                  (n >>>= 0),
                  r || _(this, t, e, n, Math.pow(2, 8 * n) - 1, 0)
                var i = n - 1,
                  a = 1
                for (this[e + i] = 255 & t; 0 <= --i && (a *= 256); )
                  this[e + i] = (t / a) & 255
                return e + n
              }),
              (u.prototype.writeUInt8 = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || _(this, t, e, 1, 255, 0),
                  (this[e] = 255 & t),
                  e + 1
                )
              }),
              (u.prototype.writeUInt16LE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || _(this, t, e, 2, 65535, 0),
                  (this[e] = 255 & t),
                  (this[e + 1] = t >>> 8),
                  e + 2
                )
              }),
              (u.prototype.writeUInt16BE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || _(this, t, e, 2, 65535, 0),
                  (this[e] = t >>> 8),
                  (this[e + 1] = 255 & t),
                  e + 2
                )
              }),
              (u.prototype.writeUInt32LE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || _(this, t, e, 4, 4294967295, 0),
                  (this[e + 3] = t >>> 24),
                  (this[e + 2] = t >>> 16),
                  (this[e + 1] = t >>> 8),
                  (this[e] = 255 & t),
                  e + 4
                )
              }),
              (u.prototype.writeUInt32BE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || _(this, t, e, 4, 4294967295, 0),
                  (this[e] = t >>> 24),
                  (this[e + 1] = t >>> 16),
                  (this[e + 2] = t >>> 8),
                  (this[e + 3] = 255 & t),
                  e + 4
                )
              }),
              (u.prototype.writeIntLE = function (t, e, n, r) {
                var i
                ;(t = +t),
                  (e >>>= 0),
                  r || _(this, t, e, n, (i = Math.pow(2, 8 * n - 1)) - 1, -i)
                var a = 0,
                  o = 1,
                  s = 0
                for (this[e] = 255 & t; ++a < n && (o *= 256); )
                  t < 0 && 0 === s && 0 !== this[e + a - 1] && (s = 1),
                    (this[e + a] = (((t / o) >> 0) - s) & 255)
                return e + n
              }),
              (u.prototype.writeIntBE = function (t, e, n, r) {
                var i
                ;(t = +t),
                  (e >>>= 0),
                  r || _(this, t, e, n, (i = Math.pow(2, 8 * n - 1)) - 1, -i)
                var a = n - 1,
                  o = 1,
                  s = 0
                for (this[e + a] = 255 & t; 0 <= --a && (o *= 256); )
                  t < 0 && 0 === s && 0 !== this[e + a + 1] && (s = 1),
                    (this[e + a] = (((t / o) >> 0) - s) & 255)
                return e + n
              }),
              (u.prototype.writeInt8 = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || _(this, t, e, 1, 127, -128),
                  t < 0 && (t = 255 + t + 1),
                  (this[e] = 255 & t),
                  e + 1
                )
              }),
              (u.prototype.writeInt16LE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || _(this, t, e, 2, 32767, -32768),
                  (this[e] = 255 & t),
                  (this[e + 1] = t >>> 8),
                  e + 2
                )
              }),
              (u.prototype.writeInt16BE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || _(this, t, e, 2, 32767, -32768),
                  (this[e] = t >>> 8),
                  (this[e + 1] = 255 & t),
                  e + 2
                )
              }),
              (u.prototype.writeInt32LE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || _(this, t, e, 4, 2147483647, -2147483648),
                  (this[e] = 255 & t),
                  (this[e + 1] = t >>> 8),
                  (this[e + 2] = t >>> 16),
                  (this[e + 3] = t >>> 24),
                  e + 4
                )
              }),
              (u.prototype.writeInt32BE = function (t, e, n) {
                return (
                  (t = +t),
                  (e >>>= 0),
                  n || _(this, t, e, 4, 2147483647, -2147483648),
                  t < 0 && (t = 4294967295 + t + 1),
                  (this[e] = t >>> 24),
                  (this[e + 1] = t >>> 16),
                  (this[e + 2] = t >>> 8),
                  (this[e + 3] = 255 & t),
                  e + 4
                )
              }),
              (u.prototype.writeFloatLE = function (t, e, n) {
                return M(this, t, e, !0, n)
              }),
              (u.prototype.writeFloatBE = function (t, e, n) {
                return M(this, t, e, !1, n)
              }),
              (u.prototype.writeDoubleLE = function (t, e, n) {
                return S(this, t, e, !0, n)
              }),
              (u.prototype.writeDoubleBE = function (t, e, n) {
                return S(this, t, e, !1, n)
              }),
              (u.prototype.copy = function (t, e, n, r) {
                if (!u.isBuffer(t))
                  throw new TypeError('argument should be a Buffer')
                if (
                  ((n = n || 0),
                  r || 0 === r || (r = this.length),
                  e >= t.length && (e = t.length),
                  (e = e || 0),
                  0 < r && r < n && (r = n),
                  r === n)
                )
                  return 0
                if (0 === t.length || 0 === this.length) return 0
                if (e < 0) throw new RangeError('targetStart out of bounds')
                if (n < 0 || n >= this.length)
                  throw new RangeError('Index out of range')
                if (r < 0) throw new RangeError('sourceEnd out of bounds')
                r > this.length && (r = this.length),
                  t.length - e < r - n && (r = t.length - e + n)
                var i = r - n
                if (
                  this === t &&
                  'function' == typeof Uint8Array.prototype.copyWithin
                )
                  this.copyWithin(e, n, r)
                else if (this === t && n < e && e < r)
                  for (var a = i - 1; 0 <= a; --a) t[a + e] = this[a + n]
                else Uint8Array.prototype.set.call(t, this.subarray(n, r), e)
                return i
              }),
              (u.prototype.fill = function (t, e, n, r) {
                if ('string' == typeof t) {
                  if (
                    ('string' == typeof e
                      ? ((r = e), (e = 0), (n = this.length))
                      : 'string' == typeof n && ((r = n), (n = this.length)),
                    void 0 !== r && 'string' != typeof r)
                  )
                    throw new TypeError('encoding must be a string')
                  if ('string' == typeof r && !u.isEncoding(r))
                    throw new TypeError('Unknown encoding: ' + r)
                  var i
                  1 === t.length &&
                    ((i = t.charCodeAt(0)),
                    (('utf8' === r && i < 128) || 'latin1' === r) && (t = i))
                } else 'number' == typeof t && (t &= 255)
                if (e < 0 || this.length < e || this.length < n)
                  throw new RangeError('Out of range index')
                if (n <= e) return this
                var a
                if (
                  ((e >>>= 0),
                  (n = void 0 === n ? this.length : n >>> 0),
                  'number' == typeof (t = t || 0))
                )
                  for (a = e; a < n; ++a) this[a] = t
                else {
                  var o = u.isBuffer(t) ? t : u.from(t, r),
                    s = o.length
                  if (0 === s)
                    throw new TypeError(
                      'The value "' + t + '" is invalid for argument "value"',
                    )
                  for (a = 0; a < n - e; ++a) this[a + e] = o[a % s]
                }
                return this
              })
            var E = /[^+/0-9A-Za-z-_]/g
            function T(t, e) {
              var n
              e = e || 1 / 0
              for (var r = t.length, i = null, a = [], o = 0; o < r; ++o) {
                if (55295 < (n = t.charCodeAt(o)) && n < 57344) {
                  if (!i) {
                    if (56319 < n) {
                      ;-1 < (e -= 3) && a.push(239, 191, 189)
                      continue
                    }
                    if (o + 1 === r) {
                      ;-1 < (e -= 3) && a.push(239, 191, 189)
                      continue
                    }
                    i = n
                    continue
                  }
                  if (n < 56320) {
                    ;-1 < (e -= 3) && a.push(239, 191, 189), (i = n)
                    continue
                  }
                  n = 65536 + (((i - 55296) << 10) | (n - 56320))
                } else i && -1 < (e -= 3) && a.push(239, 191, 189)
                if (((i = null), n < 128)) {
                  if (--e < 0) break
                  a.push(n)
                } else if (n < 2048) {
                  if ((e -= 2) < 0) break
                  a.push((n >> 6) | 192, (63 & n) | 128)
                } else if (n < 65536) {
                  if ((e -= 3) < 0) break
                  a.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128)
                } else {
                  if (!(n < 1114112)) throw new Error('Invalid code point')
                  if ((e -= 4) < 0) break
                  a.push(
                    (n >> 18) | 240,
                    ((n >> 12) & 63) | 128,
                    ((n >> 6) & 63) | 128,
                    (63 & n) | 128,
                  )
                }
              }
              return a
            }
            function A(t) {
              return s.toByteArray(
                (function (t) {
                  if (
                    (t = (t = t.split('=')[0]).trim().replace(E, '')).length < 2
                  )
                    return ''
                  for (; t.length % 4 != 0; ) t += '='
                  return t
                })(t),
              )
            }
            function L(t, e, n, r) {
              for (
                var i = 0;
                i < r && !(i + n >= e.length || i >= t.length);
                ++i
              )
                e[i + n] = t[i]
              return i
            }
            function R(t, e) {
              return (
                t instanceof e ||
                (null != t &&
                  null != t.constructor &&
                  null != t.constructor.name &&
                  t.constructor.name === e.name)
              )
            }
            function C(t) {
              return t != t
            }
          }).call(this, t('buffer').Buffer)
        },
        { 'base64-js': 3, 'buffer': 5, 'ieee754': 8 },
      ],
      6: [
        function (t, e, n) {
          e.exports = function (t) {
            switch (t) {
              case 'int8':
                return Int8Array
              case 'int16':
                return Int16Array
              case 'int32':
                return Int32Array
              case 'uint8':
                return Uint8Array
              case 'uint16':
                return Uint16Array
              case 'uint32':
                return Uint32Array
              case 'float32':
                return Float32Array
              case 'float64':
                return Float64Array
              case 'array':
                return Array
              case 'uint8_clamped':
                return Uint8ClampedArray
            }
          }
        },
        {},
      ],
      7: [
        function (t, n, e) {
          ;(function (t) {
            var e =
              'undefined' != typeof window
                ? window
                : void 0 !== t
                  ? t
                  : 'undefined' != typeof self
                    ? self
                    : {}
            n.exports = e
          }).call(
            this,
            'undefined' != typeof global
              ? global
              : 'undefined' != typeof self
                ? self
                : 'undefined' != typeof window
                  ? window
                  : {},
          )
        },
        {},
      ],
      8: [
        function (t, e, n) {
          ;(n.read = function (t, e, n, r, i) {
            var a,
              o,
              s = 8 * i - r - 1,
              c = (1 << s) - 1,
              l = c >> 1,
              h = -7,
              u = n ? i - 1 : 0,
              p = n ? -1 : 1,
              d = t[e + u]
            for (
              u += p, a = d & ((1 << -h) - 1), d >>= -h, h += s;
              0 < h;
              a = 256 * a + t[e + u], u += p, h -= 8
            );
            for (
              o = a & ((1 << -h) - 1), a >>= -h, h += r;
              0 < h;
              o = 256 * o + t[e + u], u += p, h -= 8
            );
            if (0 === a) a = 1 - l
            else {
              if (a === c) return o ? NaN : (1 / 0) * (d ? -1 : 1)
              ;(o += Math.pow(2, r)), (a -= l)
            }
            return (d ? -1 : 1) * o * Math.pow(2, a - r)
          }),
            (n.write = function (t, e, n, r, i, a) {
              var o,
                s,
                c,
                l = 8 * a - i - 1,
                h = (1 << l) - 1,
                u = h >> 1,
                p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                d = r ? 0 : a - 1,
                f = r ? 1 : -1,
                m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0
              for (
                e = Math.abs(e),
                  isNaN(e) || e === 1 / 0
                    ? ((s = isNaN(e) ? 1 : 0), (o = h))
                    : ((o = Math.floor(Math.log(e) / Math.LN2)),
                      e * (c = Math.pow(2, -o)) < 1 && (o--, (c *= 2)),
                      2 <=
                        (e += 1 <= o + u ? p / c : p * Math.pow(2, 1 - u)) *
                          c && (o++, (c /= 2)),
                      h <= o + u
                        ? ((s = 0), (o = h))
                        : 1 <= o + u
                          ? ((s = (e * c - 1) * Math.pow(2, i)), (o += u))
                          : ((s = e * Math.pow(2, u - 1) * Math.pow(2, i)),
                            (o = 0)));
                8 <= i;
                t[n + d] = 255 & s, d += f, s /= 256, i -= 8
              );
              for (
                o = (o << i) | s, l += i;
                0 < l;
                t[n + d] = 255 & o, d += f, o /= 256, l -= 8
              );
              t[n + d - f] |= 128 * m
            })
        },
        {},
      ],
      9: [
        function (t, e, n) {
          'function' == typeof Object.create
            ? (e.exports = function (t, e) {
                e &&
                  ((t.super_ = e),
                  (t.prototype = Object.create(e.prototype, {
                    constructor: {
                      value: t,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0,
                    },
                  })))
              })
            : (e.exports = function (t, e) {
                var n
                e &&
                  ((t.super_ = e),
                  ((n = function () {}).prototype = e.prototype),
                  (t.prototype = new n()),
                  (t.prototype.constructor = t))
              })
        },
        {},
      ],
      10: [
        function (t, e, n) {
          function r(t) {
            return (
              !!t.constructor &&
              'function' == typeof t.constructor.isBuffer &&
              t.constructor.isBuffer(t)
            )
          }
          e.exports = function (t) {
            return (
              null != t &&
              (r(t) ||
                ('function' == typeof (e = t).readFloatLE &&
                  'function' == typeof e.slice &&
                  r(e.slice(0, 0))) ||
                !!t._isBuffer)
            )
            var e
          }
        },
        {},
      ],
      11: [
        function (t, e, n) {
          e.exports = function (t) {
            if (!t) return !1
            var e = r.call(t)
            return (
              '[object Function]' === e ||
              ('function' == typeof t && '[object RegExp]' !== e) ||
              ('undefined' != typeof window &&
                (t === window.setTimeout ||
                  t === window.alert ||
                  t === window.confirm ||
                  t === window.prompt))
            )
          }
          var r = Object.prototype.toString
        },
        {},
      ],
      12: [
        function (t, e, n) {
          var o = t('word-wrapper'),
            s = t('xtend'),
            c = t('as-number'),
            l = [
              'x',
              'e',
              'a',
              'o',
              'n',
              's',
              'r',
              'c',
              'u',
              'm',
              'v',
              'w',
              'z',
            ],
            i = ['m', 'w'],
            b = [
              'H',
              'I',
              'N',
              'E',
              'F',
              'K',
              'L',
              'T',
              'U',
              'V',
              'W',
              'X',
              'Y',
              'Z',
            ],
            r = '\t'.charCodeAt(0),
            a = ' '.charCodeAt(0)
          function h(t) {
            ;(this.glyphs = []),
              (this._measure = this.computeMetrics.bind(this)),
              this.update(t)
          }
          function u(t, e) {
            if (!t.chars || 0 === t.chars.length) return null
            var n = w(t.chars, e)
            return 0 <= n ? t.chars[n] : null
          }
          function _(t, e, n) {
            if (!t.kernings || 0 === t.kernings.length) return 0
            for (var r = t.kernings, i = 0; i < r.length; i++) {
              var a = r[i]
              if (a.first === e && a.second === n) return a.amount
            }
            return 0
          }
          function w(t, e, n) {
            for (var r = (n = n || 0); r < t.length; r++)
              if (t[r].id === e) return r
            return -1
          }
          ;(e.exports = function (t) {
            return new h(t)
          }),
            (h.prototype.update = function (t) {
              if (
                ((t = s({ measure: this._measure }, t)),
                (this._opt = t),
                (this._opt.tabSize = c(this._opt.tabSize, 4)),
                !t.font)
              )
                throw new Error('must provide a valid bitmap font')
              var h = this.glyphs,
                u = t.text || '',
                p = t.font
              this._setupSpaceGlyphs(p)
              var e = o.lines(u, t),
                n = t.width || 0
              h.length = 0
              var d = e.reduce(function (t, e) {
                  return Math.max(t, e.width, n)
                }, 0),
                f = 0,
                m = 0,
                v = c(t.lineHeight, p.common.lineHeight),
                r = p.common.base,
                i = v - r,
                g = t.letterSpacing || 0,
                a = v * e.length - i,
                y = (function (t) {
                  {
                    if ('center' === t) return 1
                    if ('right' === t) return 2
                  }
                  return 0
                })(this._opt.align)
              ;(m -= a),
                (this._width = d),
                (this._height = a),
                (this._descender = v - r),
                (this._baseline = r),
                (this._xHeight = (function (t) {
                  for (var e = 0; e < l.length; e++) {
                    var n = l[e].charCodeAt(0),
                      r = w(t.chars, n)
                    if (0 <= r) return t.chars[r].height
                  }
                  return 0
                })(p)),
                (this._capHeight = (function (t) {
                  for (var e = 0; e < b.length; e++) {
                    var n = b[e].charCodeAt(0),
                      r = w(t.chars, n)
                    if (0 <= r) return t.chars[r].height
                  }
                  return 0
                })(p)),
                (this._lineHeight = v),
                (this._ascender = v - i - this._xHeight)
              var x = this
              e.forEach(function (t, e) {
                for (
                  var n, r = t.start, i = t.end, a = t.width, o = r;
                  o < i;
                  o++
                ) {
                  var s,
                    c = u.charCodeAt(o),
                    l = x.getGlyph(p, c)
                  l &&
                    (n && (f += _(p, n.id, l.id)),
                    (s = f),
                    1 === y ? (s += (d - a) / 2) : 2 === y && (s += d - a),
                    h.push({ position: [s, m], data: l, index: o, line: e }),
                    (f += l.xadvance + g),
                    (n = l))
                }
                ;(m += v), (f = 0)
              }),
                (this._linesTotal = e.length)
            }),
            (h.prototype._setupSpaceGlyphs = function (t) {
              var e, n
              ;(this._fallbackSpaceGlyph = null),
                (this._fallbackTabGlyph = null),
                t.chars &&
                  0 !== t.chars.length &&
                  ((e =
                    u(t, a) ||
                    (function (t) {
                      for (var e = 0; e < i.length; e++) {
                        var n = i[e].charCodeAt(0),
                          r = w(t.chars, n)
                        if (0 <= r) return t.chars[r]
                      }
                      return 0
                    })(t) ||
                    t.chars[0]),
                  (n = this._opt.tabSize * e.xadvance),
                  (this._fallbackSpaceGlyph = e),
                  (this._fallbackTabGlyph = s(e, {
                    x: 0,
                    y: 0,
                    xadvance: n,
                    id: r,
                    xoffset: 0,
                    yoffset: 0,
                    width: 0,
                    height: 0,
                  })))
            }),
            (h.prototype.getGlyph = function (t, e) {
              var n = u(t, e)
              return (
                n ||
                (e === r
                  ? this._fallbackTabGlyph
                  : e === a
                    ? this._fallbackSpaceGlyph
                    : null)
              )
            }),
            (h.prototype.computeMetrics = function (t, e, n, r) {
              var i,
                a = this._opt.letterSpacing || 0,
                o = this._opt.font,
                s = 0,
                c = 0,
                l = 0
              if (!o.chars || 0 === o.chars.length)
                return { start: e, end: e, width: 0 }
              n = Math.min(t.length, n)
              for (var h = e; h < n; h++) {
                var u,
                  p = t.charCodeAt(h)
                if ((u = this.getGlyph(o, p))) {
                  u.xoffset
                  var d = (s += i ? _(o, i.id, u.id) : 0) + u.xadvance + a,
                    f = s + u.width
                  if (r <= f || r <= d) break
                  ;(s = d), (c = f), (i = u)
                }
                l++
              }
              return i && (c += i.xoffset), { start: e, end: e + l, width: c }
            }),
            [
              'width',
              'height',
              'descender',
              'ascender',
              'xHeight',
              'baseline',
              'capHeight',
              'lineHeight',
            ].forEach(function (t) {
              Object.defineProperty(h.prototype, t, {
                get: (function (t) {
                  return new Function(
                    [
                      'return function ' + t + '() {',
                      '  return this._' + t,
                      '}',
                    ].join('\n'),
                  )()
                })(t),
                configurable: !0,
              })
            })
        },
        { 'as-number': 2, 'word-wrapper': 25, 'xtend': 28 },
      ],
      13: [
        function (e, i, t) {
          ;(function (h) {
            function u() {}
            var t = e('xhr'),
              p = e('parse-bmfont-ascii'),
              d = e('parse-bmfont-xml'),
              f = e('parse-bmfont-binary'),
              m = e('./lib/is-binary'),
              n = e('xtend'),
              r =
                self.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()
            i.exports = function (c, l) {
              ;(l = 'function' == typeof l ? l : u),
                (c = 'string' == typeof c ? { uri: c } : c || {}).binary &&
                  (c = (function (t) {
                    if (r) return n(t, { responseType: 'arraybuffer' })
                    if (void 0 === self.XMLHttpRequest)
                      throw new Error(
                        'your browser does not support XHR loading',
                      )
                    var e = new self.XMLHttpRequest()
                    return (
                      e.overrideMimeType('text/plain; charset=x-user-defined'),
                      n({ xhr: e }, t)
                    )
                  })(c)),
                t(c, function (t, e, n) {
                  if (t) return l(t)
                  if (!/^2/.test(e.statusCode))
                    return l(new Error('http status code: ' + e.statusCode))
                  if (!n) return l(new Error('no body result'))
                  var r,
                    i,
                    a = !1
                  ;(i = n),
                    '[object ArrayBuffer]' ===
                      Object.prototype.toString.call(i) &&
                      ((r = new Uint8Array(n)), (n = h.from(r, 'binary'))),
                    m(n) &&
                      ((a = !0),
                      'string' == typeof n && (n = h.from(n, 'binary'))),
                    a ||
                      (h.isBuffer(n) && (n = n.toString(c.encoding)),
                      (n = n.trim()))
                  try {
                    var o = e.headers['content-type'],
                      s = a
                        ? f(n)
                        : /json/.test(o) || '{' === n.charAt(0)
                          ? JSON.parse(n)
                          : (/xml/.test(o) || '<' === n.charAt(0) ? d : p)(n)
                  } catch (t) {
                    l(new Error('error parsing font ' + t.message)), (l = u)
                  }
                  l(null, s)
                })
            }
          }).call(this, e('buffer').Buffer)
        },
        {
          './lib/is-binary': 14,
          'buffer': 5,
          'parse-bmfont-ascii': 15,
          'parse-bmfont-binary': 16,
          'parse-bmfont-xml': 17,
          'xhr': 26,
          'xtend': 28,
        },
      ],
      14: [
        function (r, i, t) {
          ;(function (t) {
            var e = r('buffer-equal'),
              n = t.from([66, 77, 70, 3])
            i.exports = function (t) {
              return 'string' == typeof t
                ? 'BMF' === t.substring(0, 3)
                : 4 < t.length && e(t.slice(0, 4), n)
            }
          }).call(this, r('buffer').Buffer)
        },
        { 'buffer': 5, 'buffer-equal': 4 },
      ],
      15: [
        function (t, e, n) {
          function c(t) {
            return t && 0 !== t.length
              ? 0 === t.indexOf('"') || 0 === t.indexOf("'")
                ? t.substring(1, t.length - 1)
                : -1 !== t.indexOf(',')
                  ? t.split(',').map(function (t) {
                      return parseInt(t, 10)
                    })
                  : parseInt(t, 10)
              : ''
          }
          e.exports = function (t) {
            if (!t) throw new Error('no data provided')
            var e = { pages: [], chars: [], kernings: [] },
              n = (t = t.toString().trim()).split(/\r\n?|\n/g)
            if (0 === n.length) throw new Error('no data in BMFont file')
            for (var r = 0; r < n.length; r++) {
              var i = (function (t, e) {
                if (!(t = t.replace(/\t+/g, ' ').trim())) return null
                var n = t.indexOf(' ')
                if (-1 === n) throw new Error('no named row at line ' + e)
                var r = t.substring(0, n)
                t = (t = (t = (t = t.substring(n + 1)).replace(
                  /letter=[\'\"]\S+[\'\"]/gi,
                  '',
                )).split('=')).map(function (t) {
                  return t.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g)
                })
                for (var i = [], a = 0; a < t.length; a++) {
                  var o = t[a]
                  0 === a
                    ? i.push({ key: o[0], data: '' })
                    : a === t.length - 1
                      ? (i[i.length - 1].data = c(o[0]))
                      : ((i[i.length - 1].data = c(o[0])),
                        i.push({ key: o[1], data: '' }))
                }
                var s = { key: r, data: {} }
                return (
                  i.forEach(function (t) {
                    s.data[t.key] = t.data
                  }),
                  s
                )
              })(n[r], r)
              if (i)
                if ('page' === i.key) {
                  if ('number' != typeof i.data.id)
                    throw new Error(
                      'malformed file at line ' + r + ' -- needs page id=N',
                    )
                  if ('string' != typeof i.data.file)
                    throw new Error(
                      'malformed file at line ' +
                        r +
                        ' -- needs page file="path"',
                    )
                  e.pages[i.data.id] = i.data.file
                } else
                  'chars' === i.key ||
                    'kernings' === i.key ||
                    ('char' === i.key
                      ? e.chars.push(i.data)
                      : 'kerning' === i.key
                        ? e.kernings.push(i.data)
                        : (e[i.key] = i.data))
            }
            return e
          }
        },
        {},
      ],
      16: [
        function (t, e, n) {
          var i = [66, 77, 70]
          function c(t, e) {
            for (var n = e; n < t.length && 0 !== t[n]; n++);
            return t.slice(e, n)
          }
          e.exports = function (n) {
            if (n.length < 6)
              throw new Error('invalid buffer length for BMFont')
            if (
              !i.every(function (t, e) {
                return n.readUInt8(e) === t
              })
            )
              throw new Error('BMFont missing BMF byte header')
            var t = 3
            if (3 < n.readUInt8(t++))
              throw new Error(
                'Only supports BMFont Binary v3 (BMFont App v1.10)',
              )
            for (var e = { kernings: [], chars: [] }, r = 0; r < 5; r++)
              t += (function (t, e, n) {
                if (n > e.length - 1) return 0
                var r = e.readUInt8(n++),
                  i = e.readInt32LE(n)
                switch (((n += 4), r)) {
                  case 1:
                    t.info = (function (t, e) {
                      var n = {}
                      n.size = t.readInt16LE(e)
                      var r = t.readUInt8(e + 2)
                      ;(n.smooth = (r >> 7) & 1),
                        (n.unicode = (r >> 6) & 1),
                        (n.italic = (r >> 5) & 1),
                        (n.bold = (r >> 4) & 1),
                        (r >> 3) & 1 && (n.fixedHeight = 1)
                      return (
                        (n.charset = t.readUInt8(e + 3) || ''),
                        (n.stretchH = t.readUInt16LE(e + 4)),
                        (n.aa = t.readUInt8(e + 6)),
                        (n.padding = [
                          t.readInt8(e + 7),
                          t.readInt8(e + 8),
                          t.readInt8(e + 9),
                          t.readInt8(e + 10),
                        ]),
                        (n.spacing = [t.readInt8(e + 11), t.readInt8(e + 12)]),
                        (n.outline = t.readUInt8(e + 13)),
                        (n.face = (function (t, e) {
                          return c(t, e).toString('utf8')
                        })(t, e + 14)),
                        n
                      )
                    })(e, n)
                    break
                  case 2:
                    t.common = (function (t, e) {
                      var n = {}
                      ;(n.lineHeight = t.readUInt16LE(e)),
                        (n.base = t.readUInt16LE(e + 2)),
                        (n.scaleW = t.readUInt16LE(e + 4)),
                        (n.scaleH = t.readUInt16LE(e + 6)),
                        (n.pages = t.readUInt16LE(e + 8))
                      t.readUInt8(e + 10)
                      return (
                        (n.packed = 0),
                        (n.alphaChnl = t.readUInt8(e + 11)),
                        (n.redChnl = t.readUInt8(e + 12)),
                        (n.greenChnl = t.readUInt8(e + 13)),
                        (n.blueChnl = t.readUInt8(e + 14)),
                        n
                      )
                    })(e, n)
                    break
                  case 3:
                    t.pages = (function (t, e, n) {
                      for (
                        var r = [],
                          i = c(t, e),
                          a = i.length + 1,
                          o = n / a,
                          s = 0;
                        s < o;
                        s++
                      )
                        (r[s] = t.slice(e, e + i.length).toString('utf8')),
                          (e += a)
                      return r
                    })(e, n, i)
                    break
                  case 4:
                    t.chars = (function (t, e, n) {
                      for (var r = [], i = n / 20, a = 0; a < i; a++) {
                        var o = {},
                          s = 20 * a
                        ;(o.id = t.readUInt32LE(e + 0 + s)),
                          (o.x = t.readUInt16LE(e + 4 + s)),
                          (o.y = t.readUInt16LE(e + 6 + s)),
                          (o.width = t.readUInt16LE(e + 8 + s)),
                          (o.height = t.readUInt16LE(e + 10 + s)),
                          (o.xoffset = t.readInt16LE(e + 12 + s)),
                          (o.yoffset = t.readInt16LE(e + 14 + s)),
                          (o.xadvance = t.readInt16LE(e + 16 + s)),
                          (o.page = t.readUInt8(e + 18 + s)),
                          (o.chnl = t.readUInt8(e + 19 + s)),
                          (r[a] = o)
                      }
                      return r
                    })(e, n, i)
                    break
                  case 5:
                    t.kernings = (function (t, e, n) {
                      for (var r = [], i = n / 10, a = 0; a < i; a++) {
                        var o = {},
                          s = 10 * a
                        ;(o.first = t.readUInt32LE(e + 0 + s)),
                          (o.second = t.readUInt32LE(e + 4 + s)),
                          (o.amount = t.readInt16LE(e + 8 + s)),
                          (r[a] = o)
                      }
                      return r
                    })(e, n, i)
                }
                return 5 + i
              })(e, n, t)
            return e
          }
        },
        {},
      ],
      17: [
        function (t, e, n) {
          var l = t('./parse-attribs'),
            h = t('xml-parse-from-string'),
            r = {
              scaleh: 'scaleH',
              scalew: 'scaleW',
              stretchh: 'stretchH',
              lineheight: 'lineHeight',
              alphachnl: 'alphaChnl',
              redchnl: 'redChnl',
              greenchnl: 'greenChnl',
              bluechnl: 'blueChnl',
            }
          function u(t) {
            return (function (t) {
              for (var e = [], n = 0; n < t.attributes.length; n++)
                e.push(t.attributes[n])
              return e
            })(t).reduce(function (t, e) {
              var n
              return (
                (t[((n = e.nodeName), r[n.toLowerCase()] || n)] = e.nodeValue),
                t
              )
            }, {})
          }
          e.exports = function (t) {
            t = t.toString()
            var o = h(t),
              s = { pages: [], chars: [], kernings: [] }
            ;['info', 'common'].forEach(function (t) {
              var e = o.getElementsByTagName(t)[0]
              e && (s[t] = l(u(e)))
            })
            var e = o.getElementsByTagName('pages')[0]
            if (!e) throw new Error('malformed file -- no <pages> element')
            for (
              var n = e.getElementsByTagName('page'), r = 0;
              r < n.length;
              r++
            ) {
              var i = n[r],
                a = parseInt(i.getAttribute('id'), 10),
                c = i.getAttribute('file')
              if (isNaN(a))
                throw new Error('malformed file -- page "id" attribute is NaN')
              if (!c)
                throw new Error('malformed file -- needs page "file" attribute')
              s.pages[parseInt(a, 10)] = c
            }
            return (
              ['chars', 'kernings'].forEach(function (t) {
                var e = o.getElementsByTagName(t)[0]
                if (e)
                  for (
                    var n = t.substring(0, t.length - 1),
                      r = e.getElementsByTagName(n),
                      i = 0;
                    i < r.length;
                    i++
                  ) {
                    var a = r[i]
                    s[t].push(l(u(a)))
                  }
              }),
              s
            )
          }
        },
        { './parse-attribs': 18, 'xml-parse-from-string': 27 },
      ],
      18: [
        function (t, e, n) {
          var r = 'chasrset'
          e.exports = function (t) {
            for (var e in (r in t && ((t.charset = t[r]), delete t[r]), t))
              'face' !== e &&
                'charset' !== e &&
                (t[e] =
                  'padding' === e || 'spacing' === e
                    ? t[e].split(',').map(function (t) {
                        return parseInt(t, 10)
                      })
                    : parseInt(t[e], 10))
            return t
          }
        },
        {},
      ],
      19: [
        function (t, e, n) {
          function l(t) {
            return t.replace(/^\s+|\s+$/g, '')
          }
          e.exports = function (t) {
            if (!t) return {}
            for (
              var e, n = {}, r = l(t).split('\n'), i = 0;
              i < r.length;
              i++
            ) {
              var a = r[i],
                o = a.indexOf(':'),
                s = l(a.slice(0, o)).toLowerCase(),
                c = l(a.slice(o + 1))
              void 0 === n[s]
                ? (n[s] = c)
                : ((e = n[s]),
                  '[object Array]' === Object.prototype.toString.call(e)
                    ? n[s].push(c)
                    : (n[s] = [n[s], c]))
            }
            return n
          }
        },
        {},
      ],
      20: [
        function (t, e, n) {
          var f = t('dtype'),
            m = t('an-array'),
            v = t('is-buffer'),
            g = [0, 2, 3],
            y = [2, 1, 3]
          e.exports = function (t, e) {
            ;(t && (m(t) || v(t))) || ((e = t || {}), (t = null))
            for (
              var n =
                  'string' ==
                  typeof (e = 'number' == typeof e ? { count: e } : e || {})
                    .type
                    ? e.type
                    : 'uint16',
                r = 'number' == typeof e.count ? e.count : 1,
                i = e.start || 0,
                a = !1 !== e.clockwise ? g : y,
                o = a[0],
                s = a[1],
                c = a[2],
                l = 6 * r,
                h = t || new (f(n))(l),
                u = 0,
                p = 0;
              u < l;
              u += 6, p += 4
            ) {
              var d = u + i
              ;(h[d + 0] = p + 0),
                (h[d + 1] = p + 1),
                (h[d + 2] = p + 2),
                (h[d + 3] = p + o),
                (h[d + 4] = p + s),
                (h[d + 5] = p + c)
            }
            return h
          }
        },
        { 'an-array': 1, 'dtype': 6, 'is-buffer': 10 },
      ],
      21: [
        function (t, e, n) {
          var h = t('layout-bmfont-text'),
            r = t('inherits'),
            u = t('quad-indices'),
            p = t('./lib/vertices'),
            i = t('./lib/utils'),
            a = THREE.BufferGeometry
          function o(t) {
            a.call(this),
              'string' == typeof t && (t = { text: t }),
              (this._opt = Object.assign({}, t)),
              t && this.update(t)
          }
          ;(e.exports = function (t) {
            return new o(t)
          }),
            r(o, a),
            (o.prototype.update = function (t) {
              if (
                ('string' == typeof t && (t = { text: t }),
                !(t = Object.assign({}, this._opt, t)).font)
              )
                throw new TypeError('must specify a { font } in options')
              this.layout = h(t)
              var e = !1 !== t.flipY,
                n = t.font,
                r = n.common.scaleW,
                i = n.common.scaleH,
                a = this.layout.glyphs.filter(function (t) {
                  var e = t.data
                  return 0 < e.width * e.height
                })
              this.visibleGlyphs = a
              var o,
                s = p.positions(a),
                c = p.uvs(a, r, i, e),
                l = u([], { clockwise: !0, type: 'uint16', count: a.length })
              this.setIndex(l),
                this.setAttribute('position', new THREE.BufferAttribute(s, 2)),
                this.setAttribute('uv', new THREE.BufferAttribute(c, 2)),
                !t.multipage && 'page' in this.attributes
                  ? this.removeAttribute('page')
                  : t.multipage &&
                    ((o = p.pages(a)),
                    this.setAttribute('page', new THREE.BufferAttribute(o, 1)))
            }),
            (o.prototype.computeBoundingSphere = function () {
              null === this.boundingSphere &&
                (this.boundingSphere = new THREE.Sphere())
              var t = this.attributes.position.array,
                e = this.attributes.position.itemSize
              if (!t || !e || t.length < 2)
                return (
                  (this.boundingSphere.radius = 0),
                  void this.boundingSphere.center.set(0, 0, 0)
                )
              i.computeSphere(t, this.boundingSphere),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  )
            }),
            (o.prototype.computeBoundingBox = function () {
              null === this.boundingBox && (this.boundingBox = new THREE.Box3())
              var t = this.boundingBox,
                e = this.attributes.position.array,
                n = this.attributes.position.itemSize
              !e || !n || e.length < 2 ? t.makeEmpty() : i.computeBox(e, t)
            })
        },
        {
          './lib/utils': 22,
          './lib/vertices': 23,
          'inherits': 9,
          'layout-bmfont-text': 12,
          'quad-indices': 20,
        },
      ],
      22: [
        function (t, e, n) {
          var s = { min: [0, 0], max: [0, 0] }
          function c(t) {
            var e = t.length / 2
            ;(s.min[0] = t[0]),
              (s.min[1] = t[1]),
              (s.max[0] = t[0]),
              (s.max[1] = t[1])
            for (var n = 0; n < e; n++) {
              var r = t[2 * n + 0],
                i = t[2 * n + 1]
              ;(s.min[0] = Math.min(r, s.min[0])),
                (s.min[1] = Math.min(i, s.min[1])),
                (s.max[0] = Math.max(r, s.max[0])),
                (s.max[1] = Math.max(i, s.max[1]))
            }
          }
          ;(e.exports.computeBox = function (t, e) {
            c(t),
              e.min.set(s.min[0], s.min[1], 0),
              e.max.set(s.max[0], s.max[1], 0)
          }),
            (e.exports.computeSphere = function (t, e) {
              c(t)
              var n = s.min[0],
                r = s.min[1],
                i = s.max[0] - n,
                a = s.max[1] - r,
                o = Math.sqrt(i * i + a * a)
              e.center.set(n + i / 2, r + a / 2, 0), (e.radius = o / 2)
            })
        },
        {},
      ],
      23: [
        function (t, e, n) {
          ;(e.exports.pages = function (t) {
            var n = new Float32Array(4 * t.length * 1),
              r = 0
            return (
              t.forEach(function (t) {
                var e = t.data.page || 0
                ;(n[r++] = e), (n[r++] = e), (n[r++] = e), (n[r++] = e)
              }),
              n
            )
          }),
            (e.exports.uvs = function (t, c, l, h) {
              var u = new Float32Array(4 * t.length * 2),
                p = 0
              return (
                t.forEach(function (t) {
                  var e = t.data,
                    n = e.x + e.width,
                    r = e.y + e.height,
                    i = e.x / c,
                    a = e.y / l,
                    o = n / c,
                    s = r / l
                  h && ((a = (l - e.y) / l), (s = (l - r) / l)),
                    (u[p++] = i),
                    (u[p++] = a),
                    (u[p++] = i),
                    (u[p++] = s),
                    (u[p++] = o),
                    (u[p++] = s),
                    (u[p++] = o),
                    (u[p++] = a)
                }),
                u
              )
            }),
            (e.exports.positions = function (t) {
              var o = new Float32Array(4 * t.length * 2),
                s = 0
              return (
                t.forEach(function (t) {
                  var e = t.data,
                    n = t.position[0] + e.xoffset,
                    r = t.position[1] + e.yoffset,
                    i = e.width,
                    a = e.height
                  ;(o[s++] = n),
                    (o[s++] = r),
                    (o[s++] = n),
                    (o[s++] = r + a),
                    (o[s++] = n + i),
                    (o[s++] = r + a),
                    (o[s++] = n + i),
                    (o[s++] = r)
                }),
                o
              )
            })
        },
        {},
      ],
      24: [
        function (t, e, n) {
          var r, i
          ;(r = this),
            (i = function (t) {
              'use strict'
              void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
                void 0 === Number.isInteger &&
                  (Number.isInteger = function (t) {
                    return (
                      'number' == typeof t && isFinite(t) && Math.floor(t) === t
                    )
                  }),
                void 0 === Math.sign &&
                  (Math.sign = function (t) {
                    return t < 0 ? -1 : 0 < t ? 1 : +t
                  }),
                'name' in Function.prototype == !1 &&
                  Object.defineProperty(Function.prototype, 'name', {
                    get: function () {
                      return this.toString().match(
                        /^\s*function\s*([^\(\s]*)/,
                      )[1]
                    },
                  }),
                void 0 === Object.assign &&
                  (Object.assign = function (t) {
                    if (null == t)
                      throw new TypeError(
                        'Cannot convert undefined or null to object',
                      )
                    for (var e = Object(t), n = 1; n < arguments.length; n++) {
                      var r = arguments[n]
                      if (null != r)
                        for (var i in r)
                          Object.prototype.hasOwnProperty.call(r, i) &&
                            (e[i] = r[i])
                    }
                    return e
                  })
              var V = 0,
                j = 1,
                W = 2,
                z = 1,
                F = 2,
                H = 3,
                O = 0,
                q = 1,
                X = 2,
                Y = 0,
                Z = 1,
                J = 2,
                Q = 3,
                K = 4,
                $ = 5,
                tt = 100,
                et = 101,
                nt = 102,
                rt = 103,
                it = 104,
                at = 200,
                ot = 201,
                st = 202,
                ct = 203,
                lt = 204,
                ht = 205,
                ut = 206,
                pt = 207,
                dt = 208,
                ft = 209,
                mt = 210,
                vt = 0,
                gt = 1,
                yt = 2,
                xt = 3,
                bt = 4,
                _t = 5,
                wt = 6,
                Mt = 7,
                G = 0,
                k = 1,
                St = 2,
                Et = 0,
                Tt = 1,
                At = 2,
                Lt = 3,
                Rt = 4,
                Ct = 5,
                Pt = 301,
                Ot = 302,
                It = 303,
                Dt = 304,
                Bt = 306,
                Nt = 307,
                Ut = 1e3,
                zt = 1001,
                Ft = 1002,
                Ht = 1003,
                Gt = 1004,
                kt = 1005,
                Vt = 1006,
                jt = 1007,
                Wt = 1008,
                qt = 1009,
                i = 1010,
                a = 1011,
                Xt = 1012,
                o = 1013,
                Yt = 1014,
                Zt = 1015,
                Jt = 1016,
                s = 1017,
                c = 1018,
                l = 1019,
                Qt = 1020,
                h = 1021,
                Kt = 1022,
                $t = 1023,
                u = 1024,
                p = 1025,
                d = $t,
                te = 1026,
                ee = 1027,
                f = 1028,
                m = 1029,
                v = 1030,
                g = 1031,
                y = 1032,
                x = 1033,
                b = 33776,
                _ = 33777,
                w = 33778,
                M = 33779,
                S = 35840,
                E = 35841,
                T = 35842,
                A = 35843,
                L = 36196,
                R = 37492,
                C = 37496,
                P = 37808,
                I = 37809,
                D = 37810,
                B = 37811,
                N = 37812,
                U = 37813,
                ne = 37814,
                re = 37815,
                ie = 37816,
                ae = 37817,
                oe = 37818,
                se = 37819,
                ce = 37820,
                le = 37821,
                he = 36492,
                ue = 37840,
                pe = 37841,
                de = 37842,
                fe = 37843,
                me = 37844,
                ve = 37845,
                ge = 37846,
                ye = 37847,
                xe = 37848,
                be = 37849,
                _e = 37850,
                we = 37851,
                Me = 37852,
                Se = 37853,
                r = 2300,
                Ee = 2301,
                Te = 2400,
                Ae = 2401,
                Le = 2402,
                Re = 3e3,
                Ce = 3001,
                Pe = 3007,
                Oe = 3002,
                e = 3003,
                n = 3004,
                Ie = 3005,
                De = 3006,
                Be = 3200,
                Ne = 3201,
                Ue = 0,
                ze = 1,
                Fe = 7680,
                He = 519,
                Ge = 35044,
                ke = 35048
              function Ve() {}
              Object.assign(Ve.prototype, {
                addEventListener: function (t, e) {
                  void 0 === this._listeners && (this._listeners = {})
                  var n = this._listeners
                  void 0 === n[t] && (n[t] = []),
                    -1 === n[t].indexOf(e) && n[t].push(e)
                },
                hasEventListener: function (t, e) {
                  if (void 0 === this._listeners) return !1
                  var n = this._listeners
                  return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                },
                removeEventListener: function (t, e) {
                  var n, r
                  void 0 !== this._listeners &&
                    (void 0 === (n = this._listeners[t]) ||
                      (-1 !== (r = n.indexOf(e)) && n.splice(r, 1)))
                },
                dispatchEvent: function (t) {
                  if (void 0 !== this._listeners) {
                    var e = this._listeners[t.type]
                    if (void 0 !== e) {
                      t.target = this
                      for (var n = e.slice(0), r = 0, i = n.length; r < i; r++)
                        n[r].call(this, t)
                    }
                  }
                },
              })
              for (var je = [], We = 0; We < 256; We++)
                je[We] = (We < 16 ? '0' : '') + We.toString(16)
              var qe,
                Xe = {
                  DEG2RAD: Math.PI / 180,
                  RAD2DEG: 180 / Math.PI,
                  generateUUID: function () {
                    var t = (4294967295 * Math.random()) | 0,
                      e = (4294967295 * Math.random()) | 0,
                      n = (4294967295 * Math.random()) | 0,
                      r = (4294967295 * Math.random()) | 0
                    return (
                      je[255 & t] +
                      je[(t >> 8) & 255] +
                      je[(t >> 16) & 255] +
                      je[(t >> 24) & 255] +
                      '-' +
                      je[255 & e] +
                      je[(e >> 8) & 255] +
                      '-' +
                      je[((e >> 16) & 15) | 64] +
                      je[(e >> 24) & 255] +
                      '-' +
                      je[(63 & n) | 128] +
                      je[(n >> 8) & 255] +
                      '-' +
                      je[(n >> 16) & 255] +
                      je[(n >> 24) & 255] +
                      je[255 & r] +
                      je[(r >> 8) & 255] +
                      je[(r >> 16) & 255] +
                      je[(r >> 24) & 255]
                    ).toUpperCase()
                  },
                  clamp: function (t, e, n) {
                    return Math.max(e, Math.min(n, t))
                  },
                  euclideanModulo: function (t, e) {
                    return ((t % e) + e) % e
                  },
                  mapLinear: function (t, e, n, r, i) {
                    return r + ((t - e) * (i - r)) / (n - e)
                  },
                  lerp: function (t, e, n) {
                    return (1 - n) * t + n * e
                  },
                  smoothstep: function (t, e, n) {
                    return t <= e
                      ? 0
                      : n <= t
                        ? 1
                        : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                  },
                  smootherstep: function (t, e, n) {
                    return t <= e
                      ? 0
                      : n <= t
                        ? 1
                        : (t = (t - e) / (n - e)) *
                          t *
                          t *
                          (t * (6 * t - 15) + 10)
                  },
                  randInt: function (t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                  },
                  randFloat: function (t, e) {
                    return t + Math.random() * (e - t)
                  },
                  randFloatSpread: function (t) {
                    return t * (0.5 - Math.random())
                  },
                  degToRad: function (t) {
                    return t * Xe.DEG2RAD
                  },
                  radToDeg: function (t) {
                    return t * Xe.RAD2DEG
                  },
                  isPowerOfTwo: function (t) {
                    return 0 == (t & (t - 1)) && 0 !== t
                  },
                  ceilPowerOfTwo: function (t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                  },
                  floorPowerOfTwo: function (t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                  },
                  setQuaternionFromProperEuler: function (t, e, n, r, i) {
                    var a = Math.cos,
                      o = Math.sin,
                      s = a(n / 2),
                      c = o(n / 2),
                      l = a((e + r) / 2),
                      h = o((e + r) / 2),
                      u = a((e - r) / 2),
                      p = o((e - r) / 2),
                      d = a((r - e) / 2),
                      f = o((r - e) / 2)
                    switch (i) {
                      case 'XYX':
                        t.set(s * h, c * u, c * p, s * l)
                        break
                      case 'YZY':
                        t.set(c * p, s * h, c * u, s * l)
                        break
                      case 'ZXZ':
                        t.set(c * u, c * p, s * h, s * l)
                        break
                      case 'XZX':
                        t.set(s * h, c * f, c * d, s * l)
                        break
                      case 'YXY':
                        t.set(c * d, s * h, c * f, s * l)
                        break
                      case 'ZYZ':
                        t.set(c * f, c * d, s * h, s * l)
                        break
                      default:
                        console.warn(
                          'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
                            i,
                        )
                    }
                  },
                }
              function Ye(t, e) {
                void 0 === t && (t = 0),
                  void 0 === e && (e = 0),
                  (this.x = t),
                  (this.y = e)
              }
              function Ze() {
                ;(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
                  0 < arguments.length &&
                    console.error(
                      'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.',
                    )
              }
              Object.defineProperties(Ye.prototype, {
                width: {
                  get: function () {
                    return this.x
                  },
                  set: function (t) {
                    this.x = t
                  },
                },
                height: {
                  get: function () {
                    return this.y
                  },
                  set: function (t) {
                    this.y = t
                  },
                },
              }),
                Object.assign(Ye.prototype, {
                  isVector2: !0,
                  set: function (t, e) {
                    return (this.x = t), (this.y = e), this
                  },
                  setScalar: function (t) {
                    return (this.x = t), (this.y = t), this
                  },
                  setX: function (t) {
                    return (this.x = t), this
                  },
                  setY: function (t) {
                    return (this.y = t), this
                  },
                  setComponent: function (t, e) {
                    switch (t) {
                      case 0:
                        this.x = e
                        break
                      case 1:
                        this.y = e
                        break
                      default:
                        throw new Error('index is out of range: ' + t)
                    }
                    return this
                  },
                  getComponent: function (t) {
                    switch (t) {
                      case 0:
                        return this.x
                      case 1:
                        return this.y
                      default:
                        throw new Error('index is out of range: ' + t)
                    }
                  },
                  clone: function () {
                    return new this.constructor(this.x, this.y)
                  },
                  copy: function (t) {
                    return (this.x = t.x), (this.y = t.y), this
                  },
                  add: function (t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                        ),
                        this.addVectors(t, e))
                      : ((this.x += t.x), (this.y += t.y), this)
                  },
                  addScalar: function (t) {
                    return (this.x += t), (this.y += t), this
                  },
                  addVectors: function (t, e) {
                    return (this.x = t.x + e.x), (this.y = t.y + e.y), this
                  },
                  addScaledVector: function (t, e) {
                    return (this.x += t.x * e), (this.y += t.y * e), this
                  },
                  sub: function (t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                        ),
                        this.subVectors(t, e))
                      : ((this.x -= t.x), (this.y -= t.y), this)
                  },
                  subScalar: function (t) {
                    return (this.x -= t), (this.y -= t), this
                  },
                  subVectors: function (t, e) {
                    return (this.x = t.x - e.x), (this.y = t.y - e.y), this
                  },
                  multiply: function (t) {
                    return (this.x *= t.x), (this.y *= t.y), this
                  },
                  multiplyScalar: function (t) {
                    return (this.x *= t), (this.y *= t), this
                  },
                  divide: function (t) {
                    return (this.x /= t.x), (this.y /= t.y), this
                  },
                  divideScalar: function (t) {
                    return this.multiplyScalar(1 / t)
                  },
                  applyMatrix3: function (t) {
                    var e = this.x,
                      n = this.y,
                      r = t.elements
                    return (
                      (this.x = r[0] * e + r[3] * n + r[6]),
                      (this.y = r[1] * e + r[4] * n + r[7]),
                      this
                    )
                  },
                  min: function (t) {
                    return (
                      (this.x = Math.min(this.x, t.x)),
                      (this.y = Math.min(this.y, t.y)),
                      this
                    )
                  },
                  max: function (t) {
                    return (
                      (this.x = Math.max(this.x, t.x)),
                      (this.y = Math.max(this.y, t.y)),
                      this
                    )
                  },
                  clamp: function (t, e) {
                    return (
                      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                      this
                    )
                  },
                  clampScalar: function (t, e) {
                    return (
                      (this.x = Math.max(t, Math.min(e, this.x))),
                      (this.y = Math.max(t, Math.min(e, this.y))),
                      this
                    )
                  },
                  clampLength: function (t, e) {
                    var n = this.length()
                    return this.divideScalar(n || 1).multiplyScalar(
                      Math.max(t, Math.min(e, n)),
                    )
                  },
                  floor: function () {
                    return (
                      (this.x = Math.floor(this.x)),
                      (this.y = Math.floor(this.y)),
                      this
                    )
                  },
                  ceil: function () {
                    return (
                      (this.x = Math.ceil(this.x)),
                      (this.y = Math.ceil(this.y)),
                      this
                    )
                  },
                  round: function () {
                    return (
                      (this.x = Math.round(this.x)),
                      (this.y = Math.round(this.y)),
                      this
                    )
                  },
                  roundToZero: function () {
                    return (
                      (this.x =
                        this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                      (this.y =
                        this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                      this
                    )
                  },
                  negate: function () {
                    return (this.x = -this.x), (this.y = -this.y), this
                  },
                  dot: function (t) {
                    return this.x * t.x + this.y * t.y
                  },
                  cross: function (t) {
                    return this.x * t.y - this.y * t.x
                  },
                  lengthSq: function () {
                    return this.x * this.x + this.y * this.y
                  },
                  length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                  },
                  manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y)
                  },
                  normalize: function () {
                    return this.divideScalar(this.length() || 1)
                  },
                  angle: function () {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                  },
                  distanceTo: function (t) {
                    return Math.sqrt(this.distanceToSquared(t))
                  },
                  distanceToSquared: function (t) {
                    var e = this.x - t.x,
                      n = this.y - t.y
                    return e * e + n * n
                  },
                  manhattanDistanceTo: function (t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                  },
                  setLength: function (t) {
                    return this.normalize().multiplyScalar(t)
                  },
                  lerp: function (t, e) {
                    return (
                      (this.x += (t.x - this.x) * e),
                      (this.y += (t.y - this.y) * e),
                      this
                    )
                  },
                  lerpVectors: function (t, e, n) {
                    return (
                      (this.x = t.x + (e.x - t.x) * n),
                      (this.y = t.y + (e.y - t.y) * n),
                      this
                    )
                  },
                  equals: function (t) {
                    return t.x === this.x && t.y === this.y
                  },
                  fromArray: function (t, e) {
                    return (
                      void 0 === e && (e = 0),
                      (this.x = t[e]),
                      (this.y = t[e + 1]),
                      this
                    )
                  },
                  toArray: function (t, e) {
                    return (
                      void 0 === t && (t = []),
                      void 0 === e && (e = 0),
                      (t[e] = this.x),
                      (t[e + 1] = this.y),
                      t
                    )
                  },
                  fromBufferAttribute: function (t, e, n) {
                    return (
                      void 0 !== n &&
                        console.warn(
                          'THREE.Vector2: offset has been removed from .fromBufferAttribute().',
                        ),
                      (this.x = t.getX(e)),
                      (this.y = t.getY(e)),
                      this
                    )
                  },
                  rotateAround: function (t, e) {
                    var n = Math.cos(e),
                      r = Math.sin(e),
                      i = this.x - t.x,
                      a = this.y - t.y
                    return (
                      (this.x = i * n - a * r + t.x),
                      (this.y = i * r + a * n + t.y),
                      this
                    )
                  },
                  random: function () {
                    return (
                      (this.x = Math.random()), (this.y = Math.random()), this
                    )
                  },
                }),
                Object.assign(Ze.prototype, {
                  isMatrix3: !0,
                  set: function (t, e, n, r, i, a, o, s, c) {
                    var l = this.elements
                    return (
                      (l[0] = t),
                      (l[1] = r),
                      (l[2] = o),
                      (l[3] = e),
                      (l[4] = i),
                      (l[5] = s),
                      (l[6] = n),
                      (l[7] = a),
                      (l[8] = c),
                      this
                    )
                  },
                  identity: function () {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                  },
                  clone: function () {
                    return new this.constructor().fromArray(this.elements)
                  },
                  copy: function (t) {
                    var e = this.elements,
                      n = t.elements
                    return (
                      (e[0] = n[0]),
                      (e[1] = n[1]),
                      (e[2] = n[2]),
                      (e[3] = n[3]),
                      (e[4] = n[4]),
                      (e[5] = n[5]),
                      (e[6] = n[6]),
                      (e[7] = n[7]),
                      (e[8] = n[8]),
                      this
                    )
                  },
                  extractBasis: function (t, e, n) {
                    return (
                      t.setFromMatrix3Column(this, 0),
                      e.setFromMatrix3Column(this, 1),
                      n.setFromMatrix3Column(this, 2),
                      this
                    )
                  },
                  setFromMatrix4: function (t) {
                    var e = t.elements
                    return (
                      this.set(
                        e[0],
                        e[4],
                        e[8],
                        e[1],
                        e[5],
                        e[9],
                        e[2],
                        e[6],
                        e[10],
                      ),
                      this
                    )
                  },
                  multiply: function (t) {
                    return this.multiplyMatrices(this, t)
                  },
                  premultiply: function (t) {
                    return this.multiplyMatrices(t, this)
                  },
                  multiplyMatrices: function (t, e) {
                    var n = t.elements,
                      r = e.elements,
                      i = this.elements,
                      a = n[0],
                      o = n[3],
                      s = n[6],
                      c = n[1],
                      l = n[4],
                      h = n[7],
                      u = n[2],
                      p = n[5],
                      d = n[8],
                      f = r[0],
                      m = r[3],
                      v = r[6],
                      g = r[1],
                      y = r[4],
                      x = r[7],
                      b = r[2],
                      _ = r[5],
                      w = r[8]
                    return (
                      (i[0] = a * f + o * g + s * b),
                      (i[3] = a * m + o * y + s * _),
                      (i[6] = a * v + o * x + s * w),
                      (i[1] = c * f + l * g + h * b),
                      (i[4] = c * m + l * y + h * _),
                      (i[7] = c * v + l * x + h * w),
                      (i[2] = u * f + p * g + d * b),
                      (i[5] = u * m + p * y + d * _),
                      (i[8] = u * v + p * x + d * w),
                      this
                    )
                  },
                  multiplyScalar: function (t) {
                    var e = this.elements
                    return (
                      (e[0] *= t),
                      (e[3] *= t),
                      (e[6] *= t),
                      (e[1] *= t),
                      (e[4] *= t),
                      (e[7] *= t),
                      (e[2] *= t),
                      (e[5] *= t),
                      (e[8] *= t),
                      this
                    )
                  },
                  determinant: function () {
                    var t = this.elements,
                      e = t[0],
                      n = t[1],
                      r = t[2],
                      i = t[3],
                      a = t[4],
                      o = t[5],
                      s = t[6],
                      c = t[7],
                      l = t[8]
                    return (
                      e * a * l -
                      e * o * c -
                      n * i * l +
                      n * o * s +
                      r * i * c -
                      r * a * s
                    )
                  },
                  getInverse: function (t, e) {
                    void 0 !== e &&
                      console.warn(
                        'THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.',
                      )
                    var n = t.elements,
                      r = this.elements,
                      i = n[0],
                      a = n[1],
                      o = n[2],
                      s = n[3],
                      c = n[4],
                      l = n[5],
                      h = n[6],
                      u = n[7],
                      p = n[8],
                      d = p * c - l * u,
                      f = l * h - p * s,
                      m = u * s - c * h,
                      v = i * d + a * f + o * m
                    if (0 == v) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
                    var g = 1 / v
                    return (
                      (r[0] = d * g),
                      (r[1] = (o * u - p * a) * g),
                      (r[2] = (l * a - o * c) * g),
                      (r[3] = f * g),
                      (r[4] = (p * i - o * h) * g),
                      (r[5] = (o * s - l * i) * g),
                      (r[6] = m * g),
                      (r[7] = (a * h - u * i) * g),
                      (r[8] = (c * i - a * s) * g),
                      this
                    )
                  },
                  transpose: function () {
                    var t = this.elements,
                      e = t[1]
                    return (
                      (t[1] = t[3]),
                      (t[3] = e),
                      (e = t[2]),
                      (t[2] = t[6]),
                      (t[6] = e),
                      (e = t[5]),
                      (t[5] = t[7]),
                      (t[7] = e),
                      this
                    )
                  },
                  getNormalMatrix: function (t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                  },
                  transposeIntoArray: function (t) {
                    var e = this.elements
                    return (
                      (t[0] = e[0]),
                      (t[1] = e[3]),
                      (t[2] = e[6]),
                      (t[3] = e[1]),
                      (t[4] = e[4]),
                      (t[5] = e[7]),
                      (t[6] = e[2]),
                      (t[7] = e[5]),
                      (t[8] = e[8]),
                      this
                    )
                  },
                  setUvTransform: function (t, e, n, r, i, a, o) {
                    var s = Math.cos(i),
                      c = Math.sin(i)
                    this.set(
                      n * s,
                      n * c,
                      -n * (s * a + c * o) + a + t,
                      -r * c,
                      r * s,
                      -r * (-c * a + s * o) + o + e,
                      0,
                      0,
                      1,
                    )
                  },
                  scale: function (t, e) {
                    var n = this.elements
                    return (
                      (n[0] *= t),
                      (n[3] *= t),
                      (n[6] *= t),
                      (n[1] *= e),
                      (n[4] *= e),
                      (n[7] *= e),
                      this
                    )
                  },
                  rotate: function (t) {
                    var e = Math.cos(t),
                      n = Math.sin(t),
                      r = this.elements,
                      i = r[0],
                      a = r[3],
                      o = r[6],
                      s = r[1],
                      c = r[4],
                      l = r[7]
                    return (
                      (r[0] = e * i + n * s),
                      (r[3] = e * a + n * c),
                      (r[6] = e * o + n * l),
                      (r[1] = -n * i + e * s),
                      (r[4] = -n * a + e * c),
                      (r[7] = -n * o + e * l),
                      this
                    )
                  },
                  translate: function (t, e) {
                    var n = this.elements
                    return (
                      (n[0] += t * n[2]),
                      (n[3] += t * n[5]),
                      (n[6] += t * n[8]),
                      (n[1] += e * n[2]),
                      (n[4] += e * n[5]),
                      (n[7] += e * n[8]),
                      this
                    )
                  },
                  equals: function (t) {
                    for (
                      var e = this.elements, n = t.elements, r = 0;
                      r < 9;
                      r++
                    )
                      if (e[r] !== n[r]) return !1
                    return !0
                  },
                  fromArray: function (t, e) {
                    void 0 === e && (e = 0)
                    for (var n = 0; n < 9; n++) this.elements[n] = t[n + e]
                    return this
                  },
                  toArray: function (t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0)
                    var n = this.elements
                    return (
                      (t[e] = n[0]),
                      (t[e + 1] = n[1]),
                      (t[e + 2] = n[2]),
                      (t[e + 3] = n[3]),
                      (t[e + 4] = n[4]),
                      (t[e + 5] = n[5]),
                      (t[e + 6] = n[6]),
                      (t[e + 7] = n[7]),
                      (t[e + 8] = n[8]),
                      t
                    )
                  },
                })
              var Je = {
                  getDataURL: function (t) {
                    if (/^data:/i.test(t.src)) return t.src
                    if ('undefined' == typeof HTMLCanvasElement) return t.src
                    var e,
                      n =
                        t instanceof HTMLCanvasElement
                          ? t
                          : (void 0 === qe &&
                              (qe = document.createElementNS(
                                'http://www.w3.org/1999/xhtml',
                                'canvas',
                              )),
                            (qe.width = t.width),
                            (qe.height = t.height),
                            (e = qe.getContext('2d')),
                            t instanceof ImageData
                              ? e.putImageData(t, 0, 0)
                              : e.drawImage(t, 0, 0, t.width, t.height),
                            qe)
                    return 2048 < n.width || 2048 < n.height
                      ? n.toDataURL('image/jpeg', 0.6)
                      : n.toDataURL('image/png')
                  },
                },
                Qe = 0
              function Ke(t, e, n, r, i, a, o, s, c, l) {
                Object.defineProperty(this, 'id', { value: Qe++ }),
                  (this.uuid = Xe.generateUUID()),
                  (this.name = ''),
                  (this.image = void 0 !== t ? t : Ke.DEFAULT_IMAGE),
                  (this.mipmaps = []),
                  (this.mapping = void 0 !== e ? e : Ke.DEFAULT_MAPPING),
                  (this.wrapS = void 0 !== n ? n : zt),
                  (this.wrapT = void 0 !== r ? r : zt),
                  (this.magFilter = void 0 !== i ? i : Vt),
                  (this.minFilter = void 0 !== a ? a : Wt),
                  (this.anisotropy = void 0 !== c ? c : 1),
                  (this.format = void 0 !== o ? o : $t),
                  (this.internalFormat = null),
                  (this.type = void 0 !== s ? s : qt),
                  (this.offset = new Ye(0, 0)),
                  (this.repeat = new Ye(1, 1)),
                  (this.center = new Ye(0, 0)),
                  (this.rotation = 0),
                  (this.matrixAutoUpdate = !0),
                  (this.matrix = new Ze()),
                  (this.generateMipmaps = !0),
                  (this.premultiplyAlpha = !1),
                  (this.flipY = !0),
                  (this.unpackAlignment = 4),
                  (this.encoding = void 0 !== l ? l : Re),
                  (this.version = 0),
                  (this.onUpdate = null)
              }
              function $e(t, e, n, r) {
                void 0 === t && (t = 0),
                  void 0 === e && (e = 0),
                  void 0 === n && (n = 0),
                  void 0 === r && (r = 1),
                  (this.x = t),
                  (this.y = e),
                  (this.z = n),
                  (this.w = r)
              }
              function tn(t, e, n) {
                ;(this.width = t),
                  (this.height = e),
                  (this.scissor = new $e(0, 0, t, e)),
                  (this.scissorTest = !1),
                  (this.viewport = new $e(0, 0, t, e)),
                  (n = n || {}),
                  (this.texture = new Ke(
                    void 0,
                    n.mapping,
                    n.wrapS,
                    n.wrapT,
                    n.magFilter,
                    n.minFilter,
                    n.format,
                    n.type,
                    n.anisotropy,
                    n.encoding,
                  )),
                  (this.texture.image = {}),
                  (this.texture.image.width = t),
                  (this.texture.image.height = e),
                  (this.texture.generateMipmaps =
                    void 0 !== n.generateMipmaps && n.generateMipmaps),
                  (this.texture.minFilter =
                    void 0 !== n.minFilter ? n.minFilter : Vt),
                  (this.depthBuffer =
                    void 0 === n.depthBuffer || n.depthBuffer),
                  (this.stencilBuffer =
                    void 0 === n.stencilBuffer || n.stencilBuffer),
                  (this.depthTexture =
                    void 0 !== n.depthTexture ? n.depthTexture : null)
              }
              function en(t, e, n) {
                tn.call(this, t, e, n), (this.samples = 4)
              }
              function nn(t, e, n, r) {
                void 0 === t && (t = 0),
                  void 0 === e && (e = 0),
                  void 0 === n && (n = 0),
                  void 0 === r && (r = 1),
                  (this._x = t),
                  (this._y = e),
                  (this._z = n),
                  (this._w = r)
              }
              ;(Ke.DEFAULT_IMAGE = void 0),
                (Ke.DEFAULT_MAPPING = 300),
                (Ke.prototype = Object.assign(Object.create(Ve.prototype), {
                  constructor: Ke,
                  isTexture: !0,
                  updateMatrix: function () {
                    this.matrix.setUvTransform(
                      this.offset.x,
                      this.offset.y,
                      this.repeat.x,
                      this.repeat.y,
                      this.rotation,
                      this.center.x,
                      this.center.y,
                    )
                  },
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                  copy: function (t) {
                    return (
                      (this.name = t.name),
                      (this.image = t.image),
                      (this.mipmaps = t.mipmaps.slice(0)),
                      (this.mapping = t.mapping),
                      (this.wrapS = t.wrapS),
                      (this.wrapT = t.wrapT),
                      (this.magFilter = t.magFilter),
                      (this.minFilter = t.minFilter),
                      (this.anisotropy = t.anisotropy),
                      (this.format = t.format),
                      (this.internalFormat = t.internalFormat),
                      (this.type = t.type),
                      this.offset.copy(t.offset),
                      this.repeat.copy(t.repeat),
                      this.center.copy(t.center),
                      (this.rotation = t.rotation),
                      (this.matrixAutoUpdate = t.matrixAutoUpdate),
                      this.matrix.copy(t.matrix),
                      (this.generateMipmaps = t.generateMipmaps),
                      (this.premultiplyAlpha = t.premultiplyAlpha),
                      (this.flipY = t.flipY),
                      (this.unpackAlignment = t.unpackAlignment),
                      (this.encoding = t.encoding),
                      this
                    )
                  },
                  toJSON: function (t) {
                    var e = void 0 === t || 'string' == typeof t
                    if (!e && void 0 !== t.textures[this.uuid])
                      return t.textures[this.uuid]
                    var n = {
                      metadata: {
                        version: 4.5,
                        type: 'Texture',
                        generator: 'Texture.toJSON',
                      },
                      uuid: this.uuid,
                      name: this.name,
                      mapping: this.mapping,
                      repeat: [this.repeat.x, this.repeat.y],
                      offset: [this.offset.x, this.offset.y],
                      center: [this.center.x, this.center.y],
                      rotation: this.rotation,
                      wrap: [this.wrapS, this.wrapT],
                      format: this.format,
                      type: this.type,
                      encoding: this.encoding,
                      minFilter: this.minFilter,
                      magFilter: this.magFilter,
                      anisotropy: this.anisotropy,
                      flipY: this.flipY,
                      premultiplyAlpha: this.premultiplyAlpha,
                      unpackAlignment: this.unpackAlignment,
                    }
                    if (void 0 !== this.image) {
                      var r,
                        i = this.image
                      if (
                        (void 0 === i.uuid && (i.uuid = Xe.generateUUID()),
                        !e && void 0 === t.images[i.uuid])
                      ) {
                        if (Array.isArray(i)) {
                          r = []
                          for (var a = 0, o = i.length; a < o; a++)
                            r.push(Je.getDataURL(i[a]))
                        } else r = Je.getDataURL(i)
                        t.images[i.uuid] = { uuid: i.uuid, url: r }
                      }
                      n.image = i.uuid
                    }
                    return e || (t.textures[this.uuid] = n), n
                  },
                  dispose: function () {
                    this.dispatchEvent({ type: 'dispose' })
                  },
                  transformUv: function (t) {
                    if (300 !== this.mapping) return t
                    if ((t.applyMatrix3(this.matrix), t.x < 0 || 1 < t.x))
                      switch (this.wrapS) {
                        case Ut:
                          t.x = t.x - Math.floor(t.x)
                          break
                        case zt:
                          t.x = t.x < 0 ? 0 : 1
                          break
                        case Ft:
                          1 === Math.abs(Math.floor(t.x) % 2)
                            ? (t.x = Math.ceil(t.x) - t.x)
                            : (t.x = t.x - Math.floor(t.x))
                      }
                    if (t.y < 0 || 1 < t.y)
                      switch (this.wrapT) {
                        case Ut:
                          t.y = t.y - Math.floor(t.y)
                          break
                        case zt:
                          t.y = t.y < 0 ? 0 : 1
                          break
                        case Ft:
                          1 === Math.abs(Math.floor(t.y) % 2)
                            ? (t.y = Math.ceil(t.y) - t.y)
                            : (t.y = t.y - Math.floor(t.y))
                      }
                    return this.flipY && (t.y = 1 - t.y), t
                  },
                })),
                Object.defineProperty(Ke.prototype, 'needsUpdate', {
                  set: function (t) {
                    !0 === t && this.version++
                  },
                }),
                Object.defineProperties($e.prototype, {
                  width: {
                    get: function () {
                      return this.z
                    },
                    set: function (t) {
                      this.z = t
                    },
                  },
                  height: {
                    get: function () {
                      return this.w
                    },
                    set: function (t) {
                      this.w = t
                    },
                  },
                }),
                Object.assign($e.prototype, {
                  isVector4: !0,
                  set: function (t, e, n, r) {
                    return (
                      (this.x = t),
                      (this.y = e),
                      (this.z = n),
                      (this.w = r),
                      this
                    )
                  },
                  setScalar: function (t) {
                    return (
                      (this.x = t),
                      (this.y = t),
                      (this.z = t),
                      (this.w = t),
                      this
                    )
                  },
                  setX: function (t) {
                    return (this.x = t), this
                  },
                  setY: function (t) {
                    return (this.y = t), this
                  },
                  setZ: function (t) {
                    return (this.z = t), this
                  },
                  setW: function (t) {
                    return (this.w = t), this
                  },
                  setComponent: function (t, e) {
                    switch (t) {
                      case 0:
                        this.x = e
                        break
                      case 1:
                        this.y = e
                        break
                      case 2:
                        this.z = e
                        break
                      case 3:
                        this.w = e
                        break
                      default:
                        throw new Error('index is out of range: ' + t)
                    }
                    return this
                  },
                  getComponent: function (t) {
                    switch (t) {
                      case 0:
                        return this.x
                      case 1:
                        return this.y
                      case 2:
                        return this.z
                      case 3:
                        return this.w
                      default:
                        throw new Error('index is out of range: ' + t)
                    }
                  },
                  clone: function () {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                  },
                  copy: function (t) {
                    return (
                      (this.x = t.x),
                      (this.y = t.y),
                      (this.z = t.z),
                      (this.w = void 0 !== t.w ? t.w : 1),
                      this
                    )
                  },
                  add: function (t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                        ),
                        this.addVectors(t, e))
                      : ((this.x += t.x),
                        (this.y += t.y),
                        (this.z += t.z),
                        (this.w += t.w),
                        this)
                  },
                  addScalar: function (t) {
                    return (
                      (this.x += t),
                      (this.y += t),
                      (this.z += t),
                      (this.w += t),
                      this
                    )
                  },
                  addVectors: function (t, e) {
                    return (
                      (this.x = t.x + e.x),
                      (this.y = t.y + e.y),
                      (this.z = t.z + e.z),
                      (this.w = t.w + e.w),
                      this
                    )
                  },
                  addScaledVector: function (t, e) {
                    return (
                      (this.x += t.x * e),
                      (this.y += t.y * e),
                      (this.z += t.z * e),
                      (this.w += t.w * e),
                      this
                    )
                  },
                  sub: function (t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                        ),
                        this.subVectors(t, e))
                      : ((this.x -= t.x),
                        (this.y -= t.y),
                        (this.z -= t.z),
                        (this.w -= t.w),
                        this)
                  },
                  subScalar: function (t) {
                    return (
                      (this.x -= t),
                      (this.y -= t),
                      (this.z -= t),
                      (this.w -= t),
                      this
                    )
                  },
                  subVectors: function (t, e) {
                    return (
                      (this.x = t.x - e.x),
                      (this.y = t.y - e.y),
                      (this.z = t.z - e.z),
                      (this.w = t.w - e.w),
                      this
                    )
                  },
                  multiplyScalar: function (t) {
                    return (
                      (this.x *= t),
                      (this.y *= t),
                      (this.z *= t),
                      (this.w *= t),
                      this
                    )
                  },
                  applyMatrix4: function (t) {
                    var e = this.x,
                      n = this.y,
                      r = this.z,
                      i = this.w,
                      a = t.elements
                    return (
                      (this.x = a[0] * e + a[4] * n + a[8] * r + a[12] * i),
                      (this.y = a[1] * e + a[5] * n + a[9] * r + a[13] * i),
                      (this.z = a[2] * e + a[6] * n + a[10] * r + a[14] * i),
                      (this.w = a[3] * e + a[7] * n + a[11] * r + a[15] * i),
                      this
                    )
                  },
                  divideScalar: function (t) {
                    return this.multiplyScalar(1 / t)
                  },
                  setAxisAngleFromQuaternion: function (t) {
                    this.w = 2 * Math.acos(t.w)
                    var e = Math.sqrt(1 - t.w * t.w)
                    return (
                      e < 1e-4
                        ? ((this.x = 1), (this.y = 0), (this.z = 0))
                        : ((this.x = t.x / e),
                          (this.y = t.y / e),
                          (this.z = t.z / e)),
                      this
                    )
                  },
                  setAxisAngleFromRotationMatrix: function (t) {
                    var e,
                      n,
                      r,
                      i,
                      a = t.elements,
                      o = a[0],
                      s = a[4],
                      c = a[8],
                      l = a[1],
                      h = a[5],
                      u = a[9],
                      p = a[2],
                      d = a[6],
                      f = a[10]
                    if (
                      Math.abs(s - l) < 0.01 &&
                      Math.abs(c - p) < 0.01 &&
                      Math.abs(u - d) < 0.01
                    ) {
                      if (
                        Math.abs(s + l) < 0.1 &&
                        Math.abs(c + p) < 0.1 &&
                        Math.abs(u + d) < 0.1 &&
                        Math.abs(o + h + f - 3) < 0.1
                      )
                        return this.set(1, 0, 0, 0), this
                      e = Math.PI
                      var m = (o + 1) / 2,
                        v = (h + 1) / 2,
                        g = (f + 1) / 2,
                        y = (s + l) / 4,
                        x = (c + p) / 4,
                        b = (u + d) / 4
                      return (
                        v < m && g < m
                          ? (i =
                              m < 0.01
                                ? ((n = 0), (r = 0.707106781))
                                : ((r = y / (n = Math.sqrt(m))), x / n))
                          : g < v
                            ? (i =
                                v < 0.01
                                  ? ((r = 0), (n = 0.707106781))
                                  : ((n = y / (r = Math.sqrt(v))), b / r))
                            : g < 0.01
                              ? ((r = n = 0.707106781), (i = 0))
                              : ((n = x / (i = Math.sqrt(g))), (r = b / i)),
                        this.set(n, r, i, e),
                        this
                      )
                    }
                    var _ = Math.sqrt(
                      (d - u) * (d - u) + (c - p) * (c - p) + (l - s) * (l - s),
                    )
                    return (
                      Math.abs(_) < 0.001 && (_ = 1),
                      (this.x = (d - u) / _),
                      (this.y = (c - p) / _),
                      (this.z = (l - s) / _),
                      (this.w = Math.acos((o + h + f - 1) / 2)),
                      this
                    )
                  },
                  min: function (t) {
                    return (
                      (this.x = Math.min(this.x, t.x)),
                      (this.y = Math.min(this.y, t.y)),
                      (this.z = Math.min(this.z, t.z)),
                      (this.w = Math.min(this.w, t.w)),
                      this
                    )
                  },
                  max: function (t) {
                    return (
                      (this.x = Math.max(this.x, t.x)),
                      (this.y = Math.max(this.y, t.y)),
                      (this.z = Math.max(this.z, t.z)),
                      (this.w = Math.max(this.w, t.w)),
                      this
                    )
                  },
                  clamp: function (t, e) {
                    return (
                      (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                      (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                      (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                      (this.w = Math.max(t.w, Math.min(e.w, this.w))),
                      this
                    )
                  },
                  clampScalar: function (t, e) {
                    return (
                      (this.x = Math.max(t, Math.min(e, this.x))),
                      (this.y = Math.max(t, Math.min(e, this.y))),
                      (this.z = Math.max(t, Math.min(e, this.z))),
                      (this.w = Math.max(t, Math.min(e, this.w))),
                      this
                    )
                  },
                  clampLength: function (t, e) {
                    var n = this.length()
                    return this.divideScalar(n || 1).multiplyScalar(
                      Math.max(t, Math.min(e, n)),
                    )
                  },
                  floor: function () {
                    return (
                      (this.x = Math.floor(this.x)),
                      (this.y = Math.floor(this.y)),
                      (this.z = Math.floor(this.z)),
                      (this.w = Math.floor(this.w)),
                      this
                    )
                  },
                  ceil: function () {
                    return (
                      (this.x = Math.ceil(this.x)),
                      (this.y = Math.ceil(this.y)),
                      (this.z = Math.ceil(this.z)),
                      (this.w = Math.ceil(this.w)),
                      this
                    )
                  },
                  round: function () {
                    return (
                      (this.x = Math.round(this.x)),
                      (this.y = Math.round(this.y)),
                      (this.z = Math.round(this.z)),
                      (this.w = Math.round(this.w)),
                      this
                    )
                  },
                  roundToZero: function () {
                    return (
                      (this.x =
                        this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                      (this.y =
                        this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                      (this.z =
                        this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                      (this.w =
                        this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
                      this
                    )
                  },
                  negate: function () {
                    return (
                      (this.x = -this.x),
                      (this.y = -this.y),
                      (this.z = -this.z),
                      (this.w = -this.w),
                      this
                    )
                  },
                  dot: function (t) {
                    return (
                      this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                    )
                  },
                  lengthSq: function () {
                    return (
                      this.x * this.x +
                      this.y * this.y +
                      this.z * this.z +
                      this.w * this.w
                    )
                  },
                  length: function () {
                    return Math.sqrt(
                      this.x * this.x +
                        this.y * this.y +
                        this.z * this.z +
                        this.w * this.w,
                    )
                  },
                  manhattanLength: function () {
                    return (
                      Math.abs(this.x) +
                      Math.abs(this.y) +
                      Math.abs(this.z) +
                      Math.abs(this.w)
                    )
                  },
                  normalize: function () {
                    return this.divideScalar(this.length() || 1)
                  },
                  setLength: function (t) {
                    return this.normalize().multiplyScalar(t)
                  },
                  lerp: function (t, e) {
                    return (
                      (this.x += (t.x - this.x) * e),
                      (this.y += (t.y - this.y) * e),
                      (this.z += (t.z - this.z) * e),
                      (this.w += (t.w - this.w) * e),
                      this
                    )
                  },
                  lerpVectors: function (t, e, n) {
                    return (
                      (this.x = t.x + (e.x - t.x) * n),
                      (this.y = t.y + (e.y - t.y) * n),
                      (this.z = t.z + (e.z - t.z) * n),
                      (this.w = t.w + (e.w - t.w) * n),
                      this
                    )
                  },
                  equals: function (t) {
                    return (
                      t.x === this.x &&
                      t.y === this.y &&
                      t.z === this.z &&
                      t.w === this.w
                    )
                  },
                  fromArray: function (t, e) {
                    return (
                      void 0 === e && (e = 0),
                      (this.x = t[e]),
                      (this.y = t[e + 1]),
                      (this.z = t[e + 2]),
                      (this.w = t[e + 3]),
                      this
                    )
                  },
                  toArray: function (t, e) {
                    return (
                      void 0 === t && (t = []),
                      void 0 === e && (e = 0),
                      (t[e] = this.x),
                      (t[e + 1] = this.y),
                      (t[e + 2] = this.z),
                      (t[e + 3] = this.w),
                      t
                    )
                  },
                  fromBufferAttribute: function (t, e, n) {
                    return (
                      void 0 !== n &&
                        console.warn(
                          'THREE.Vector4: offset has been removed from .fromBufferAttribute().',
                        ),
                      (this.x = t.getX(e)),
                      (this.y = t.getY(e)),
                      (this.z = t.getZ(e)),
                      (this.w = t.getW(e)),
                      this
                    )
                  },
                  random: function () {
                    return (
                      (this.x = Math.random()),
                      (this.y = Math.random()),
                      (this.z = Math.random()),
                      (this.w = Math.random()),
                      this
                    )
                  },
                }),
                (tn.prototype = Object.assign(Object.create(Ve.prototype), {
                  constructor: tn,
                  isWebGLRenderTarget: !0,
                  setSize: function (t, e) {
                    ;(this.width === t && this.height === e) ||
                      ((this.width = t),
                      (this.height = e),
                      (this.texture.image.width = t),
                      (this.texture.image.height = e),
                      this.dispose()),
                      this.viewport.set(0, 0, t, e),
                      this.scissor.set(0, 0, t, e)
                  },
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                  copy: function (t) {
                    return (
                      (this.width = t.width),
                      (this.height = t.height),
                      this.viewport.copy(t.viewport),
                      (this.texture = t.texture.clone()),
                      (this.depthBuffer = t.depthBuffer),
                      (this.stencilBuffer = t.stencilBuffer),
                      (this.depthTexture = t.depthTexture),
                      this
                    )
                  },
                  dispose: function () {
                    this.dispatchEvent({ type: 'dispose' })
                  },
                })),
                (en.prototype = Object.assign(Object.create(tn.prototype), {
                  constructor: en,
                  isWebGLMultisampleRenderTarget: !0,
                  copy: function (t) {
                    return (
                      tn.prototype.copy.call(this, t),
                      (this.samples = t.samples),
                      this
                    )
                  },
                })),
                Object.assign(nn, {
                  slerp: function (t, e, n, r) {
                    return n.copy(t).slerp(e, r)
                  },
                  slerpFlat: function (t, e, n, r, i, a, o) {
                    var s,
                      c,
                      l,
                      h,
                      u,
                      p,
                      d,
                      f,
                      m = n[r + 0],
                      v = n[r + 1],
                      g = n[r + 2],
                      y = n[r + 3],
                      x = i[a + 0],
                      b = i[a + 1],
                      _ = i[a + 2],
                      w = i[a + 3]
                    ;(y === w && m === x && v === b && g === _) ||
                      ((p = 1 - o),
                      (c = 0 <= (s = m * x + v * b + g * _ + y * w) ? 1 : -1),
                      (l = 1 - s * s) > Number.EPSILON &&
                        ((h = Math.sqrt(l)),
                        (u = Math.atan2(h, s * c)),
                        (p = Math.sin(p * u) / h),
                        (o = Math.sin(o * u) / h)),
                      (m = m * p + x * (d = o * c)),
                      (v = v * p + b * d),
                      (g = g * p + _ * d),
                      (y = y * p + w * d),
                      p === 1 - o &&
                        ((m *= f =
                          1 / Math.sqrt(m * m + v * v + g * g + y * y)),
                        (v *= f),
                        (g *= f),
                        (y *= f))),
                      (t[e] = m),
                      (t[e + 1] = v),
                      (t[e + 2] = g),
                      (t[e + 3] = y)
                  },
                  multiplyQuaternionsFlat: function (t, e, n, r, i, a) {
                    var o = n[r],
                      s = n[r + 1],
                      c = n[r + 2],
                      l = n[r + 3],
                      h = i[a],
                      u = i[a + 1],
                      p = i[a + 2],
                      d = i[a + 3]
                    return (
                      (t[e] = o * d + l * h + s * p - c * u),
                      (t[e + 1] = s * d + l * u + c * h - o * p),
                      (t[e + 2] = c * d + l * p + o * u - s * h),
                      (t[e + 3] = l * d - o * h - s * u - c * p),
                      t
                    )
                  },
                }),
                Object.defineProperties(nn.prototype, {
                  x: {
                    get: function () {
                      return this._x
                    },
                    set: function (t) {
                      ;(this._x = t), this._onChangeCallback()
                    },
                  },
                  y: {
                    get: function () {
                      return this._y
                    },
                    set: function (t) {
                      ;(this._y = t), this._onChangeCallback()
                    },
                  },
                  z: {
                    get: function () {
                      return this._z
                    },
                    set: function (t) {
                      ;(this._z = t), this._onChangeCallback()
                    },
                  },
                  w: {
                    get: function () {
                      return this._w
                    },
                    set: function (t) {
                      ;(this._w = t), this._onChangeCallback()
                    },
                  },
                }),
                Object.assign(nn.prototype, {
                  isQuaternion: !0,
                  set: function (t, e, n, r) {
                    return (
                      (this._x = t),
                      (this._y = e),
                      (this._z = n),
                      (this._w = r),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  clone: function () {
                    return new this.constructor(
                      this._x,
                      this._y,
                      this._z,
                      this._w,
                    )
                  },
                  copy: function (t) {
                    return (
                      (this._x = t.x),
                      (this._y = t.y),
                      (this._z = t.z),
                      (this._w = t.w),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  setFromEuler: function (t, e) {
                    if (!t || !t.isEuler)
                      throw new Error(
                        'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.',
                      )
                    var n = t._x,
                      r = t._y,
                      i = t._z,
                      a = t.order,
                      o = Math.cos,
                      s = Math.sin,
                      c = o(n / 2),
                      l = o(r / 2),
                      h = o(i / 2),
                      u = s(n / 2),
                      p = s(r / 2),
                      d = s(i / 2)
                    switch (a) {
                      case 'XYZ':
                        ;(this._x = u * l * h + c * p * d),
                          (this._y = c * p * h - u * l * d),
                          (this._z = c * l * d + u * p * h),
                          (this._w = c * l * h - u * p * d)
                        break
                      case 'YXZ':
                        ;(this._x = u * l * h + c * p * d),
                          (this._y = c * p * h - u * l * d),
                          (this._z = c * l * d - u * p * h),
                          (this._w = c * l * h + u * p * d)
                        break
                      case 'ZXY':
                        ;(this._x = u * l * h - c * p * d),
                          (this._y = c * p * h + u * l * d),
                          (this._z = c * l * d + u * p * h),
                          (this._w = c * l * h - u * p * d)
                        break
                      case 'ZYX':
                        ;(this._x = u * l * h - c * p * d),
                          (this._y = c * p * h + u * l * d),
                          (this._z = c * l * d - u * p * h),
                          (this._w = c * l * h + u * p * d)
                        break
                      case 'YZX':
                        ;(this._x = u * l * h + c * p * d),
                          (this._y = c * p * h + u * l * d),
                          (this._z = c * l * d - u * p * h),
                          (this._w = c * l * h - u * p * d)
                        break
                      case 'XZY':
                        ;(this._x = u * l * h - c * p * d),
                          (this._y = c * p * h - u * l * d),
                          (this._z = c * l * d + u * p * h),
                          (this._w = c * l * h + u * p * d)
                        break
                      default:
                        console.warn(
                          'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
                            a,
                        )
                    }
                    return !1 !== e && this._onChangeCallback(), this
                  },
                  setFromAxisAngle: function (t, e) {
                    var n = e / 2,
                      r = Math.sin(n)
                    return (
                      (this._x = t.x * r),
                      (this._y = t.y * r),
                      (this._z = t.z * r),
                      (this._w = Math.cos(n)),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  setFromRotationMatrix: function (t) {
                    var e,
                      n,
                      r,
                      i,
                      a = t.elements,
                      o = a[0],
                      s = a[4],
                      c = a[8],
                      l = a[1],
                      h = a[5],
                      u = a[9],
                      p = a[2],
                      d = a[6],
                      f = a[10],
                      m = o + h + f
                    return (
                      0 < m
                        ? ((e = 0.5 / Math.sqrt(m + 1)),
                          (this._w = 0.25 / e),
                          (this._x = (d - u) * e),
                          (this._y = (c - p) * e),
                          (this._z = (l - s) * e))
                        : h < o && f < o
                          ? ((n = 2 * Math.sqrt(1 + o - h - f)),
                            (this._w = (d - u) / n),
                            (this._x = 0.25 * n),
                            (this._y = (s + l) / n),
                            (this._z = (c + p) / n))
                          : f < h
                            ? ((r = 2 * Math.sqrt(1 + h - o - f)),
                              (this._w = (c - p) / r),
                              (this._x = (s + l) / r),
                              (this._y = 0.25 * r),
                              (this._z = (u + d) / r))
                            : ((i = 2 * Math.sqrt(1 + f - o - h)),
                              (this._w = (l - s) / i),
                              (this._x = (c + p) / i),
                              (this._y = (u + d) / i),
                              (this._z = 0.25 * i)),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  setFromUnitVectors: function (t, e) {
                    var n = t.dot(e) + 1
                    return (
                      n < 1e-6
                        ? ((n = 0),
                          Math.abs(t.x) > Math.abs(t.z)
                            ? ((this._x = -t.y), (this._y = t.x), (this._z = 0))
                            : ((this._x = 0),
                              (this._y = -t.z),
                              (this._z = t.y)))
                        : ((this._x = t.y * e.z - t.z * e.y),
                          (this._y = t.z * e.x - t.x * e.z),
                          (this._z = t.x * e.y - t.y * e.x)),
                      (this._w = n),
                      this.normalize()
                    )
                  },
                  angleTo: function (t) {
                    return 2 * Math.acos(Math.abs(Xe.clamp(this.dot(t), -1, 1)))
                  },
                  rotateTowards: function (t, e) {
                    var n = this.angleTo(t)
                    if (0 === n) return this
                    var r = Math.min(1, e / n)
                    return this.slerp(t, r), this
                  },
                  inverse: function () {
                    return this.conjugate()
                  },
                  conjugate: function () {
                    return (
                      (this._x *= -1),
                      (this._y *= -1),
                      (this._z *= -1),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  dot: function (t) {
                    return (
                      this._x * t._x +
                      this._y * t._y +
                      this._z * t._z +
                      this._w * t._w
                    )
                  },
                  lengthSq: function () {
                    return (
                      this._x * this._x +
                      this._y * this._y +
                      this._z * this._z +
                      this._w * this._w
                    )
                  },
                  length: function () {
                    return Math.sqrt(
                      this._x * this._x +
                        this._y * this._y +
                        this._z * this._z +
                        this._w * this._w,
                    )
                  },
                  normalize: function () {
                    var t = this.length()
                    return (
                      0 === t
                        ? ((this._x = 0),
                          (this._y = 0),
                          (this._z = 0),
                          (this._w = 1))
                        : ((t = 1 / t),
                          (this._x = this._x * t),
                          (this._y = this._y * t),
                          (this._z = this._z * t),
                          (this._w = this._w * t)),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  multiply: function (t, e) {
                    return void 0 !== e
                      ? (console.warn(
                          'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.',
                        ),
                        this.multiplyQuaternions(t, e))
                      : this.multiplyQuaternions(this, t)
                  },
                  premultiply: function (t) {
                    return this.multiplyQuaternions(t, this)
                  },
                  multiplyQuaternions: function (t, e) {
                    var n = t._x,
                      r = t._y,
                      i = t._z,
                      a = t._w,
                      o = e._x,
                      s = e._y,
                      c = e._z,
                      l = e._w
                    return (
                      (this._x = n * l + a * o + r * c - i * s),
                      (this._y = r * l + a * s + i * o - n * c),
                      (this._z = i * l + a * c + n * s - r * o),
                      (this._w = a * l - n * o - r * s - i * c),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  slerp: function (t, e) {
                    if (0 === e) return this
                    if (1 === e) return this.copy(t)
                    var n = this._x,
                      r = this._y,
                      i = this._z,
                      a = this._w,
                      o = a * t._w + n * t._x + r * t._y + i * t._z
                    if (
                      (o < 0
                        ? ((this._w = -t._w),
                          (this._x = -t._x),
                          (this._y = -t._y),
                          (this._z = -t._z),
                          (o = -o))
                        : this.copy(t),
                      1 <= o)
                    )
                      return (
                        (this._w = a),
                        (this._x = n),
                        (this._y = r),
                        (this._z = i),
                        this
                      )
                    var s = 1 - o * o
                    if (s <= Number.EPSILON) {
                      var c = 1 - e
                      return (
                        (this._w = c * a + e * this._w),
                        (this._x = c * n + e * this._x),
                        (this._y = c * r + e * this._y),
                        (this._z = c * i + e * this._z),
                        this.normalize(),
                        this._onChangeCallback(),
                        this
                      )
                    }
                    var l = Math.sqrt(s),
                      h = Math.atan2(l, o),
                      u = Math.sin((1 - e) * h) / l,
                      p = Math.sin(e * h) / l
                    return (
                      (this._w = a * u + this._w * p),
                      (this._x = n * u + this._x * p),
                      (this._y = r * u + this._y * p),
                      (this._z = i * u + this._z * p),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  equals: function (t) {
                    return (
                      t._x === this._x &&
                      t._y === this._y &&
                      t._z === this._z &&
                      t._w === this._w
                    )
                  },
                  fromArray: function (t, e) {
                    return (
                      void 0 === e && (e = 0),
                      (this._x = t[e]),
                      (this._y = t[e + 1]),
                      (this._z = t[e + 2]),
                      (this._w = t[e + 3]),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  toArray: function (t, e) {
                    return (
                      void 0 === t && (t = []),
                      void 0 === e && (e = 0),
                      (t[e] = this._x),
                      (t[e + 1] = this._y),
                      (t[e + 2] = this._z),
                      (t[e + 3] = this._w),
                      t
                    )
                  },
                  fromBufferAttribute: function (t, e) {
                    return (
                      (this._x = t.getX(e)),
                      (this._y = t.getY(e)),
                      (this._z = t.getZ(e)),
                      (this._w = t.getW(e)),
                      this
                    )
                  },
                  _onChange: function (t) {
                    return (this._onChangeCallback = t), this
                  },
                  _onChangeCallback: function () {},
                })
              var rn = new on(),
                an = new nn()
              function on(t, e, n) {
                void 0 === t && (t = 0),
                  void 0 === e && (e = 0),
                  void 0 === n && (n = 0),
                  (this.x = t),
                  (this.y = e),
                  (this.z = n)
              }
              Object.assign(on.prototype, {
                isVector3: !0,
                set: function (t, e, n) {
                  return (this.x = t), (this.y = e), (this.z = n), this
                },
                setScalar: function (t) {
                  return (this.x = t), (this.y = t), (this.z = t), this
                },
                setX: function (t) {
                  return (this.x = t), this
                },
                setY: function (t) {
                  return (this.y = t), this
                },
                setZ: function (t) {
                  return (this.z = t), this
                },
                setComponent: function (t, e) {
                  switch (t) {
                    case 0:
                      this.x = e
                      break
                    case 1:
                      this.y = e
                      break
                    case 2:
                      this.z = e
                      break
                    default:
                      throw new Error('index is out of range: ' + t)
                  }
                  return this
                },
                getComponent: function (t) {
                  switch (t) {
                    case 0:
                      return this.x
                    case 1:
                      return this.y
                    case 2:
                      return this.z
                    default:
                      throw new Error('index is out of range: ' + t)
                  }
                },
                clone: function () {
                  return new this.constructor(this.x, this.y, this.z)
                },
                copy: function (t) {
                  return (this.x = t.x), (this.y = t.y), (this.z = t.z), this
                },
                add: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
                      ),
                      this.addVectors(t, e))
                    : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this)
                },
                addScalar: function (t) {
                  return (this.x += t), (this.y += t), (this.z += t), this
                },
                addVectors: function (t, e) {
                  return (
                    (this.x = t.x + e.x),
                    (this.y = t.y + e.y),
                    (this.z = t.z + e.z),
                    this
                  )
                },
                addScaledVector: function (t, e) {
                  return (
                    (this.x += t.x * e),
                    (this.y += t.y * e),
                    (this.z += t.z * e),
                    this
                  )
                },
                sub: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
                      ),
                      this.subVectors(t, e))
                    : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this)
                },
                subScalar: function (t) {
                  return (this.x -= t), (this.y -= t), (this.z -= t), this
                },
                subVectors: function (t, e) {
                  return (
                    (this.x = t.x - e.x),
                    (this.y = t.y - e.y),
                    (this.z = t.z - e.z),
                    this
                  )
                },
                multiply: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.',
                      ),
                      this.multiplyVectors(t, e))
                    : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this)
                },
                multiplyScalar: function (t) {
                  return (this.x *= t), (this.y *= t), (this.z *= t), this
                },
                multiplyVectors: function (t, e) {
                  return (
                    (this.x = t.x * e.x),
                    (this.y = t.y * e.y),
                    (this.z = t.z * e.z),
                    this
                  )
                },
                applyEuler: function (t) {
                  return (
                    (t && t.isEuler) ||
                      console.error(
                        'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.',
                      ),
                    this.applyQuaternion(an.setFromEuler(t))
                  )
                },
                applyAxisAngle: function (t, e) {
                  return this.applyQuaternion(an.setFromAxisAngle(t, e))
                },
                applyMatrix3: function (t) {
                  var e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements
                  return (
                    (this.x = i[0] * e + i[3] * n + i[6] * r),
                    (this.y = i[1] * e + i[4] * n + i[7] * r),
                    (this.z = i[2] * e + i[5] * n + i[8] * r),
                    this
                  )
                },
                applyNormalMatrix: function (t) {
                  return this.applyMatrix3(t).normalize()
                },
                applyMatrix4: function (t) {
                  var e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements,
                    a = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15])
                  return (
                    (this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * a),
                    (this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * a),
                    (this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * a),
                    this
                  )
                },
                applyQuaternion: function (t) {
                  var e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.x,
                    a = t.y,
                    o = t.z,
                    s = t.w,
                    c = s * e + a * r - o * n,
                    l = s * n + o * e - i * r,
                    h = s * r + i * n - a * e,
                    u = -i * e - a * n - o * r
                  return (
                    (this.x = c * s + u * -i + l * -o - h * -a),
                    (this.y = l * s + u * -a + h * -i - c * -o),
                    (this.z = h * s + u * -o + c * -a - l * -i),
                    this
                  )
                },
                project: function (t) {
                  return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
                    t.projectionMatrix,
                  )
                },
                unproject: function (t) {
                  return this.applyMatrix4(
                    t.projectionMatrixInverse,
                  ).applyMatrix4(t.matrixWorld)
                },
                transformDirection: function (t) {
                  var e = this.x,
                    n = this.y,
                    r = this.z,
                    i = t.elements
                  return (
                    (this.x = i[0] * e + i[4] * n + i[8] * r),
                    (this.y = i[1] * e + i[5] * n + i[9] * r),
                    (this.z = i[2] * e + i[6] * n + i[10] * r),
                    this.normalize()
                  )
                },
                divide: function (t) {
                  return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this
                },
                divideScalar: function (t) {
                  return this.multiplyScalar(1 / t)
                },
                min: function (t) {
                  return (
                    (this.x = Math.min(this.x, t.x)),
                    (this.y = Math.min(this.y, t.y)),
                    (this.z = Math.min(this.z, t.z)),
                    this
                  )
                },
                max: function (t) {
                  return (
                    (this.x = Math.max(this.x, t.x)),
                    (this.y = Math.max(this.y, t.y)),
                    (this.z = Math.max(this.z, t.z)),
                    this
                  )
                },
                clamp: function (t, e) {
                  return (
                    (this.x = Math.max(t.x, Math.min(e.x, this.x))),
                    (this.y = Math.max(t.y, Math.min(e.y, this.y))),
                    (this.z = Math.max(t.z, Math.min(e.z, this.z))),
                    this
                  )
                },
                clampScalar: function (t, e) {
                  return (
                    (this.x = Math.max(t, Math.min(e, this.x))),
                    (this.y = Math.max(t, Math.min(e, this.y))),
                    (this.z = Math.max(t, Math.min(e, this.z))),
                    this
                  )
                },
                clampLength: function (t, e) {
                  var n = this.length()
                  return this.divideScalar(n || 1).multiplyScalar(
                    Math.max(t, Math.min(e, n)),
                  )
                },
                floor: function () {
                  return (
                    (this.x = Math.floor(this.x)),
                    (this.y = Math.floor(this.y)),
                    (this.z = Math.floor(this.z)),
                    this
                  )
                },
                ceil: function () {
                  return (
                    (this.x = Math.ceil(this.x)),
                    (this.y = Math.ceil(this.y)),
                    (this.z = Math.ceil(this.z)),
                    this
                  )
                },
                round: function () {
                  return (
                    (this.x = Math.round(this.x)),
                    (this.y = Math.round(this.y)),
                    (this.z = Math.round(this.z)),
                    this
                  )
                },
                roundToZero: function () {
                  return (
                    (this.x =
                      this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
                    (this.y =
                      this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
                    (this.z =
                      this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
                    this
                  )
                },
                negate: function () {
                  return (
                    (this.x = -this.x),
                    (this.y = -this.y),
                    (this.z = -this.z),
                    this
                  )
                },
                dot: function (t) {
                  return this.x * t.x + this.y * t.y + this.z * t.z
                },
                lengthSq: function () {
                  return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function () {
                  return Math.sqrt(
                    this.x * this.x + this.y * this.y + this.z * this.z,
                  )
                },
                manhattanLength: function () {
                  return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function () {
                  return this.divideScalar(this.length() || 1)
                },
                setLength: function (t) {
                  return this.normalize().multiplyScalar(t)
                },
                lerp: function (t, e) {
                  return (
                    (this.x += (t.x - this.x) * e),
                    (this.y += (t.y - this.y) * e),
                    (this.z += (t.z - this.z) * e),
                    this
                  )
                },
                lerpVectors: function (t, e, n) {
                  return (
                    (this.x = t.x + (e.x - t.x) * n),
                    (this.y = t.y + (e.y - t.y) * n),
                    (this.z = t.z + (e.z - t.z) * n),
                    this
                  )
                },
                cross: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.',
                      ),
                      this.crossVectors(t, e))
                    : this.crossVectors(this, t)
                },
                crossVectors: function (t, e) {
                  var n = t.x,
                    r = t.y,
                    i = t.z,
                    a = e.x,
                    o = e.y,
                    s = e.z
                  return (
                    (this.x = r * s - i * o),
                    (this.y = i * a - n * s),
                    (this.z = n * o - r * a),
                    this
                  )
                },
                projectOnVector: function (t) {
                  var e = t.lengthSq()
                  if (0 === e) return this.set(0, 0, 0)
                  var n = t.dot(this) / e
                  return this.copy(t).multiplyScalar(n)
                },
                projectOnPlane: function (t) {
                  return rn.copy(this).projectOnVector(t), this.sub(rn)
                },
                reflect: function (t) {
                  return this.sub(rn.copy(t).multiplyScalar(2 * this.dot(t)))
                },
                angleTo: function (t) {
                  var e = Math.sqrt(this.lengthSq() * t.lengthSq())
                  if (0 === e) return Math.PI / 2
                  var n = this.dot(t) / e
                  return Math.acos(Xe.clamp(n, -1, 1))
                },
                distanceTo: function (t) {
                  return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function (t) {
                  var e = this.x - t.x,
                    n = this.y - t.y,
                    r = this.z - t.z
                  return e * e + n * n + r * r
                },
                manhattanDistanceTo: function (t) {
                  return (
                    Math.abs(this.x - t.x) +
                    Math.abs(this.y - t.y) +
                    Math.abs(this.z - t.z)
                  )
                },
                setFromSpherical: function (t) {
                  return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                },
                setFromSphericalCoords: function (t, e, n) {
                  var r = Math.sin(e) * t
                  return (
                    (this.x = r * Math.sin(n)),
                    (this.y = Math.cos(e) * t),
                    (this.z = r * Math.cos(n)),
                    this
                  )
                },
                setFromCylindrical: function (t) {
                  return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                },
                setFromCylindricalCoords: function (t, e, n) {
                  return (
                    (this.x = t * Math.sin(e)),
                    (this.y = n),
                    (this.z = t * Math.cos(e)),
                    this
                  )
                },
                setFromMatrixPosition: function (t) {
                  var e = t.elements
                  return (
                    (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this
                  )
                },
                setFromMatrixScale: function (t) {
                  var e = this.setFromMatrixColumn(t, 0).length(),
                    n = this.setFromMatrixColumn(t, 1).length(),
                    r = this.setFromMatrixColumn(t, 2).length()
                  return (this.x = e), (this.y = n), (this.z = r), this
                },
                setFromMatrixColumn: function (t, e) {
                  return this.fromArray(t.elements, 4 * e)
                },
                setFromMatrix3Column: function (t, e) {
                  return this.fromArray(t.elements, 3 * e)
                },
                equals: function (t) {
                  return t.x === this.x && t.y === this.y && t.z === this.z
                },
                fromArray: function (t, e) {
                  return (
                    void 0 === e && (e = 0),
                    (this.x = t[e]),
                    (this.y = t[e + 1]),
                    (this.z = t[e + 2]),
                    this
                  )
                },
                toArray: function (t, e) {
                  return (
                    void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    (t[e] = this.x),
                    (t[e + 1] = this.y),
                    (t[e + 2] = this.z),
                    t
                  )
                },
                fromBufferAttribute: function (t, e, n) {
                  return (
                    void 0 !== n &&
                      console.warn(
                        'THREE.Vector3: offset has been removed from .fromBufferAttribute().',
                      ),
                    (this.x = t.getX(e)),
                    (this.y = t.getY(e)),
                    (this.z = t.getZ(e)),
                    this
                  )
                },
                random: function () {
                  return (
                    (this.x = Math.random()),
                    (this.y = Math.random()),
                    (this.z = Math.random()),
                    this
                  )
                },
              })
              var sn = new on(),
                cn = new fn(),
                ln = new on(0, 0, 0),
                hn = new on(1, 1, 1),
                un = new on(),
                pn = new on(),
                dn = new on()
              function fn() {
                ;(this.elements = [
                  1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
                ]),
                  0 < arguments.length &&
                    console.error(
                      'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.',
                    )
              }
              Object.assign(fn.prototype, {
                isMatrix4: !0,
                set: function (t, e, n, r, i, a, o, s, c, l, h, u, p, d, f, m) {
                  var v = this.elements
                  return (
                    (v[0] = t),
                    (v[4] = e),
                    (v[8] = n),
                    (v[12] = r),
                    (v[1] = i),
                    (v[5] = a),
                    (v[9] = o),
                    (v[13] = s),
                    (v[2] = c),
                    (v[6] = l),
                    (v[10] = h),
                    (v[14] = u),
                    (v[3] = p),
                    (v[7] = d),
                    (v[11] = f),
                    (v[15] = m),
                    this
                  )
                },
                identity: function () {
                  return (
                    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                  )
                },
                clone: function () {
                  return new fn().fromArray(this.elements)
                },
                copy: function (t) {
                  var e = this.elements,
                    n = t.elements
                  return (
                    (e[0] = n[0]),
                    (e[1] = n[1]),
                    (e[2] = n[2]),
                    (e[3] = n[3]),
                    (e[4] = n[4]),
                    (e[5] = n[5]),
                    (e[6] = n[6]),
                    (e[7] = n[7]),
                    (e[8] = n[8]),
                    (e[9] = n[9]),
                    (e[10] = n[10]),
                    (e[11] = n[11]),
                    (e[12] = n[12]),
                    (e[13] = n[13]),
                    (e[14] = n[14]),
                    (e[15] = n[15]),
                    this
                  )
                },
                copyPosition: function (t) {
                  var e = this.elements,
                    n = t.elements
                  return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this
                },
                extractBasis: function (t, e, n) {
                  return (
                    t.setFromMatrixColumn(this, 0),
                    e.setFromMatrixColumn(this, 1),
                    n.setFromMatrixColumn(this, 2),
                    this
                  )
                },
                makeBasis: function (t, e, n) {
                  return (
                    this.set(
                      t.x,
                      e.x,
                      n.x,
                      0,
                      t.y,
                      e.y,
                      n.y,
                      0,
                      t.z,
                      e.z,
                      n.z,
                      0,
                      0,
                      0,
                      0,
                      1,
                    ),
                    this
                  )
                },
                extractRotation: function (t) {
                  var e = this.elements,
                    n = t.elements,
                    r = 1 / sn.setFromMatrixColumn(t, 0).length(),
                    i = 1 / sn.setFromMatrixColumn(t, 1).length(),
                    a = 1 / sn.setFromMatrixColumn(t, 2).length()
                  return (
                    (e[0] = n[0] * r),
                    (e[1] = n[1] * r),
                    (e[2] = n[2] * r),
                    (e[3] = 0),
                    (e[4] = n[4] * i),
                    (e[5] = n[5] * i),
                    (e[6] = n[6] * i),
                    (e[7] = 0),
                    (e[8] = n[8] * a),
                    (e[9] = n[9] * a),
                    (e[10] = n[10] * a),
                    (e[11] = 0),
                    (e[12] = 0),
                    (e[13] = 0),
                    (e[14] = 0),
                    (e[15] = 1),
                    this
                  )
                },
                makeRotationFromEuler: function (t) {
                  ;(t && t.isEuler) ||
                    console.error(
                      'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.',
                    )
                  var e,
                    n,
                    r,
                    i,
                    a,
                    o,
                    s,
                    c,
                    l,
                    h,
                    u,
                    p,
                    d,
                    f,
                    m,
                    v,
                    g,
                    y,
                    x,
                    b,
                    _,
                    w,
                    M,
                    S,
                    E = this.elements,
                    T = t.x,
                    A = t.y,
                    L = t.z,
                    R = Math.cos(T),
                    C = Math.sin(T),
                    P = Math.cos(A),
                    O = Math.sin(A),
                    I = Math.cos(L),
                    D = Math.sin(L)
                  return (
                    'XYZ' === t.order
                      ? ((e = R * I),
                        (n = R * D),
                        (r = C * I),
                        (i = C * D),
                        (E[0] = P * I),
                        (E[4] = -P * D),
                        (E[8] = O),
                        (E[1] = n + r * O),
                        (E[5] = e - i * O),
                        (E[9] = -C * P),
                        (E[2] = i - e * O),
                        (E[6] = r + n * O),
                        (E[10] = R * P))
                      : 'YXZ' === t.order
                        ? ((a = P * I),
                          (o = P * D),
                          (s = O * I),
                          (c = O * D),
                          (E[0] = a + c * C),
                          (E[4] = s * C - o),
                          (E[8] = R * O),
                          (E[1] = R * D),
                          (E[5] = R * I),
                          (E[9] = -C),
                          (E[2] = o * C - s),
                          (E[6] = c + a * C),
                          (E[10] = R * P))
                        : 'ZXY' === t.order
                          ? ((l = P * I),
                            (h = P * D),
                            (u = O * I),
                            (p = O * D),
                            (E[0] = l - p * C),
                            (E[4] = -R * D),
                            (E[8] = u + h * C),
                            (E[1] = h + u * C),
                            (E[5] = R * I),
                            (E[9] = p - l * C),
                            (E[2] = -R * O),
                            (E[6] = C),
                            (E[10] = R * P))
                          : 'ZYX' === t.order
                            ? ((d = R * I),
                              (f = R * D),
                              (m = C * I),
                              (v = C * D),
                              (E[0] = P * I),
                              (E[4] = m * O - f),
                              (E[8] = d * O + v),
                              (E[1] = P * D),
                              (E[5] = v * O + d),
                              (E[9] = f * O - m),
                              (E[2] = -O),
                              (E[6] = C * P),
                              (E[10] = R * P))
                            : 'YZX' === t.order
                              ? ((g = R * P),
                                (y = R * O),
                                (x = C * P),
                                (b = C * O),
                                (E[0] = P * I),
                                (E[4] = b - g * D),
                                (E[8] = x * D + y),
                                (E[1] = D),
                                (E[5] = R * I),
                                (E[9] = -C * I),
                                (E[2] = -O * I),
                                (E[6] = y * D + x),
                                (E[10] = g - b * D))
                              : 'XZY' === t.order &&
                                ((_ = R * P),
                                (w = R * O),
                                (M = C * P),
                                (S = C * O),
                                (E[0] = P * I),
                                (E[4] = -D),
                                (E[8] = O * I),
                                (E[1] = _ * D + S),
                                (E[5] = R * I),
                                (E[9] = w * D - M),
                                (E[2] = M * D - w),
                                (E[6] = C * I),
                                (E[10] = S * D + _)),
                    (E[3] = 0),
                    (E[7] = 0),
                    (E[11] = 0),
                    (E[12] = 0),
                    (E[13] = 0),
                    (E[14] = 0),
                    (E[15] = 1),
                    this
                  )
                },
                makeRotationFromQuaternion: function (t) {
                  return this.compose(ln, t, hn)
                },
                lookAt: function (t, e, n) {
                  var r = this.elements
                  return (
                    dn.subVectors(t, e),
                    0 === dn.lengthSq() && (dn.z = 1),
                    dn.normalize(),
                    un.crossVectors(n, dn),
                    0 === un.lengthSq() &&
                      (1 === Math.abs(n.z) ? (dn.x += 1e-4) : (dn.z += 1e-4),
                      dn.normalize(),
                      un.crossVectors(n, dn)),
                    un.normalize(),
                    pn.crossVectors(dn, un),
                    (r[0] = un.x),
                    (r[4] = pn.x),
                    (r[8] = dn.x),
                    (r[1] = un.y),
                    (r[5] = pn.y),
                    (r[9] = dn.y),
                    (r[2] = un.z),
                    (r[6] = pn.z),
                    (r[10] = dn.z),
                    this
                  )
                },
                multiply: function (t, e) {
                  return void 0 !== e
                    ? (console.warn(
                        'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.',
                      ),
                      this.multiplyMatrices(t, e))
                    : this.multiplyMatrices(this, t)
                },
                premultiply: function (t) {
                  return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function (t, e) {
                  var n = t.elements,
                    r = e.elements,
                    i = this.elements,
                    a = n[0],
                    o = n[4],
                    s = n[8],
                    c = n[12],
                    l = n[1],
                    h = n[5],
                    u = n[9],
                    p = n[13],
                    d = n[2],
                    f = n[6],
                    m = n[10],
                    v = n[14],
                    g = n[3],
                    y = n[7],
                    x = n[11],
                    b = n[15],
                    _ = r[0],
                    w = r[4],
                    M = r[8],
                    S = r[12],
                    E = r[1],
                    T = r[5],
                    A = r[9],
                    L = r[13],
                    R = r[2],
                    C = r[6],
                    P = r[10],
                    O = r[14],
                    I = r[3],
                    D = r[7],
                    B = r[11],
                    N = r[15]
                  return (
                    (i[0] = a * _ + o * E + s * R + c * I),
                    (i[4] = a * w + o * T + s * C + c * D),
                    (i[8] = a * M + o * A + s * P + c * B),
                    (i[12] = a * S + o * L + s * O + c * N),
                    (i[1] = l * _ + h * E + u * R + p * I),
                    (i[5] = l * w + h * T + u * C + p * D),
                    (i[9] = l * M + h * A + u * P + p * B),
                    (i[13] = l * S + h * L + u * O + p * N),
                    (i[2] = d * _ + f * E + m * R + v * I),
                    (i[6] = d * w + f * T + m * C + v * D),
                    (i[10] = d * M + f * A + m * P + v * B),
                    (i[14] = d * S + f * L + m * O + v * N),
                    (i[3] = g * _ + y * E + x * R + b * I),
                    (i[7] = g * w + y * T + x * C + b * D),
                    (i[11] = g * M + y * A + x * P + b * B),
                    (i[15] = g * S + y * L + x * O + b * N),
                    this
                  )
                },
                multiplyScalar: function (t) {
                  var e = this.elements
                  return (
                    (e[0] *= t),
                    (e[4] *= t),
                    (e[8] *= t),
                    (e[12] *= t),
                    (e[1] *= t),
                    (e[5] *= t),
                    (e[9] *= t),
                    (e[13] *= t),
                    (e[2] *= t),
                    (e[6] *= t),
                    (e[10] *= t),
                    (e[14] *= t),
                    (e[3] *= t),
                    (e[7] *= t),
                    (e[11] *= t),
                    (e[15] *= t),
                    this
                  )
                },
                determinant: function () {
                  var t = this.elements,
                    e = t[0],
                    n = t[4],
                    r = t[8],
                    i = t[12],
                    a = t[1],
                    o = t[5],
                    s = t[9],
                    c = t[13],
                    l = t[2],
                    h = t[6],
                    u = t[10],
                    p = t[14]
                  return (
                    t[3] *
                      (i * s * h -
                        r * c * h -
                        i * o * u +
                        n * c * u +
                        r * o * p -
                        n * s * p) +
                    t[7] *
                      (e * s * p -
                        e * c * u +
                        i * a * u -
                        r * a * p +
                        r * c * l -
                        i * s * l) +
                    t[11] *
                      (e * c * h -
                        e * o * p -
                        i * a * h +
                        n * a * p +
                        i * o * l -
                        n * c * l) +
                    t[15] *
                      (-r * o * l -
                        e * s * h +
                        e * o * u +
                        r * a * h -
                        n * a * u +
                        n * s * l)
                  )
                },
                transpose: function () {
                  var t = this.elements,
                    e = t[1]
                  return (
                    (t[1] = t[4]),
                    (t[4] = e),
                    (e = t[2]),
                    (t[2] = t[8]),
                    (t[8] = e),
                    (e = t[6]),
                    (t[6] = t[9]),
                    (t[9] = e),
                    (e = t[3]),
                    (t[3] = t[12]),
                    (t[12] = e),
                    (e = t[7]),
                    (t[7] = t[13]),
                    (t[13] = e),
                    (e = t[11]),
                    (t[11] = t[14]),
                    (t[14] = e),
                    this
                  )
                },
                setPosition: function (t, e, n) {
                  var r = this.elements
                  return (
                    t.isVector3
                      ? ((r[12] = t.x), (r[13] = t.y), (r[14] = t.z))
                      : ((r[12] = t), (r[13] = e), (r[14] = n)),
                    this
                  )
                },
                getInverse: function (t, e) {
                  void 0 !== e &&
                    console.warn(
                      'THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.',
                    )
                  var n = this.elements,
                    r = t.elements,
                    i = r[0],
                    a = r[1],
                    o = r[2],
                    s = r[3],
                    c = r[4],
                    l = r[5],
                    h = r[6],
                    u = r[7],
                    p = r[8],
                    d = r[9],
                    f = r[10],
                    m = r[11],
                    v = r[12],
                    g = r[13],
                    y = r[14],
                    x = r[15],
                    b =
                      d * y * u -
                      g * f * u +
                      g * h * m -
                      l * y * m -
                      d * h * x +
                      l * f * x,
                    _ =
                      v * f * u -
                      p * y * u -
                      v * h * m +
                      c * y * m +
                      p * h * x -
                      c * f * x,
                    w =
                      p * g * u -
                      v * d * u +
                      v * l * m -
                      c * g * m -
                      p * l * x +
                      c * d * x,
                    M =
                      v * d * h -
                      p * g * h -
                      v * l * f +
                      c * g * f +
                      p * l * y -
                      c * d * y,
                    S = i * b + a * _ + o * w + s * M
                  if (0 == S)
                    return this.set(
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                      0,
                    )
                  var E = 1 / S
                  return (
                    (n[0] = b * E),
                    (n[1] =
                      (g * f * s -
                        d * y * s -
                        g * o * m +
                        a * y * m +
                        d * o * x -
                        a * f * x) *
                      E),
                    (n[2] =
                      (l * y * s -
                        g * h * s +
                        g * o * u -
                        a * y * u -
                        l * o * x +
                        a * h * x) *
                      E),
                    (n[3] =
                      (d * h * s -
                        l * f * s -
                        d * o * u +
                        a * f * u +
                        l * o * m -
                        a * h * m) *
                      E),
                    (n[4] = _ * E),
                    (n[5] =
                      (p * y * s -
                        v * f * s +
                        v * o * m -
                        i * y * m -
                        p * o * x +
                        i * f * x) *
                      E),
                    (n[6] =
                      (v * h * s -
                        c * y * s -
                        v * o * u +
                        i * y * u +
                        c * o * x -
                        i * h * x) *
                      E),
                    (n[7] =
                      (c * f * s -
                        p * h * s +
                        p * o * u -
                        i * f * u -
                        c * o * m +
                        i * h * m) *
                      E),
                    (n[8] = w * E),
                    (n[9] =
                      (v * d * s -
                        p * g * s -
                        v * a * m +
                        i * g * m +
                        p * a * x -
                        i * d * x) *
                      E),
                    (n[10] =
                      (c * g * s -
                        v * l * s +
                        v * a * u -
                        i * g * u -
                        c * a * x +
                        i * l * x) *
                      E),
                    (n[11] =
                      (p * l * s -
                        c * d * s -
                        p * a * u +
                        i * d * u +
                        c * a * m -
                        i * l * m) *
                      E),
                    (n[12] = M * E),
                    (n[13] =
                      (p * g * o -
                        v * d * o +
                        v * a * f -
                        i * g * f -
                        p * a * y +
                        i * d * y) *
                      E),
                    (n[14] =
                      (v * l * o -
                        c * g * o -
                        v * a * h +
                        i * g * h +
                        c * a * y -
                        i * l * y) *
                      E),
                    (n[15] =
                      (c * d * o -
                        p * l * o +
                        p * a * h -
                        i * d * h -
                        c * a * f +
                        i * l * f) *
                      E),
                    this
                  )
                },
                scale: function (t) {
                  var e = this.elements,
                    n = t.x,
                    r = t.y,
                    i = t.z
                  return (
                    (e[0] *= n),
                    (e[4] *= r),
                    (e[8] *= i),
                    (e[1] *= n),
                    (e[5] *= r),
                    (e[9] *= i),
                    (e[2] *= n),
                    (e[6] *= r),
                    (e[10] *= i),
                    (e[3] *= n),
                    (e[7] *= r),
                    (e[11] *= i),
                    this
                  )
                },
                getMaxScaleOnAxis: function () {
                  var t = this.elements,
                    e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                    n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                    r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]
                  return Math.sqrt(Math.max(e, n, r))
                },
                makeTranslation: function (t, e, n) {
                  return (
                    this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
                    this
                  )
                },
                makeRotationX: function (t) {
                  var e = Math.cos(t),
                    n = Math.sin(t)
                  return (
                    this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
                    this
                  )
                },
                makeRotationY: function (t) {
                  var e = Math.cos(t),
                    n = Math.sin(t)
                  return (
                    this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
                    this
                  )
                },
                makeRotationZ: function (t) {
                  var e = Math.cos(t),
                    n = Math.sin(t)
                  return (
                    this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                  )
                },
                makeRotationAxis: function (t, e) {
                  var n = Math.cos(e),
                    r = Math.sin(e),
                    i = 1 - n,
                    a = t.x,
                    o = t.y,
                    s = t.z,
                    c = i * a,
                    l = i * o
                  return (
                    this.set(
                      c * a + n,
                      c * o - r * s,
                      c * s + r * o,
                      0,
                      c * o + r * s,
                      l * o + n,
                      l * s - r * a,
                      0,
                      c * s - r * o,
                      l * s + r * a,
                      i * s * s + n,
                      0,
                      0,
                      0,
                      0,
                      1,
                    ),
                    this
                  )
                },
                makeScale: function (t, e, n) {
                  return (
                    this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                    this
                  )
                },
                makeShear: function (t, e, n) {
                  return (
                    this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
                    this
                  )
                },
                compose: function (t, e, n) {
                  var r = this.elements,
                    i = e._x,
                    a = e._y,
                    o = e._z,
                    s = e._w,
                    c = i + i,
                    l = a + a,
                    h = o + o,
                    u = i * c,
                    p = i * l,
                    d = i * h,
                    f = a * l,
                    m = a * h,
                    v = o * h,
                    g = s * c,
                    y = s * l,
                    x = s * h,
                    b = n.x,
                    _ = n.y,
                    w = n.z
                  return (
                    (r[0] = (1 - (f + v)) * b),
                    (r[1] = (p + x) * b),
                    (r[2] = (d - y) * b),
                    (r[3] = 0),
                    (r[4] = (p - x) * _),
                    (r[5] = (1 - (u + v)) * _),
                    (r[6] = (m + g) * _),
                    (r[7] = 0),
                    (r[8] = (d + y) * w),
                    (r[9] = (m - g) * w),
                    (r[10] = (1 - (u + f)) * w),
                    (r[11] = 0),
                    (r[12] = t.x),
                    (r[13] = t.y),
                    (r[14] = t.z),
                    (r[15] = 1),
                    this
                  )
                },
                decompose: function (t, e, n) {
                  var r = this.elements,
                    i = sn.set(r[0], r[1], r[2]).length(),
                    a = sn.set(r[4], r[5], r[6]).length(),
                    o = sn.set(r[8], r[9], r[10]).length()
                  this.determinant() < 0 && (i = -i),
                    (t.x = r[12]),
                    (t.y = r[13]),
                    (t.z = r[14]),
                    cn.copy(this)
                  var s = 1 / i,
                    c = 1 / a,
                    l = 1 / o
                  return (
                    (cn.elements[0] *= s),
                    (cn.elements[1] *= s),
                    (cn.elements[2] *= s),
                    (cn.elements[4] *= c),
                    (cn.elements[5] *= c),
                    (cn.elements[6] *= c),
                    (cn.elements[8] *= l),
                    (cn.elements[9] *= l),
                    (cn.elements[10] *= l),
                    e.setFromRotationMatrix(cn),
                    (n.x = i),
                    (n.y = a),
                    (n.z = o),
                    this
                  )
                },
                makePerspective: function (t, e, n, r, i, a) {
                  void 0 === a &&
                    console.warn(
                      'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.',
                    )
                  var o = this.elements,
                    s = (2 * i) / (e - t),
                    c = (2 * i) / (n - r),
                    l = (e + t) / (e - t),
                    h = (n + r) / (n - r),
                    u = -(a + i) / (a - i),
                    p = (-2 * a * i) / (a - i)
                  return (
                    (o[0] = s),
                    (o[4] = 0),
                    (o[8] = l),
                    (o[12] = 0),
                    (o[1] = 0),
                    (o[5] = c),
                    (o[9] = h),
                    (o[13] = 0),
                    (o[2] = 0),
                    (o[6] = 0),
                    (o[10] = u),
                    (o[14] = p),
                    (o[3] = 0),
                    (o[7] = 0),
                    (o[11] = -1),
                    (o[15] = 0),
                    this
                  )
                },
                makeOrthographic: function (t, e, n, r, i, a) {
                  var o = this.elements,
                    s = 1 / (e - t),
                    c = 1 / (n - r),
                    l = 1 / (a - i),
                    h = (e + t) * s,
                    u = (n + r) * c,
                    p = (a + i) * l
                  return (
                    (o[0] = 2 * s),
                    (o[4] = 0),
                    (o[8] = 0),
                    (o[12] = -h),
                    (o[1] = 0),
                    (o[5] = 2 * c),
                    (o[9] = 0),
                    (o[13] = -u),
                    (o[2] = 0),
                    (o[6] = 0),
                    (o[10] = -2 * l),
                    (o[14] = -p),
                    (o[3] = 0),
                    (o[7] = 0),
                    (o[11] = 0),
                    (o[15] = 1),
                    this
                  )
                },
                equals: function (t) {
                  for (
                    var e = this.elements, n = t.elements, r = 0;
                    r < 16;
                    r++
                  )
                    if (e[r] !== n[r]) return !1
                  return !0
                },
                fromArray: function (t, e) {
                  void 0 === e && (e = 0)
                  for (var n = 0; n < 16; n++) this.elements[n] = t[n + e]
                  return this
                },
                toArray: function (t, e) {
                  void 0 === t && (t = []), void 0 === e && (e = 0)
                  var n = this.elements
                  return (
                    (t[e] = n[0]),
                    (t[e + 1] = n[1]),
                    (t[e + 2] = n[2]),
                    (t[e + 3] = n[3]),
                    (t[e + 4] = n[4]),
                    (t[e + 5] = n[5]),
                    (t[e + 6] = n[6]),
                    (t[e + 7] = n[7]),
                    (t[e + 8] = n[8]),
                    (t[e + 9] = n[9]),
                    (t[e + 10] = n[10]),
                    (t[e + 11] = n[11]),
                    (t[e + 12] = n[12]),
                    (t[e + 13] = n[13]),
                    (t[e + 14] = n[14]),
                    (t[e + 15] = n[15]),
                    t
                  )
                },
              })
              var mn = new fn(),
                vn = new nn()
              function gn(t, e, n, r) {
                void 0 === t && (t = 0),
                  void 0 === e && (e = 0),
                  void 0 === n && (n = 0),
                  void 0 === r && (r = gn.DefaultOrder),
                  (this._x = t),
                  (this._y = e),
                  (this._z = n),
                  (this._order = r)
              }
              function yn() {
                this.mask = 1
              }
              ;(gn.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']),
                (gn.DefaultOrder = 'XYZ'),
                Object.defineProperties(gn.prototype, {
                  x: {
                    get: function () {
                      return this._x
                    },
                    set: function (t) {
                      ;(this._x = t), this._onChangeCallback()
                    },
                  },
                  y: {
                    get: function () {
                      return this._y
                    },
                    set: function (t) {
                      ;(this._y = t), this._onChangeCallback()
                    },
                  },
                  z: {
                    get: function () {
                      return this._z
                    },
                    set: function (t) {
                      ;(this._z = t), this._onChangeCallback()
                    },
                  },
                  order: {
                    get: function () {
                      return this._order
                    },
                    set: function (t) {
                      ;(this._order = t), this._onChangeCallback()
                    },
                  },
                }),
                Object.assign(gn.prototype, {
                  isEuler: !0,
                  set: function (t, e, n, r) {
                    return (
                      (this._x = t),
                      (this._y = e),
                      (this._z = n),
                      (this._order = r || this._order),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  clone: function () {
                    return new this.constructor(
                      this._x,
                      this._y,
                      this._z,
                      this._order,
                    )
                  },
                  copy: function (t) {
                    return (
                      (this._x = t._x),
                      (this._y = t._y),
                      (this._z = t._z),
                      (this._order = t._order),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  setFromRotationMatrix: function (t, e, n) {
                    var r = Xe.clamp,
                      i = t.elements,
                      a = i[0],
                      o = i[4],
                      s = i[8],
                      c = i[1],
                      l = i[5],
                      h = i[9],
                      u = i[2],
                      p = i[6],
                      d = i[10]
                    switch ((e = e || this._order)) {
                      case 'XYZ':
                        ;(this._y = Math.asin(r(s, -1, 1))),
                          Math.abs(s) < 0.9999999
                            ? ((this._x = Math.atan2(-h, d)),
                              (this._z = Math.atan2(-o, a)))
                            : ((this._x = Math.atan2(p, l)), (this._z = 0))
                        break
                      case 'YXZ':
                        ;(this._x = Math.asin(-r(h, -1, 1))),
                          Math.abs(h) < 0.9999999
                            ? ((this._y = Math.atan2(s, d)),
                              (this._z = Math.atan2(c, l)))
                            : ((this._y = Math.atan2(-u, a)), (this._z = 0))
                        break
                      case 'ZXY':
                        ;(this._x = Math.asin(r(p, -1, 1))),
                          Math.abs(p) < 0.9999999
                            ? ((this._y = Math.atan2(-u, d)),
                              (this._z = Math.atan2(-o, l)))
                            : ((this._y = 0), (this._z = Math.atan2(c, a)))
                        break
                      case 'ZYX':
                        ;(this._y = Math.asin(-r(u, -1, 1))),
                          Math.abs(u) < 0.9999999
                            ? ((this._x = Math.atan2(p, d)),
                              (this._z = Math.atan2(c, a)))
                            : ((this._x = 0), (this._z = Math.atan2(-o, l)))
                        break
                      case 'YZX':
                        ;(this._z = Math.asin(r(c, -1, 1))),
                          Math.abs(c) < 0.9999999
                            ? ((this._x = Math.atan2(-h, l)),
                              (this._y = Math.atan2(-u, a)))
                            : ((this._x = 0), (this._y = Math.atan2(s, d)))
                        break
                      case 'XZY':
                        ;(this._z = Math.asin(-r(o, -1, 1))),
                          Math.abs(o) < 0.9999999
                            ? ((this._x = Math.atan2(p, l)),
                              (this._y = Math.atan2(s, a)))
                            : ((this._x = Math.atan2(-h, d)), (this._y = 0))
                        break
                      default:
                        console.warn(
                          'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
                            e,
                        )
                    }
                    return (
                      (this._order = e),
                      !1 !== n && this._onChangeCallback(),
                      this
                    )
                  },
                  setFromQuaternion: function (t, e, n) {
                    return (
                      mn.makeRotationFromQuaternion(t),
                      this.setFromRotationMatrix(mn, e, n)
                    )
                  },
                  setFromVector3: function (t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                  },
                  reorder: function (t) {
                    return vn.setFromEuler(this), this.setFromQuaternion(vn, t)
                  },
                  equals: function (t) {
                    return (
                      t._x === this._x &&
                      t._y === this._y &&
                      t._z === this._z &&
                      t._order === this._order
                    )
                  },
                  fromArray: function (t) {
                    return (
                      (this._x = t[0]),
                      (this._y = t[1]),
                      (this._z = t[2]),
                      void 0 !== t[3] && (this._order = t[3]),
                      this._onChangeCallback(),
                      this
                    )
                  },
                  toArray: function (t, e) {
                    return (
                      void 0 === t && (t = []),
                      void 0 === e && (e = 0),
                      (t[e] = this._x),
                      (t[e + 1] = this._y),
                      (t[e + 2] = this._z),
                      (t[e + 3] = this._order),
                      t
                    )
                  },
                  toVector3: function (t) {
                    return t
                      ? t.set(this._x, this._y, this._z)
                      : new on(this._x, this._y, this._z)
                  },
                  _onChange: function (t) {
                    return (this._onChangeCallback = t), this
                  },
                  _onChangeCallback: function () {},
                }),
                Object.assign(yn.prototype, {
                  set: function (t) {
                    this.mask = (1 << t) | 0
                  },
                  enable: function (t) {
                    this.mask |= (1 << t) | 0
                  },
                  enableAll: function () {
                    this.mask = -1
                  },
                  toggle: function (t) {
                    this.mask ^= (1 << t) | 0
                  },
                  disable: function (t) {
                    this.mask &= ~((1 << t) | 0)
                  },
                  disableAll: function () {
                    this.mask = 0
                  },
                  test: function (t) {
                    return 0 != (this.mask & t.mask)
                  },
                })
              var xn = 0,
                bn = new on(),
                _n = new nn(),
                wn = new fn(),
                Mn = new on(),
                Sn = new on(),
                En = new on(),
                Tn = new nn(),
                An = new on(1, 0, 0),
                Ln = new on(0, 1, 0),
                Rn = new on(0, 0, 1),
                Cn = { type: 'added' },
                Pn = { type: 'removed' }
              function On() {
                Object.defineProperty(this, 'id', { value: xn++ }),
                  (this.uuid = Xe.generateUUID()),
                  (this.name = ''),
                  (this.type = 'Object3D'),
                  (this.parent = null),
                  (this.children = []),
                  (this.up = On.DefaultUp.clone())
                var t = new on(),
                  e = new gn(),
                  n = new nn(),
                  r = new on(1, 1, 1)
                e._onChange(function () {
                  n.setFromEuler(e, !1)
                }),
                  n._onChange(function () {
                    e.setFromQuaternion(n, void 0, !1)
                  }),
                  Object.defineProperties(this, {
                    position: { configurable: !0, enumerable: !0, value: t },
                    rotation: { configurable: !0, enumerable: !0, value: e },
                    quaternion: { configurable: !0, enumerable: !0, value: n },
                    scale: { configurable: !0, enumerable: !0, value: r },
                    modelViewMatrix: { value: new fn() },
                    normalMatrix: { value: new Ze() },
                  }),
                  (this.matrix = new fn()),
                  (this.matrixWorld = new fn()),
                  (this.matrixAutoUpdate = On.DefaultMatrixAutoUpdate),
                  (this.matrixWorldNeedsUpdate = !1),
                  (this.layers = new yn()),
                  (this.visible = !0),
                  (this.castShadow = !1),
                  (this.receiveShadow = !1),
                  (this.frustumCulled = !0),
                  (this.renderOrder = 0),
                  (this.userData = {})
              }
              function In() {
                On.call(this),
                  (this.type = 'Scene'),
                  (this.background = null),
                  (this.environment = null),
                  (this.fog = null),
                  (this.overrideMaterial = null),
                  (this.autoUpdate = !0),
                  'undefined' != typeof __THREE_DEVTOOLS__ &&
                    __THREE_DEVTOOLS__.dispatchEvent(
                      new CustomEvent('observe', { detail: this }),
                    )
              }
              ;(On.DefaultUp = new on(0, 1, 0)),
                (On.DefaultMatrixAutoUpdate = !0),
                (On.prototype = Object.assign(Object.create(Ve.prototype), {
                  constructor: On,
                  isObject3D: !0,
                  onBeforeRender: function () {},
                  onAfterRender: function () {},
                  applyMatrix4: function (t) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                      this.matrix.premultiply(t),
                      this.matrix.decompose(
                        this.position,
                        this.quaternion,
                        this.scale,
                      )
                  },
                  applyQuaternion: function (t) {
                    return this.quaternion.premultiply(t), this
                  },
                  setRotationFromAxisAngle: function (t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                  },
                  setRotationFromEuler: function (t) {
                    this.quaternion.setFromEuler(t, !0)
                  },
                  setRotationFromMatrix: function (t) {
                    this.quaternion.setFromRotationMatrix(t)
                  },
                  setRotationFromQuaternion: function (t) {
                    this.quaternion.copy(t)
                  },
                  rotateOnAxis: function (t, e) {
                    return (
                      _n.setFromAxisAngle(t, e),
                      this.quaternion.multiply(_n),
                      this
                    )
                  },
                  rotateOnWorldAxis: function (t, e) {
                    return (
                      _n.setFromAxisAngle(t, e),
                      this.quaternion.premultiply(_n),
                      this
                    )
                  },
                  rotateX: function (t) {
                    return this.rotateOnAxis(An, t)
                  },
                  rotateY: function (t) {
                    return this.rotateOnAxis(Ln, t)
                  },
                  rotateZ: function (t) {
                    return this.rotateOnAxis(Rn, t)
                  },
                  translateOnAxis: function (t, e) {
                    return (
                      bn.copy(t).applyQuaternion(this.quaternion),
                      this.position.add(bn.multiplyScalar(e)),
                      this
                    )
                  },
                  translateX: function (t) {
                    return this.translateOnAxis(An, t)
                  },
                  translateY: function (t) {
                    return this.translateOnAxis(Ln, t)
                  },
                  translateZ: function (t) {
                    return this.translateOnAxis(Rn, t)
                  },
                  localToWorld: function (t) {
                    return t.applyMatrix4(this.matrixWorld)
                  },
                  worldToLocal: function (t) {
                    return t.applyMatrix4(wn.getInverse(this.matrixWorld))
                  },
                  lookAt: function (t, e, n) {
                    t.isVector3 ? Mn.copy(t) : Mn.set(t, e, n)
                    var r = this.parent
                    this.updateWorldMatrix(!0, !1),
                      Sn.setFromMatrixPosition(this.matrixWorld),
                      this.isCamera || this.isLight
                        ? wn.lookAt(Sn, Mn, this.up)
                        : wn.lookAt(Mn, Sn, this.up),
                      this.quaternion.setFromRotationMatrix(wn),
                      r &&
                        (wn.extractRotation(r.matrixWorld),
                        _n.setFromRotationMatrix(wn),
                        this.quaternion.premultiply(_n.inverse()))
                  },
                  add: function (t) {
                    if (1 < arguments.length) {
                      for (var e = 0; e < arguments.length; e++)
                        this.add(arguments[e])
                      return this
                    }
                    return (
                      t === this
                        ? console.error(
                            "THREE.Object3D.add: object can't be added as a child of itself.",
                            t,
                          )
                        : t && t.isObject3D
                          ? (null !== t.parent && t.parent.remove(t),
                            (t.parent = this).children.push(t),
                            t.dispatchEvent(Cn))
                          : console.error(
                              'THREE.Object3D.add: object not an instance of THREE.Object3D.',
                              t,
                            ),
                      this
                    )
                  },
                  remove: function (t) {
                    if (1 < arguments.length) {
                      for (var e = 0; e < arguments.length; e++)
                        this.remove(arguments[e])
                      return this
                    }
                    var n = this.children.indexOf(t)
                    return (
                      -1 !== n &&
                        ((t.parent = null),
                        this.children.splice(n, 1),
                        t.dispatchEvent(Pn)),
                      this
                    )
                  },
                  attach: function (t) {
                    return (
                      this.updateWorldMatrix(!0, !1),
                      wn.getInverse(this.matrixWorld),
                      null !== t.parent &&
                        (t.parent.updateWorldMatrix(!0, !1),
                        wn.multiply(t.parent.matrixWorld)),
                      t.applyMatrix4(wn),
                      t.updateWorldMatrix(!1, !1),
                      this.add(t),
                      this
                    )
                  },
                  getObjectById: function (t) {
                    return this.getObjectByProperty('id', t)
                  },
                  getObjectByName: function (t) {
                    return this.getObjectByProperty('name', t)
                  },
                  getObjectByProperty: function (t, e) {
                    if (this[t] === e) return this
                    for (var n = 0, r = this.children.length; n < r; n++) {
                      var i = this.children[n].getObjectByProperty(t, e)
                      if (void 0 !== i) return i
                    }
                  },
                  getWorldPosition: function (t) {
                    return (
                      void 0 === t &&
                        (console.warn(
                          'THREE.Object3D: .getWorldPosition() target is now required',
                        ),
                        (t = new on())),
                      this.updateMatrixWorld(!0),
                      t.setFromMatrixPosition(this.matrixWorld)
                    )
                  },
                  getWorldQuaternion: function (t) {
                    return (
                      void 0 === t &&
                        (console.warn(
                          'THREE.Object3D: .getWorldQuaternion() target is now required',
                        ),
                        (t = new nn())),
                      this.updateMatrixWorld(!0),
                      this.matrixWorld.decompose(Sn, t, En),
                      t
                    )
                  },
                  getWorldScale: function (t) {
                    return (
                      void 0 === t &&
                        (console.warn(
                          'THREE.Object3D: .getWorldScale() target is now required',
                        ),
                        (t = new on())),
                      this.updateMatrixWorld(!0),
                      this.matrixWorld.decompose(Sn, Tn, t),
                      t
                    )
                  },
                  getWorldDirection: function (t) {
                    void 0 === t &&
                      (console.warn(
                        'THREE.Object3D: .getWorldDirection() target is now required',
                      ),
                      (t = new on())),
                      this.updateMatrixWorld(!0)
                    var e = this.matrixWorld.elements
                    return t.set(e[8], e[9], e[10]).normalize()
                  },
                  raycast: function () {},
                  traverse: function (t) {
                    t(this)
                    for (var e = this.children, n = 0, r = e.length; n < r; n++)
                      e[n].traverse(t)
                  },
                  traverseVisible: function (t) {
                    if (!1 !== this.visible) {
                      t(this)
                      for (
                        var e = this.children, n = 0, r = e.length;
                        n < r;
                        n++
                      )
                        e[n].traverseVisible(t)
                    }
                  },
                  traverseAncestors: function (t) {
                    var e = this.parent
                    null !== e && (t(e), e.traverseAncestors(t))
                  },
                  updateMatrix: function () {
                    this.matrix.compose(
                      this.position,
                      this.quaternion,
                      this.scale,
                    ),
                      (this.matrixWorldNeedsUpdate = !0)
                  },
                  updateMatrixWorld: function (t) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                      (this.matrixWorldNeedsUpdate || t) &&
                        (null === this.parent
                          ? this.matrixWorld.copy(this.matrix)
                          : this.matrixWorld.multiplyMatrices(
                              this.parent.matrixWorld,
                              this.matrix,
                            ),
                        (t = !(this.matrixWorldNeedsUpdate = !1)))
                    for (var e = this.children, n = 0, r = e.length; n < r; n++)
                      e[n].updateMatrixWorld(t)
                  },
                  updateWorldMatrix: function (t, e) {
                    var n = this.parent
                    if (
                      (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
                      this.matrixAutoUpdate && this.updateMatrix(),
                      null === this.parent
                        ? this.matrixWorld.copy(this.matrix)
                        : this.matrixWorld.multiplyMatrices(
                            this.parent.matrixWorld,
                            this.matrix,
                          ),
                      !0 === e)
                    )
                      for (
                        var r = this.children, i = 0, a = r.length;
                        i < a;
                        i++
                      )
                        r[i].updateWorldMatrix(!1, !0)
                  },
                  toJSON: function (n) {
                    var t = void 0 === n || 'string' == typeof n,
                      e = {}
                    t &&
                      ((n = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                      }),
                      (e.metadata = {
                        version: 4.5,
                        type: 'Object',
                        generator: 'Object3D.toJSON',
                      }))
                    var r,
                      i,
                      a,
                      o,
                      s,
                      c = {}
                    function l(t, e) {
                      return (
                        void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(n)),
                        e.uuid
                      )
                    }
                    if (
                      ((c.uuid = this.uuid),
                      (c.type = this.type),
                      '' !== this.name && (c.name = this.name),
                      !0 === this.castShadow && (c.castShadow = !0),
                      !0 === this.receiveShadow && (c.receiveShadow = !0),
                      !1 === this.visible && (c.visible = !1),
                      !1 === this.frustumCulled && (c.frustumCulled = !1),
                      0 !== this.renderOrder &&
                        (c.renderOrder = this.renderOrder),
                      '{}' !== JSON.stringify(this.userData) &&
                        (c.userData = this.userData),
                      (c.layers = this.layers.mask),
                      (c.matrix = this.matrix.toArray()),
                      !1 === this.matrixAutoUpdate && (c.matrixAutoUpdate = !1),
                      this.isInstancedMesh &&
                        ((c.type = 'InstancedMesh'),
                        (c.count = this.count),
                        (c.instanceMatrix = this.instanceMatrix.toJSON())),
                      this.isMesh || this.isLine || this.isPoints)
                    ) {
                      c.geometry = l(n.geometries, this.geometry)
                      var h = this.geometry.parameters
                      if (void 0 !== h && void 0 !== h.shapes) {
                        var u = h.shapes
                        if (Array.isArray(u))
                          for (var p = 0, d = u.length; p < d; p++) {
                            var f = u[p]
                            l(n.shapes, f)
                          }
                        else l(n.shapes, u)
                      }
                    }
                    if (void 0 !== this.material)
                      if (Array.isArray(this.material)) {
                        for (
                          var m = [], v = 0, g = this.material.length;
                          v < g;
                          v++
                        )
                          m.push(l(n.materials, this.material[v]))
                        c.material = m
                      } else c.material = l(n.materials, this.material)
                    if (0 < this.children.length) {
                      c.children = []
                      for (var y = 0; y < this.children.length; y++)
                        c.children.push(this.children[y].toJSON(n).object)
                    }
                    return (
                      t &&
                        ((r = x(n.geometries)),
                        (i = x(n.materials)),
                        (a = x(n.textures)),
                        (o = x(n.images)),
                        (s = x(n.shapes)),
                        0 < r.length && (e.geometries = r),
                        0 < i.length && (e.materials = i),
                        0 < a.length && (e.textures = a),
                        0 < o.length && (e.images = o),
                        0 < s.length && (e.shapes = s)),
                      (e.object = c),
                      e
                    )
                    function x(t) {
                      var e = []
                      for (var n in t) {
                        var r = t[n]
                        delete r.metadata, e.push(r)
                      }
                      return e
                    }
                  },
                  clone: function (t) {
                    return new this.constructor().copy(this, t)
                  },
                  copy: function (t, e) {
                    if (
                      (void 0 === e && (e = !0),
                      (this.name = t.name),
                      this.up.copy(t.up),
                      this.position.copy(t.position),
                      this.quaternion.copy(t.quaternion),
                      this.scale.copy(t.scale),
                      this.matrix.copy(t.matrix),
                      this.matrixWorld.copy(t.matrixWorld),
                      (this.matrixAutoUpdate = t.matrixAutoUpdate),
                      (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
                      (this.layers.mask = t.layers.mask),
                      (this.visible = t.visible),
                      (this.castShadow = t.castShadow),
                      (this.receiveShadow = t.receiveShadow),
                      (this.frustumCulled = t.frustumCulled),
                      (this.renderOrder = t.renderOrder),
                      (this.userData = JSON.parse(JSON.stringify(t.userData))),
                      !0 === e)
                    )
                      for (var n = 0; n < t.children.length; n++) {
                        var r = t.children[n]
                        this.add(r.clone())
                      }
                    return this
                  },
                })),
                (In.prototype = Object.assign(Object.create(On.prototype), {
                  constructor: In,
                  isScene: !0,
                  copy: function (t, e) {
                    return (
                      On.prototype.copy.call(this, t, e),
                      null !== t.background &&
                        (this.background = t.background.clone()),
                      null !== t.environment &&
                        (this.environment = t.environment.clone()),
                      null !== t.fog && (this.fog = t.fog.clone()),
                      null !== t.overrideMaterial &&
                        (this.overrideMaterial = t.overrideMaterial.clone()),
                      (this.autoUpdate = t.autoUpdate),
                      (this.matrixAutoUpdate = t.matrixAutoUpdate),
                      this
                    )
                  },
                  toJSON: function (t) {
                    var e = On.prototype.toJSON.call(this, t)
                    return (
                      null !== this.background &&
                        (e.object.background = this.background.toJSON(t)),
                      null !== this.environment &&
                        (e.object.environment = this.environment.toJSON(t)),
                      null !== this.fog && (e.object.fog = this.fog.toJSON()),
                      e
                    )
                  },
                  dispose: function () {
                    this.dispatchEvent({ type: 'dispose' })
                  },
                }))
              var Dn = [
                  new on(),
                  new on(),
                  new on(),
                  new on(),
                  new on(),
                  new on(),
                  new on(),
                  new on(),
                ],
                Bn = new on(),
                Nn = new Xn(),
                Un = new on(),
                zn = new on(),
                Fn = new on(),
                Hn = new on(),
                Gn = new on(),
                kn = new on(),
                Vn = new on(),
                jn = new on(),
                Wn = new on(),
                qn = new on()
              function Xn(t, e) {
                ;(this.min = void 0 !== t ? t : new on(1 / 0, 1 / 0, 1 / 0)),
                  (this.max = void 0 !== e ? e : new on(-1 / 0, -1 / 0, -1 / 0))
              }
              function Yn(t, e, n, r, i) {
                for (var a = 0, o = t.length - 3; a <= o; a += 3) {
                  qn.fromArray(t, a)
                  var s =
                      i.x * Math.abs(qn.x) +
                      i.y * Math.abs(qn.y) +
                      i.z * Math.abs(qn.z),
                    c = e.dot(qn),
                    l = n.dot(qn),
                    h = r.dot(qn)
                  if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > s)
                    return !1
                }
                return !0
              }
              Object.assign(Xn.prototype, {
                isBox3: !0,
                set: function (t, e) {
                  return this.min.copy(t), this.max.copy(e), this
                },
                setFromArray: function (t) {
                  for (
                    var e = 1 / 0,
                      n = 1 / 0,
                      r = 1 / 0,
                      i = -1 / 0,
                      a = -1 / 0,
                      o = -1 / 0,
                      s = 0,
                      c = t.length;
                    s < c;
                    s += 3
                  ) {
                    var l = t[s],
                      h = t[s + 1],
                      u = t[s + 2]
                    l < e && (e = l),
                      h < n && (n = h),
                      u < r && (r = u),
                      i < l && (i = l),
                      a < h && (a = h),
                      o < u && (o = u)
                  }
                  return this.min.set(e, n, r), this.max.set(i, a, o), this
                },
                setFromBufferAttribute: function (t) {
                  for (
                    var e = 1 / 0,
                      n = 1 / 0,
                      r = 1 / 0,
                      i = -1 / 0,
                      a = -1 / 0,
                      o = -1 / 0,
                      s = 0,
                      c = t.count;
                    s < c;
                    s++
                  ) {
                    var l = t.getX(s),
                      h = t.getY(s),
                      u = t.getZ(s)
                    l < e && (e = l),
                      h < n && (n = h),
                      u < r && (r = u),
                      i < l && (i = l),
                      a < h && (a = h),
                      o < u && (o = u)
                  }
                  return this.min.set(e, n, r), this.max.set(i, a, o), this
                },
                setFromPoints: function (t) {
                  this.makeEmpty()
                  for (var e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e])
                  return this
                },
                setFromCenterAndSize: function (t, e) {
                  var n = Bn.copy(e).multiplyScalar(0.5)
                  return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                },
                setFromObject: function (t) {
                  return this.makeEmpty(), this.expandByObject(t)
                },
                clone: function () {
                  return new this.constructor().copy(this)
                },
                copy: function (t) {
                  return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function () {
                  return (
                    (this.min.x = this.min.y = this.min.z = 1 / 0),
                    (this.max.x = this.max.y = this.max.z = -1 / 0),
                    this
                  )
                },
                isEmpty: function () {
                  return (
                    this.max.x < this.min.x ||
                    this.max.y < this.min.y ||
                    this.max.z < this.min.z
                  )
                },
                getCenter: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        'THREE.Box3: .getCenter() target is now required',
                      ),
                      (t = new on())),
                    this.isEmpty()
                      ? t.set(0, 0, 0)
                      : t.addVectors(this.min, this.max).multiplyScalar(0.5)
                  )
                },
                getSize: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        'THREE.Box3: .getSize() target is now required',
                      ),
                      (t = new on())),
                    this.isEmpty()
                      ? t.set(0, 0, 0)
                      : t.subVectors(this.max, this.min)
                  )
                },
                expandByPoint: function (t) {
                  return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function (t) {
                  return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function (t) {
                  return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                expandByObject: function (t) {
                  t.updateWorldMatrix(!1, !1)
                  var e = t.geometry
                  void 0 !== e &&
                    (null === e.boundingBox && e.computeBoundingBox(),
                    Nn.copy(e.boundingBox),
                    Nn.applyMatrix4(t.matrixWorld),
                    this.union(Nn))
                  for (var n = t.children, r = 0, i = n.length; r < i; r++)
                    this.expandByObject(n[r])
                  return this
                },
                containsPoint: function (t) {
                  return !(
                    t.x < this.min.x ||
                    t.x > this.max.x ||
                    t.y < this.min.y ||
                    t.y > this.max.y ||
                    t.z < this.min.z ||
                    t.z > this.max.z
                  )
                },
                containsBox: function (t) {
                  return (
                    this.min.x <= t.min.x &&
                    t.max.x <= this.max.x &&
                    this.min.y <= t.min.y &&
                    t.max.y <= this.max.y &&
                    this.min.z <= t.min.z &&
                    t.max.z <= this.max.z
                  )
                },
                getParameter: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        'THREE.Box3: .getParameter() target is now required',
                      ),
                      (e = new on())),
                    e.set(
                      (t.x - this.min.x) / (this.max.x - this.min.x),
                      (t.y - this.min.y) / (this.max.y - this.min.y),
                      (t.z - this.min.z) / (this.max.z - this.min.z),
                    )
                  )
                },
                intersectsBox: function (t) {
                  return !(
                    t.max.x < this.min.x ||
                    t.min.x > this.max.x ||
                    t.max.y < this.min.y ||
                    t.min.y > this.max.y ||
                    t.max.z < this.min.z ||
                    t.min.z > this.max.z
                  )
                },
                intersectsSphere: function (t) {
                  return (
                    this.clampPoint(t.center, Bn),
                    Bn.distanceToSquared(t.center) <= t.radius * t.radius
                  )
                },
                intersectsPlane: function (t) {
                  var e,
                    n =
                      0 < t.normal.x
                        ? ((e = t.normal.x * this.min.x),
                          t.normal.x * this.max.x)
                        : ((e = t.normal.x * this.max.x),
                          t.normal.x * this.min.x)
                  return (
                    0 < t.normal.y
                      ? ((e += t.normal.y * this.min.y),
                        (n += t.normal.y * this.max.y))
                      : ((e += t.normal.y * this.max.y),
                        (n += t.normal.y * this.min.y)),
                    0 < t.normal.z
                      ? ((e += t.normal.z * this.min.z),
                        (n += t.normal.z * this.max.z))
                      : ((e += t.normal.z * this.max.z),
                        (n += t.normal.z * this.min.z)),
                    e <= -t.constant && n >= -t.constant
                  )
                },
                intersectsTriangle: function (t) {
                  if (this.isEmpty()) return !1
                  this.getCenter(Vn),
                    jn.subVectors(this.max, Vn),
                    Un.subVectors(t.a, Vn),
                    zn.subVectors(t.b, Vn),
                    Fn.subVectors(t.c, Vn),
                    Hn.subVectors(zn, Un),
                    Gn.subVectors(Fn, zn),
                    kn.subVectors(Un, Fn)
                  var e = [
                    0,
                    -Hn.z,
                    Hn.y,
                    0,
                    -Gn.z,
                    Gn.y,
                    0,
                    -kn.z,
                    kn.y,
                    Hn.z,
                    0,
                    -Hn.x,
                    Gn.z,
                    0,
                    -Gn.x,
                    kn.z,
                    0,
                    -kn.x,
                    -Hn.y,
                    Hn.x,
                    0,
                    -Gn.y,
                    Gn.x,
                    0,
                    -kn.y,
                    kn.x,
                    0,
                  ]
                  return (
                    !!Yn(e, Un, zn, Fn, jn) &&
                    !!Yn([1, 0, 0, 0, 1, 0, 0, 0, 1], Un, zn, Fn, jn) &&
                    (Wn.crossVectors(Hn, Gn),
                    Yn([Wn.x, Wn.y, Wn.z], Un, zn, Fn, jn))
                  )
                },
                clampPoint: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        'THREE.Box3: .clampPoint() target is now required',
                      ),
                      (e = new on())),
                    e.copy(t).clamp(this.min, this.max)
                  )
                },
                distanceToPoint: function (t) {
                  return Bn.copy(t).clamp(this.min, this.max).sub(t).length()
                },
                getBoundingSphere: function (t) {
                  return (
                    void 0 === t &&
                      console.error(
                        'THREE.Box3: .getBoundingSphere() target is now required',
                      ),
                    this.getCenter(t.center),
                    (t.radius = 0.5 * this.getSize(Bn).length()),
                    t
                  )
                },
                intersect: function (t) {
                  return (
                    this.min.max(t.min),
                    this.max.min(t.max),
                    this.isEmpty() && this.makeEmpty(),
                    this
                  )
                },
                union: function (t) {
                  return this.min.min(t.min), this.max.max(t.max), this
                },
                applyMatrix4: function (t) {
                  return (
                    this.isEmpty() ||
                      (Dn[0]
                        .set(this.min.x, this.min.y, this.min.z)
                        .applyMatrix4(t),
                      Dn[1]
                        .set(this.min.x, this.min.y, this.max.z)
                        .applyMatrix4(t),
                      Dn[2]
                        .set(this.min.x, this.max.y, this.min.z)
                        .applyMatrix4(t),
                      Dn[3]
                        .set(this.min.x, this.max.y, this.max.z)
                        .applyMatrix4(t),
                      Dn[4]
                        .set(this.max.x, this.min.y, this.min.z)
                        .applyMatrix4(t),
                      Dn[5]
                        .set(this.max.x, this.min.y, this.max.z)
                        .applyMatrix4(t),
                      Dn[6]
                        .set(this.max.x, this.max.y, this.min.z)
                        .applyMatrix4(t),
                      Dn[7]
                        .set(this.max.x, this.max.y, this.max.z)
                        .applyMatrix4(t),
                      this.setFromPoints(Dn)),
                    this
                  )
                },
                translate: function (t) {
                  return this.min.add(t), this.max.add(t), this
                },
                equals: function (t) {
                  return t.min.equals(this.min) && t.max.equals(this.max)
                },
              })
              var Zn = new Xn()
              function Jn(t, e) {
                ;(this.center = void 0 !== t ? t : new on()),
                  (this.radius = void 0 !== e ? e : -1)
              }
              Object.assign(Jn.prototype, {
                set: function (t, e) {
                  return this.center.copy(t), (this.radius = e), this
                },
                setFromPoints: function (t, e) {
                  var n = this.center
                  void 0 !== e ? n.copy(e) : Zn.setFromPoints(t).getCenter(n)
                  for (var r = 0, i = 0, a = t.length; i < a; i++)
                    r = Math.max(r, n.distanceToSquared(t[i]))
                  return (this.radius = Math.sqrt(r)), this
                },
                clone: function () {
                  return new this.constructor().copy(this)
                },
                copy: function (t) {
                  return (
                    this.center.copy(t.center), (this.radius = t.radius), this
                  )
                },
                isEmpty: function () {
                  return this.radius < 0
                },
                makeEmpty: function () {
                  return this.center.set(0, 0, 0), (this.radius = -1), this
                },
                containsPoint: function (t) {
                  return (
                    t.distanceToSquared(this.center) <=
                    this.radius * this.radius
                  )
                },
                distanceToPoint: function (t) {
                  return t.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function (t) {
                  var e = this.radius + t.radius
                  return t.center.distanceToSquared(this.center) <= e * e
                },
                intersectsBox: function (t) {
                  return t.intersectsSphere(this)
                },
                intersectsPlane: function (t) {
                  return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function (t, e) {
                  var n = this.center.distanceToSquared(t)
                  return (
                    void 0 === e &&
                      (console.warn(
                        'THREE.Sphere: .clampPoint() target is now required',
                      ),
                      (e = new on())),
                    e.copy(t),
                    n > this.radius * this.radius &&
                      (e.sub(this.center).normalize(),
                      e.multiplyScalar(this.radius).add(this.center)),
                    e
                  )
                },
                getBoundingBox: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        'THREE.Sphere: .getBoundingBox() target is now required',
                      ),
                      (t = new Xn())),
                    this.isEmpty()
                      ? t.makeEmpty()
                      : (t.set(this.center, this.center),
                        t.expandByScalar(this.radius)),
                    t
                  )
                },
                applyMatrix4: function (t) {
                  return (
                    this.center.applyMatrix4(t),
                    (this.radius = this.radius * t.getMaxScaleOnAxis()),
                    this
                  )
                },
                translate: function (t) {
                  return this.center.add(t), this
                },
                equals: function (t) {
                  return (
                    t.center.equals(this.center) && t.radius === this.radius
                  )
                },
              })
              var Qn = new on(),
                Kn = new on(),
                $n = new on(),
                tr = new on(),
                er = new on(),
                nr = new on(),
                rr = new on()
              function ir(t, e) {
                ;(this.origin = void 0 !== t ? t : new on()),
                  (this.direction = void 0 !== e ? e : new on(0, 0, -1))
              }
              Object.assign(ir.prototype, {
                set: function (t, e) {
                  return this.origin.copy(t), this.direction.copy(e), this
                },
                clone: function () {
                  return new this.constructor().copy(this)
                },
                copy: function (t) {
                  return (
                    this.origin.copy(t.origin),
                    this.direction.copy(t.direction),
                    this
                  )
                },
                at: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn('THREE.Ray: .at() target is now required'),
                      (e = new on())),
                    e.copy(this.direction).multiplyScalar(t).add(this.origin)
                  )
                },
                lookAt: function (t) {
                  return (
                    this.direction.copy(t).sub(this.origin).normalize(), this
                  )
                },
                recast: function (t) {
                  return this.origin.copy(this.at(t, Qn)), this
                },
                closestPointToPoint: function (t, e) {
                  void 0 === e &&
                    (console.warn(
                      'THREE.Ray: .closestPointToPoint() target is now required',
                    ),
                    (e = new on())),
                    e.subVectors(t, this.origin)
                  var n = e.dot(this.direction)
                  return n < 0
                    ? e.copy(this.origin)
                    : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                },
                distanceToPoint: function (t) {
                  return Math.sqrt(this.distanceSqToPoint(t))
                },
                distanceSqToPoint: function (t) {
                  var e = Qn.subVectors(t, this.origin).dot(this.direction)
                  return e < 0
                    ? this.origin.distanceToSquared(t)
                    : (Qn.copy(this.direction)
                        .multiplyScalar(e)
                        .add(this.origin),
                      Qn.distanceToSquared(t))
                },
                distanceSqToSegment: function (t, e, n, r) {
                  Kn.copy(t).add(e).multiplyScalar(0.5),
                    $n.copy(e).sub(t).normalize(),
                    tr.copy(this.origin).sub(Kn)
                  var i,
                    a,
                    o,
                    s,
                    c,
                    l = 0.5 * t.distanceTo(e),
                    h = -this.direction.dot($n),
                    u = tr.dot(this.direction),
                    p = -tr.dot($n),
                    d = tr.lengthSq(),
                    f = Math.abs(1 - h * h)
                  return (
                    (a =
                      0 < f
                        ? ((s = h * u - p),
                          (c = l * f),
                          0 <= (o = h * p - u)
                            ? -c <= s
                              ? s <= c
                                ? (o *= i = 1 / f) *
                                    (o + h * (s *= i) + 2 * u) +
                                  s * (h * o + s + 2 * p) +
                                  d
                                : ((s = l),
                                  -(o = Math.max(0, -(h * s + u))) * o +
                                    s * (s + 2 * p) +
                                    d)
                              : ((s = -l),
                                -(o = Math.max(0, -(h * s + u))) * o +
                                  s * (s + 2 * p) +
                                  d)
                            : s <= -c
                              ? -(o = Math.max(0, -(-h * l + u))) * o +
                                (s =
                                  0 < o ? -l : Math.min(Math.max(-l, -p), l)) *
                                  (s + 2 * p) +
                                d
                              : s <= c
                                ? ((o = 0),
                                  (s = Math.min(Math.max(-l, -p), l)) *
                                    (s + 2 * p) +
                                    d)
                                : -(o = Math.max(0, -(h * l + u))) * o +
                                  (s =
                                    0 < o ? l : Math.min(Math.max(-l, -p), l)) *
                                    (s + 2 * p) +
                                  d)
                        : ((s = 0 < h ? -l : l),
                          -(o = Math.max(0, -(h * s + u))) * o +
                            s * (s + 2 * p) +
                            d)),
                    n &&
                      n.copy(this.direction).multiplyScalar(o).add(this.origin),
                    r && r.copy($n).multiplyScalar(s).add(Kn),
                    a
                  )
                },
                intersectSphere: function (t, e) {
                  Qn.subVectors(t.center, this.origin)
                  var n = Qn.dot(this.direction),
                    r = Qn.dot(Qn) - n * n,
                    i = t.radius * t.radius
                  if (i < r) return null
                  var a = Math.sqrt(i - r),
                    o = n - a,
                    s = n + a
                  return o < 0 && s < 0
                    ? null
                    : o < 0
                      ? this.at(s, e)
                      : this.at(o, e)
                },
                intersectsSphere: function (t) {
                  return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                },
                distanceToPlane: function (t) {
                  var e = t.normal.dot(this.direction)
                  if (0 === e)
                    return 0 === t.distanceToPoint(this.origin) ? 0 : null
                  var n = -(this.origin.dot(t.normal) + t.constant) / e
                  return 0 <= n ? n : null
                },
                intersectPlane: function (t, e) {
                  var n = this.distanceToPlane(t)
                  return null === n ? null : this.at(n, e)
                },
                intersectsPlane: function (t) {
                  var e = t.distanceToPoint(this.origin)
                  return 0 === e || t.normal.dot(this.direction) * e < 0
                },
                intersectBox: function (t, e) {
                  var n,
                    r,
                    i,
                    a,
                    o = 1 / this.direction.x,
                    s = 1 / this.direction.y,
                    c = 1 / this.direction.z,
                    l = this.origin,
                    h =
                      0 <= o
                        ? ((n = (t.min.x - l.x) * o), (t.max.x - l.x) * o)
                        : ((n = (t.max.x - l.x) * o), (t.min.x - l.x) * o),
                    u =
                      0 <= s
                        ? ((r = (t.min.y - l.y) * s), (t.max.y - l.y) * s)
                        : ((r = (t.max.y - l.y) * s), (t.min.y - l.y) * s)
                  return u < n || h < r
                    ? null
                    : ((n < r || n != n) && (n = r),
                      (u < h || h != h) && (h = u),
                      (a =
                        0 <= c
                          ? ((i = (t.min.z - l.z) * c), (t.max.z - l.z) * c)
                          : ((i = (t.max.z - l.z) * c), (t.min.z - l.z) * c)) <
                        n || h < i
                        ? null
                        : ((n < i || n != n) && (n = i),
                          (a < h || h != h) && (h = a),
                          h < 0 ? null : this.at(0 <= n ? n : h, e)))
                },
                intersectsBox: function (t) {
                  return null !== this.intersectBox(t, Qn)
                },
                intersectTriangle: function (t, e, n, r, i) {
                  er.subVectors(e, t),
                    nr.subVectors(n, t),
                    rr.crossVectors(er, nr)
                  var a,
                    o = this.direction.dot(rr)
                  if (0 < o) {
                    if (r) return null
                    a = 1
                  } else {
                    if (!(o < 0)) return null
                    ;(a = -1), (o = -o)
                  }
                  tr.subVectors(this.origin, t)
                  var s = a * this.direction.dot(nr.crossVectors(tr, nr))
                  if (s < 0) return null
                  var c = a * this.direction.dot(er.cross(tr))
                  if (c < 0) return null
                  if (o < s + c) return null
                  var l = -a * tr.dot(rr)
                  return l < 0 ? null : this.at(l / o, i)
                },
                applyMatrix4: function (t) {
                  return (
                    this.origin.applyMatrix4(t),
                    this.direction.transformDirection(t),
                    this
                  )
                },
                equals: function (t) {
                  return (
                    t.origin.equals(this.origin) &&
                    t.direction.equals(this.direction)
                  )
                },
              })
              var ar = new on(),
                or = new on(),
                sr = new Ze()
              function cr(t, e) {
                ;(this.normal = void 0 !== t ? t : new on(1, 0, 0)),
                  (this.constant = void 0 !== e ? e : 0)
              }
              Object.assign(cr.prototype, {
                isPlane: !0,
                set: function (t, e) {
                  return this.normal.copy(t), (this.constant = e), this
                },
                setComponents: function (t, e, n, r) {
                  return this.normal.set(t, e, n), (this.constant = r), this
                },
                setFromNormalAndCoplanarPoint: function (t, e) {
                  return (
                    this.normal.copy(t),
                    (this.constant = -e.dot(this.normal)),
                    this
                  )
                },
                setFromCoplanarPoints: function (t, e, n) {
                  var r = ar
                    .subVectors(n, e)
                    .cross(or.subVectors(t, e))
                    .normalize()
                  return this.setFromNormalAndCoplanarPoint(r, t), this
                },
                clone: function () {
                  return new this.constructor().copy(this)
                },
                copy: function (t) {
                  return (
                    this.normal.copy(t.normal),
                    (this.constant = t.constant),
                    this
                  )
                },
                normalize: function () {
                  var t = 1 / this.normal.length()
                  return (
                    this.normal.multiplyScalar(t), (this.constant *= t), this
                  )
                },
                negate: function () {
                  return (this.constant *= -1), this.normal.negate(), this
                },
                distanceToPoint: function (t) {
                  return this.normal.dot(t) + this.constant
                },
                distanceToSphere: function (t) {
                  return this.distanceToPoint(t.center) - t.radius
                },
                projectPoint: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        'THREE.Plane: .projectPoint() target is now required',
                      ),
                      (e = new on())),
                    e
                      .copy(this.normal)
                      .multiplyScalar(-this.distanceToPoint(t))
                      .add(t)
                  )
                },
                intersectLine: function (t, e) {
                  void 0 === e &&
                    (console.warn(
                      'THREE.Plane: .intersectLine() target is now required',
                    ),
                    (e = new on()))
                  var n = t.delta(ar),
                    r = this.normal.dot(n)
                  if (0 === r)
                    return 0 === this.distanceToPoint(t.start)
                      ? e.copy(t.start)
                      : void 0
                  var i = -(t.start.dot(this.normal) + this.constant) / r
                  return i < 0 || 1 < i
                    ? void 0
                    : e.copy(n).multiplyScalar(i).add(t.start)
                },
                intersectsLine: function (t) {
                  var e = this.distanceToPoint(t.start),
                    n = this.distanceToPoint(t.end)
                  return (e < 0 && 0 < n) || (n < 0 && 0 < e)
                },
                intersectsBox: function (t) {
                  return t.intersectsPlane(this)
                },
                intersectsSphere: function (t) {
                  return t.intersectsPlane(this)
                },
                coplanarPoint: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        'THREE.Plane: .coplanarPoint() target is now required',
                      ),
                      (t = new on())),
                    t.copy(this.normal).multiplyScalar(-this.constant)
                  )
                },
                applyMatrix4: function (t, e) {
                  var n = e || sr.getNormalMatrix(t),
                    r = this.coplanarPoint(ar).applyMatrix4(t),
                    i = this.normal.applyMatrix3(n).normalize()
                  return (this.constant = -r.dot(i)), this
                },
                translate: function (t) {
                  return (this.constant -= t.dot(this.normal)), this
                },
                equals: function (t) {
                  return (
                    t.normal.equals(this.normal) && t.constant === this.constant
                  )
                },
              })
              var lr = new on(),
                hr = new on(),
                ur = new on(),
                pr = new on(),
                dr = new on(),
                fr = new on(),
                mr = new on(),
                vr = new on(),
                gr = new on(),
                yr = new on()
              function xr(t, e, n) {
                ;(this.a = void 0 !== t ? t : new on()),
                  (this.b = void 0 !== e ? e : new on()),
                  (this.c = void 0 !== n ? n : new on())
              }
              Object.assign(xr, {
                getNormal: function (t, e, n, r) {
                  void 0 === r &&
                    (console.warn(
                      'THREE.Triangle: .getNormal() target is now required',
                    ),
                    (r = new on())),
                    r.subVectors(n, e),
                    lr.subVectors(t, e),
                    r.cross(lr)
                  var i = r.lengthSq()
                  return 0 < i
                    ? r.multiplyScalar(1 / Math.sqrt(i))
                    : r.set(0, 0, 0)
                },
                getBarycoord: function (t, e, n, r, i) {
                  lr.subVectors(r, e), hr.subVectors(n, e), ur.subVectors(t, e)
                  var a = lr.dot(lr),
                    o = lr.dot(hr),
                    s = lr.dot(ur),
                    c = hr.dot(hr),
                    l = hr.dot(ur),
                    h = a * c - o * o
                  if (
                    (void 0 === i &&
                      (console.warn(
                        'THREE.Triangle: .getBarycoord() target is now required',
                      ),
                      (i = new on())),
                    0 == h)
                  )
                    return i.set(-2, -1, -1)
                  var u = 1 / h,
                    p = (c * s - o * l) * u,
                    d = (a * l - o * s) * u
                  return i.set(1 - p - d, d, p)
                },
                containsPoint: function (t, e, n, r) {
                  return (
                    xr.getBarycoord(t, e, n, r, pr),
                    0 <= pr.x && 0 <= pr.y && pr.x + pr.y <= 1
                  )
                },
                getUV: function (t, e, n, r, i, a, o, s) {
                  return (
                    this.getBarycoord(t, e, n, r, pr),
                    s.set(0, 0),
                    s.addScaledVector(i, pr.x),
                    s.addScaledVector(a, pr.y),
                    s.addScaledVector(o, pr.z),
                    s
                  )
                },
                isFrontFacing: function (t, e, n, r) {
                  return (
                    lr.subVectors(n, e),
                    hr.subVectors(t, e),
                    lr.cross(hr).dot(r) < 0
                  )
                },
              }),
                Object.assign(xr.prototype, {
                  set: function (t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                  },
                  setFromPointsAndIndices: function (t, e, n, r) {
                    return (
                      this.a.copy(t[e]),
                      this.b.copy(t[n]),
                      this.c.copy(t[r]),
                      this
                    )
                  },
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                  copy: function (t) {
                    return (
                      this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                    )
                  },
                  getArea: function () {
                    return (
                      lr.subVectors(this.c, this.b),
                      hr.subVectors(this.a, this.b),
                      0.5 * lr.cross(hr).length()
                    )
                  },
                  getMidpoint: function (t) {
                    return (
                      void 0 === t &&
                        (console.warn(
                          'THREE.Triangle: .getMidpoint() target is now required',
                        ),
                        (t = new on())),
                      t
                        .addVectors(this.a, this.b)
                        .add(this.c)
                        .multiplyScalar(1 / 3)
                    )
                  },
                  getNormal: function (t) {
                    return xr.getNormal(this.a, this.b, this.c, t)
                  },
                  getPlane: function (t) {
                    return (
                      void 0 === t &&
                        (console.warn(
                          'THREE.Triangle: .getPlane() target is now required',
                        ),
                        (t = new cr())),
                      t.setFromCoplanarPoints(this.a, this.b, this.c)
                    )
                  },
                  getBarycoord: function (t, e) {
                    return xr.getBarycoord(t, this.a, this.b, this.c, e)
                  },
                  getUV: function (t, e, n, r, i) {
                    return xr.getUV(t, this.a, this.b, this.c, e, n, r, i)
                  },
                  containsPoint: function (t) {
                    return xr.containsPoint(t, this.a, this.b, this.c)
                  },
                  isFrontFacing: function (t) {
                    return xr.isFrontFacing(this.a, this.b, this.c, t)
                  },
                  intersectsBox: function (t) {
                    return t.intersectsTriangle(this)
                  },
                  closestPointToPoint: function (t, e) {
                    void 0 === e &&
                      (console.warn(
                        'THREE.Triangle: .closestPointToPoint() target is now required',
                      ),
                      (e = new on()))
                    var n = this.a,
                      r = this.b,
                      i = this.c
                    dr.subVectors(r, n),
                      fr.subVectors(i, n),
                      vr.subVectors(t, n)
                    var a = dr.dot(vr),
                      o = fr.dot(vr)
                    if (a <= 0 && o <= 0) return e.copy(n)
                    gr.subVectors(t, r)
                    var s = dr.dot(gr),
                      c = fr.dot(gr)
                    if (0 <= s && c <= s) return e.copy(r)
                    var l = a * c - s * o
                    if (l <= 0 && 0 <= a && s <= 0)
                      return (m = a / (a - s)), e.copy(n).addScaledVector(dr, m)
                    yr.subVectors(t, i)
                    var h = dr.dot(yr),
                      u = fr.dot(yr)
                    if (0 <= u && h <= u) return e.copy(i)
                    var p = h * o - a * u
                    if (p <= 0 && 0 <= o && u <= 0)
                      return (v = o / (o - u)), e.copy(n).addScaledVector(fr, v)
                    var d = s * u - h * c
                    if (d <= 0 && 0 <= c - s && 0 <= h - u)
                      return (
                        mr.subVectors(i, r),
                        (v = (c - s) / (c - s + (h - u))),
                        e.copy(r).addScaledVector(mr, v)
                      )
                    var f = 1 / (d + p + l),
                      m = p * f,
                      v = l * f
                    return e
                      .copy(n)
                      .addScaledVector(dr, m)
                      .addScaledVector(fr, v)
                  },
                  equals: function (t) {
                    return (
                      t.a.equals(this.a) &&
                      t.b.equals(this.b) &&
                      t.c.equals(this.c)
                    )
                  },
                })
              var br = {
                  aliceblue: 15792383,
                  antiquewhite: 16444375,
                  aqua: 65535,
                  aquamarine: 8388564,
                  azure: 15794175,
                  beige: 16119260,
                  bisque: 16770244,
                  black: 0,
                  blanchedalmond: 16772045,
                  blue: 255,
                  blueviolet: 9055202,
                  brown: 10824234,
                  burlywood: 14596231,
                  cadetblue: 6266528,
                  chartreuse: 8388352,
                  chocolate: 13789470,
                  coral: 16744272,
                  cornflowerblue: 6591981,
                  cornsilk: 16775388,
                  crimson: 14423100,
                  cyan: 65535,
                  darkblue: 139,
                  darkcyan: 35723,
                  darkgoldenrod: 12092939,
                  darkgray: 11119017,
                  darkgreen: 25600,
                  darkgrey: 11119017,
                  darkkhaki: 12433259,
                  darkmagenta: 9109643,
                  darkolivegreen: 5597999,
                  darkorange: 16747520,
                  darkorchid: 10040012,
                  darkred: 9109504,
                  darksalmon: 15308410,
                  darkseagreen: 9419919,
                  darkslateblue: 4734347,
                  darkslategray: 3100495,
                  darkslategrey: 3100495,
                  darkturquoise: 52945,
                  darkviolet: 9699539,
                  deeppink: 16716947,
                  deepskyblue: 49151,
                  dimgray: 6908265,
                  dimgrey: 6908265,
                  dodgerblue: 2003199,
                  firebrick: 11674146,
                  floralwhite: 16775920,
                  forestgreen: 2263842,
                  fuchsia: 16711935,
                  gainsboro: 14474460,
                  ghostwhite: 16316671,
                  gold: 16766720,
                  goldenrod: 14329120,
                  gray: 8421504,
                  green: 32768,
                  greenyellow: 11403055,
                  grey: 8421504,
                  honeydew: 15794160,
                  hotpink: 16738740,
                  indianred: 13458524,
                  indigo: 4915330,
                  ivory: 16777200,
                  khaki: 15787660,
                  lavender: 15132410,
                  lavenderblush: 16773365,
                  lawngreen: 8190976,
                  lemonchiffon: 16775885,
                  lightblue: 11393254,
                  lightcoral: 15761536,
                  lightcyan: 14745599,
                  lightgoldenrodyellow: 16448210,
                  lightgray: 13882323,
                  lightgreen: 9498256,
                  lightgrey: 13882323,
                  lightpink: 16758465,
                  lightsalmon: 16752762,
                  lightseagreen: 2142890,
                  lightskyblue: 8900346,
                  lightslategray: 7833753,
                  lightslategrey: 7833753,
                  lightsteelblue: 11584734,
                  lightyellow: 16777184,
                  lime: 65280,
                  limegreen: 3329330,
                  linen: 16445670,
                  magenta: 16711935,
                  maroon: 8388608,
                  mediumaquamarine: 6737322,
                  mediumblue: 205,
                  mediumorchid: 12211667,
                  mediumpurple: 9662683,
                  mediumseagreen: 3978097,
                  mediumslateblue: 8087790,
                  mediumspringgreen: 64154,
                  mediumturquoise: 4772300,
                  mediumvioletred: 13047173,
                  midnightblue: 1644912,
                  mintcream: 16121850,
                  mistyrose: 16770273,
                  moccasin: 16770229,
                  navajowhite: 16768685,
                  navy: 128,
                  oldlace: 16643558,
                  olive: 8421376,
                  olivedrab: 7048739,
                  orange: 16753920,
                  orangered: 16729344,
                  orchid: 14315734,
                  palegoldenrod: 15657130,
                  palegreen: 10025880,
                  paleturquoise: 11529966,
                  palevioletred: 14381203,
                  papayawhip: 16773077,
                  peachpuff: 16767673,
                  peru: 13468991,
                  pink: 16761035,
                  plum: 14524637,
                  powderblue: 11591910,
                  purple: 8388736,
                  rebeccapurple: 6697881,
                  red: 16711680,
                  rosybrown: 12357519,
                  royalblue: 4286945,
                  saddlebrown: 9127187,
                  salmon: 16416882,
                  sandybrown: 16032864,
                  seagreen: 3050327,
                  seashell: 16774638,
                  sienna: 10506797,
                  silver: 12632256,
                  skyblue: 8900331,
                  slateblue: 6970061,
                  slategray: 7372944,
                  slategrey: 7372944,
                  snow: 16775930,
                  springgreen: 65407,
                  steelblue: 4620980,
                  tan: 13808780,
                  teal: 32896,
                  thistle: 14204888,
                  tomato: 16737095,
                  turquoise: 4251856,
                  violet: 15631086,
                  wheat: 16113331,
                  white: 16777215,
                  whitesmoke: 16119285,
                  yellow: 16776960,
                  yellowgreen: 10145074,
                },
                _r = { h: 0, s: 0, l: 0 },
                wr = { h: 0, s: 0, l: 0 }
              function Mr(t, e, n) {
                return void 0 === e && void 0 === n
                  ? this.set(t)
                  : this.setRGB(t, e, n)
              }
              function Sr(t, e, n) {
                return (
                  n < 0 && (n += 1),
                  1 < n && --n,
                  n < 1 / 6
                    ? t + 6 * (e - t) * n
                    : n < 0.5
                      ? e
                      : n < 2 / 3
                        ? t + 6 * (e - t) * (2 / 3 - n)
                        : t
                )
              }
              function Er(t) {
                return t < 0.04045
                  ? 0.0773993808 * t
                  : Math.pow(0.9478672986 * t + 0.0521327014, 2.4)
              }
              function Tr(t) {
                return t < 0.0031308
                  ? 12.92 * t
                  : 1.055 * Math.pow(t, 0.41666) - 0.055
              }
              function Ar(t, e, n, r, i, a) {
                ;(this.a = t),
                  (this.b = e),
                  (this.c = n),
                  (this.normal = r && r.isVector3 ? r : new on()),
                  (this.vertexNormals = Array.isArray(r) ? r : []),
                  (this.color = i && i.isColor ? i : new Mr()),
                  (this.vertexColors = Array.isArray(i) ? i : []),
                  (this.materialIndex = void 0 !== a ? a : 0)
              }
              Object.assign(Mr.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function (t) {
                  return (
                    t && t.isColor
                      ? this.copy(t)
                      : 'number' == typeof t
                        ? this.setHex(t)
                        : 'string' == typeof t && this.setStyle(t),
                    this
                  )
                },
                setScalar: function (t) {
                  return (this.r = t), (this.g = t), (this.b = t), this
                },
                setHex: function (t) {
                  return (
                    (t = Math.floor(t)),
                    (this.r = ((t >> 16) & 255) / 255),
                    (this.g = ((t >> 8) & 255) / 255),
                    (this.b = (255 & t) / 255),
                    this
                  )
                },
                setRGB: function (t, e, n) {
                  return (this.r = t), (this.g = e), (this.b = n), this
                },
                setHSL: function (t, e, n) {
                  var r, i
                  return (
                    (t = Xe.euclideanModulo(t, 1)),
                    (e = Xe.clamp(e, 0, 1)),
                    (n = Xe.clamp(n, 0, 1)),
                    0 === e
                      ? (this.r = this.g = this.b = n)
                      : ((i =
                          2 * n - (r = n <= 0.5 ? n * (1 + e) : n + e - n * e)),
                        (this.r = Sr(i, r, t + 1 / 3)),
                        (this.g = Sr(i, r, t)),
                        (this.b = Sr(i, r, t - 1 / 3))),
                    this
                  )
                },
                setStyle: function (e) {
                  function t(t) {
                    void 0 !== t &&
                      parseFloat(t) < 1 &&
                      console.warn(
                        'THREE.Color: Alpha component of ' +
                          e +
                          ' will be ignored.',
                      )
                  }
                  var n
                  if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e))) {
                    var r,
                      i = n[1],
                      a = n[2]
                    switch (i) {
                      case 'rgb':
                      case 'rgba':
                        if (
                          (r =
                            /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                              a,
                            ))
                        )
                          return (
                            (this.r = Math.min(255, parseInt(r[1], 10)) / 255),
                            (this.g = Math.min(255, parseInt(r[2], 10)) / 255),
                            (this.b = Math.min(255, parseInt(r[3], 10)) / 255),
                            t(r[5]),
                            this
                          )
                        if (
                          (r =
                            /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                              a,
                            ))
                        )
                          return (
                            (this.r = Math.min(100, parseInt(r[1], 10)) / 100),
                            (this.g = Math.min(100, parseInt(r[2], 10)) / 100),
                            (this.b = Math.min(100, parseInt(r[3], 10)) / 100),
                            t(r[5]),
                            this
                          )
                        break
                      case 'hsl':
                      case 'hsla':
                        if (
                          (r =
                            /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                              a,
                            ))
                        ) {
                          var o = parseFloat(r[1]) / 360,
                            s = parseInt(r[2], 10) / 100,
                            c = parseInt(r[3], 10) / 100
                          return t(r[5]), this.setHSL(o, s, c)
                        }
                    }
                  } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(e))) {
                    var l = n[1],
                      h = l.length
                    if (3 === h)
                      return (
                        (this.r =
                          parseInt(l.charAt(0) + l.charAt(0), 16) / 255),
                        (this.g =
                          parseInt(l.charAt(1) + l.charAt(1), 16) / 255),
                        (this.b =
                          parseInt(l.charAt(2) + l.charAt(2), 16) / 255),
                        this
                      )
                    if (6 === h)
                      return (
                        (this.r =
                          parseInt(l.charAt(0) + l.charAt(1), 16) / 255),
                        (this.g =
                          parseInt(l.charAt(2) + l.charAt(3), 16) / 255),
                        (this.b =
                          parseInt(l.charAt(4) + l.charAt(5), 16) / 255),
                        this
                      )
                  }
                  return e && 0 < e.length ? this.setColorName(e) : this
                },
                setColorName: function (t) {
                  var e = br[t]
                  return (
                    void 0 !== e
                      ? this.setHex(e)
                      : console.warn('THREE.Color: Unknown color ' + t),
                    this
                  )
                },
                clone: function () {
                  return new this.constructor(this.r, this.g, this.b)
                },
                copy: function (t) {
                  return (this.r = t.r), (this.g = t.g), (this.b = t.b), this
                },
                copyGammaToLinear: function (t, e) {
                  return (
                    void 0 === e && (e = 2),
                    (this.r = Math.pow(t.r, e)),
                    (this.g = Math.pow(t.g, e)),
                    (this.b = Math.pow(t.b, e)),
                    this
                  )
                },
                copyLinearToGamma: function (t, e) {
                  void 0 === e && (e = 2)
                  var n = 0 < e ? 1 / e : 1
                  return (
                    (this.r = Math.pow(t.r, n)),
                    (this.g = Math.pow(t.g, n)),
                    (this.b = Math.pow(t.b, n)),
                    this
                  )
                },
                convertGammaToLinear: function (t) {
                  return this.copyGammaToLinear(this, t), this
                },
                convertLinearToGamma: function (t) {
                  return this.copyLinearToGamma(this, t), this
                },
                copySRGBToLinear: function (t) {
                  return (
                    (this.r = Er(t.r)),
                    (this.g = Er(t.g)),
                    (this.b = Er(t.b)),
                    this
                  )
                },
                copyLinearToSRGB: function (t) {
                  return (
                    (this.r = Tr(t.r)),
                    (this.g = Tr(t.g)),
                    (this.b = Tr(t.b)),
                    this
                  )
                },
                convertSRGBToLinear: function () {
                  return this.copySRGBToLinear(this), this
                },
                convertLinearToSRGB: function () {
                  return this.copyLinearToSRGB(this), this
                },
                getHex: function () {
                  return (
                    ((255 * this.r) << 16) ^
                    ((255 * this.g) << 8) ^
                    ((255 * this.b) << 0)
                  )
                },
                getHexString: function () {
                  return ('000000' + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function (t) {
                  void 0 === t &&
                    (console.warn(
                      'THREE.Color: .getHSL() target is now required',
                    ),
                    (t = { h: 0, s: 0, l: 0 }))
                  var e,
                    n = this.r,
                    r = this.g,
                    i = this.b,
                    a = Math.max(n, r, i),
                    o = Math.min(n, r, i),
                    s = (o + a) / 2
                  if (o === a) l = e = 0
                  else {
                    var c = a - o,
                      l = s <= 0.5 ? c / (a + o) : c / (2 - a - o)
                    switch (a) {
                      case n:
                        e = (r - i) / c + (r < i ? 6 : 0)
                        break
                      case r:
                        e = (i - n) / c + 2
                        break
                      case i:
                        e = (n - r) / c + 4
                    }
                    e /= 6
                  }
                  return (t.h = e), (t.s = l), (t.l = s), t
                },
                getStyle: function () {
                  return (
                    'rgb(' +
                    ((255 * this.r) | 0) +
                    ',' +
                    ((255 * this.g) | 0) +
                    ',' +
                    ((255 * this.b) | 0) +
                    ')'
                  )
                },
                offsetHSL: function (t, e, n) {
                  return (
                    this.getHSL(_r),
                    (_r.h += t),
                    (_r.s += e),
                    (_r.l += n),
                    this.setHSL(_r.h, _r.s, _r.l),
                    this
                  )
                },
                add: function (t) {
                  return (this.r += t.r), (this.g += t.g), (this.b += t.b), this
                },
                addColors: function (t, e) {
                  return (
                    (this.r = t.r + e.r),
                    (this.g = t.g + e.g),
                    (this.b = t.b + e.b),
                    this
                  )
                },
                addScalar: function (t) {
                  return (this.r += t), (this.g += t), (this.b += t), this
                },
                sub: function (t) {
                  return (
                    (this.r = Math.max(0, this.r - t.r)),
                    (this.g = Math.max(0, this.g - t.g)),
                    (this.b = Math.max(0, this.b - t.b)),
                    this
                  )
                },
                multiply: function (t) {
                  return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this
                },
                multiplyScalar: function (t) {
                  return (this.r *= t), (this.g *= t), (this.b *= t), this
                },
                lerp: function (t, e) {
                  return (
                    (this.r += (t.r - this.r) * e),
                    (this.g += (t.g - this.g) * e),
                    (this.b += (t.b - this.b) * e),
                    this
                  )
                },
                lerpHSL: function (t, e) {
                  this.getHSL(_r), t.getHSL(wr)
                  var n = Xe.lerp(_r.h, wr.h, e),
                    r = Xe.lerp(_r.s, wr.s, e),
                    i = Xe.lerp(_r.l, wr.l, e)
                  return this.setHSL(n, r, i), this
                },
                equals: function (t) {
                  return t.r === this.r && t.g === this.g && t.b === this.b
                },
                fromArray: function (t, e) {
                  return (
                    void 0 === e && (e = 0),
                    (this.r = t[e]),
                    (this.g = t[e + 1]),
                    (this.b = t[e + 2]),
                    this
                  )
                },
                toArray: function (t, e) {
                  return (
                    void 0 === t && (t = []),
                    void 0 === e && (e = 0),
                    (t[e] = this.r),
                    (t[e + 1] = this.g),
                    (t[e + 2] = this.b),
                    t
                  )
                },
                fromBufferAttribute: function (t, e) {
                  return (
                    (this.r = t.getX(e)),
                    (this.g = t.getY(e)),
                    (this.b = t.getZ(e)),
                    !0 === t.normalized &&
                      ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
                    this
                  )
                },
                toJSON: function () {
                  return this.getHex()
                },
              }),
                (Mr.NAMES = br),
                Object.assign(Ar.prototype, {
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                  copy: function (t) {
                    ;(this.a = t.a),
                      (this.b = t.b),
                      (this.c = t.c),
                      this.normal.copy(t.normal),
                      this.color.copy(t.color),
                      (this.materialIndex = t.materialIndex)
                    for (var e = 0, n = t.vertexNormals.length; e < n; e++)
                      this.vertexNormals[e] = t.vertexNormals[e].clone()
                    for (var r = 0, i = t.vertexColors.length; r < i; r++)
                      this.vertexColors[r] = t.vertexColors[r].clone()
                    return this
                  },
                })
              var Lr = 0
              function Rr() {
                Object.defineProperty(this, 'id', { value: Lr++ }),
                  (this.uuid = Xe.generateUUID()),
                  (this.name = ''),
                  (this.type = 'Material'),
                  (this.fog = !0),
                  (this.blending = Z),
                  (this.side = O),
                  (this.flatShading = !1),
                  (this.vertexColors = !1),
                  (this.opacity = 1),
                  (this.transparent = !1),
                  (this.blendSrc = lt),
                  (this.blendDst = ht),
                  (this.blendEquation = tt),
                  (this.blendSrcAlpha = null),
                  (this.blendDstAlpha = null),
                  (this.blendEquationAlpha = null),
                  (this.depthFunc = xt),
                  (this.depthTest = !0),
                  (this.depthWrite = !0),
                  (this.stencilWriteMask = 255),
                  (this.stencilFunc = He),
                  (this.stencilRef = 0),
                  (this.stencilFuncMask = 255),
                  (this.stencilFail = Fe),
                  (this.stencilZFail = Fe),
                  (this.stencilZPass = Fe),
                  (this.stencilWrite = !1),
                  (this.clippingPlanes = null),
                  (this.clipIntersection = !1),
                  (this.clipShadows = !1),
                  (this.shadowSide = null),
                  (this.colorWrite = !0),
                  (this.precision = null),
                  (this.polygonOffset = !1),
                  (this.polygonOffsetFactor = 0),
                  (this.polygonOffsetUnits = 0),
                  (this.dithering = !1),
                  (this.alphaTest = 0),
                  (this.premultipliedAlpha = !1),
                  (this.visible = !0),
                  (this.toneMapped = !0),
                  (this.userData = {}),
                  (this.version = 0)
              }
              function Cr(t) {
                Rr.call(this),
                  (this.type = 'MeshBasicMaterial'),
                  (this.color = new Mr(16777215)),
                  (this.map = null),
                  (this.lightMap = null),
                  (this.lightMapIntensity = 1),
                  (this.aoMap = null),
                  (this.aoMapIntensity = 1),
                  (this.specularMap = null),
                  (this.alphaMap = null),
                  (this.envMap = null),
                  (this.combine = G),
                  (this.reflectivity = 1),
                  (this.refractionRatio = 0.98),
                  (this.wireframe = !1),
                  (this.wireframeLinewidth = 1),
                  (this.wireframeLinecap = 'round'),
                  (this.wireframeLinejoin = 'round'),
                  (this.skinning = !1),
                  (this.morphTargets = !1),
                  this.setValues(t)
              }
              ;(Rr.prototype = Object.assign(Object.create(Ve.prototype), {
                constructor: Rr,
                isMaterial: !0,
                onBeforeCompile: function () {},
                customProgramCacheKey: function () {
                  return this.onBeforeCompile.toString()
                },
                setValues: function (t) {
                  if (void 0 !== t)
                    for (var e in t) {
                      var n,
                        r = t[e]
                      void 0 !== r
                        ? 'shading' !== e
                          ? void 0 !== (n = this[e])
                            ? n && n.isColor
                              ? n.set(r)
                              : n && n.isVector3 && r && r.isVector3
                                ? n.copy(r)
                                : (this[e] = r)
                            : console.warn(
                                'THREE.' +
                                  this.type +
                                  ": '" +
                                  e +
                                  "' is not a property of this material.",
                              )
                          : (console.warn(
                              'THREE.' +
                                this.type +
                                ': .shading has been removed. Use the boolean .flatShading instead.',
                            ),
                            (this.flatShading = 1 === r))
                        : console.warn(
                            "THREE.Material: '" +
                              e +
                              "' parameter is undefined.",
                          )
                    }
                },
                toJSON: function (t) {
                  var e = void 0 === t || 'string' == typeof t
                  e && (t = { textures: {}, images: {} })
                  var n,
                    r,
                    i = {
                      metadata: {
                        version: 4.5,
                        type: 'Material',
                        generator: 'Material.toJSON',
                      },
                    }
                  function a(t) {
                    var e = []
                    for (var n in t) {
                      var r = t[n]
                      delete r.metadata, e.push(r)
                    }
                    return e
                  }
                  return (
                    (i.uuid = this.uuid),
                    (i.type = this.type),
                    '' !== this.name && (i.name = this.name),
                    this.color &&
                      this.color.isColor &&
                      (i.color = this.color.getHex()),
                    void 0 !== this.roughness && (i.roughness = this.roughness),
                    void 0 !== this.metalness && (i.metalness = this.metalness),
                    this.sheen &&
                      this.sheen.isColor &&
                      (i.sheen = this.sheen.getHex()),
                    this.emissive &&
                      this.emissive.isColor &&
                      (i.emissive = this.emissive.getHex()),
                    this.emissiveIntensity &&
                      1 !== this.emissiveIntensity &&
                      (i.emissiveIntensity = this.emissiveIntensity),
                    this.specular &&
                      this.specular.isColor &&
                      (i.specular = this.specular.getHex()),
                    void 0 !== this.shininess && (i.shininess = this.shininess),
                    void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
                    void 0 !== this.clearcoatRoughness &&
                      (i.clearcoatRoughness = this.clearcoatRoughness),
                    this.clearcoatMap &&
                      this.clearcoatMap.isTexture &&
                      (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                    this.clearcoatRoughnessMap &&
                      this.clearcoatRoughnessMap.isTexture &&
                      (i.clearcoatRoughnessMap =
                        this.clearcoatRoughnessMap.toJSON(t).uuid),
                    this.clearcoatNormalMap &&
                      this.clearcoatNormalMap.isTexture &&
                      ((i.clearcoatNormalMap =
                        this.clearcoatNormalMap.toJSON(t).uuid),
                      (i.clearcoatNormalScale =
                        this.clearcoatNormalScale.toArray())),
                    this.map &&
                      this.map.isTexture &&
                      (i.map = this.map.toJSON(t).uuid),
                    this.matcap &&
                      this.matcap.isTexture &&
                      (i.matcap = this.matcap.toJSON(t).uuid),
                    this.alphaMap &&
                      this.alphaMap.isTexture &&
                      (i.alphaMap = this.alphaMap.toJSON(t).uuid),
                    this.lightMap &&
                      this.lightMap.isTexture &&
                      (i.lightMap = this.lightMap.toJSON(t).uuid),
                    this.aoMap &&
                      this.aoMap.isTexture &&
                      ((i.aoMap = this.aoMap.toJSON(t).uuid),
                      (i.aoMapIntensity = this.aoMapIntensity)),
                    this.bumpMap &&
                      this.bumpMap.isTexture &&
                      ((i.bumpMap = this.bumpMap.toJSON(t).uuid),
                      (i.bumpScale = this.bumpScale)),
                    this.normalMap &&
                      this.normalMap.isTexture &&
                      ((i.normalMap = this.normalMap.toJSON(t).uuid),
                      (i.normalMapType = this.normalMapType),
                      (i.normalScale = this.normalScale.toArray())),
                    this.displacementMap &&
                      this.displacementMap.isTexture &&
                      ((i.displacementMap =
                        this.displacementMap.toJSON(t).uuid),
                      (i.displacementScale = this.displacementScale),
                      (i.displacementBias = this.displacementBias)),
                    this.roughnessMap &&
                      this.roughnessMap.isTexture &&
                      (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                    this.metalnessMap &&
                      this.metalnessMap.isTexture &&
                      (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                    this.emissiveMap &&
                      this.emissiveMap.isTexture &&
                      (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                    this.specularMap &&
                      this.specularMap.isTexture &&
                      (i.specularMap = this.specularMap.toJSON(t).uuid),
                    this.envMap &&
                      this.envMap.isTexture &&
                      ((i.envMap = this.envMap.toJSON(t).uuid),
                      (i.reflectivity = this.reflectivity),
                      (i.refractionRatio = this.refractionRatio),
                      void 0 !== this.combine && (i.combine = this.combine),
                      void 0 !== this.envMapIntensity &&
                        (i.envMapIntensity = this.envMapIntensity)),
                    this.gradientMap &&
                      this.gradientMap.isTexture &&
                      (i.gradientMap = this.gradientMap.toJSON(t).uuid),
                    void 0 !== this.size && (i.size = this.size),
                    void 0 !== this.sizeAttenuation &&
                      (i.sizeAttenuation = this.sizeAttenuation),
                    this.blending !== Z && (i.blending = this.blending),
                    !0 === this.flatShading &&
                      (i.flatShading = this.flatShading),
                    this.side !== O && (i.side = this.side),
                    this.vertexColors && (i.vertexColors = !0),
                    this.opacity < 1 && (i.opacity = this.opacity),
                    !0 === this.transparent &&
                      (i.transparent = this.transparent),
                    (i.depthFunc = this.depthFunc),
                    (i.depthTest = this.depthTest),
                    (i.depthWrite = this.depthWrite),
                    (i.stencilWrite = this.stencilWrite),
                    (i.stencilWriteMask = this.stencilWriteMask),
                    (i.stencilFunc = this.stencilFunc),
                    (i.stencilRef = this.stencilRef),
                    (i.stencilFuncMask = this.stencilFuncMask),
                    (i.stencilFail = this.stencilFail),
                    (i.stencilZFail = this.stencilZFail),
                    (i.stencilZPass = this.stencilZPass),
                    this.rotation &&
                      0 !== this.rotation &&
                      (i.rotation = this.rotation),
                    !0 === this.polygonOffset && (i.polygonOffset = !0),
                    0 !== this.polygonOffsetFactor &&
                      (i.polygonOffsetFactor = this.polygonOffsetFactor),
                    0 !== this.polygonOffsetUnits &&
                      (i.polygonOffsetUnits = this.polygonOffsetUnits),
                    this.linewidth &&
                      1 !== this.linewidth &&
                      (i.linewidth = this.linewidth),
                    void 0 !== this.dashSize && (i.dashSize = this.dashSize),
                    void 0 !== this.gapSize && (i.gapSize = this.gapSize),
                    void 0 !== this.scale && (i.scale = this.scale),
                    !0 === this.dithering && (i.dithering = !0),
                    0 < this.alphaTest && (i.alphaTest = this.alphaTest),
                    !0 === this.premultipliedAlpha &&
                      (i.premultipliedAlpha = this.premultipliedAlpha),
                    !0 === this.wireframe && (i.wireframe = this.wireframe),
                    1 < this.wireframeLinewidth &&
                      (i.wireframeLinewidth = this.wireframeLinewidth),
                    'round' !== this.wireframeLinecap &&
                      (i.wireframeLinecap = this.wireframeLinecap),
                    'round' !== this.wireframeLinejoin &&
                      (i.wireframeLinejoin = this.wireframeLinejoin),
                    !0 === this.morphTargets && (i.morphTargets = !0),
                    !0 === this.morphNormals && (i.morphNormals = !0),
                    !0 === this.skinning && (i.skinning = !0),
                    !1 === this.visible && (i.visible = !1),
                    !1 === this.toneMapped && (i.toneMapped = !1),
                    '{}' !== JSON.stringify(this.userData) &&
                      (i.userData = this.userData),
                    e &&
                      ((n = a(t.textures)),
                      (r = a(t.images)),
                      0 < n.length && (i.textures = n),
                      0 < r.length && (i.images = r)),
                    i
                  )
                },
                clone: function () {
                  return new this.constructor().copy(this)
                },
                copy: function (t) {
                  ;(this.name = t.name),
                    (this.fog = t.fog),
                    (this.blending = t.blending),
                    (this.side = t.side),
                    (this.flatShading = t.flatShading),
                    (this.vertexColors = t.vertexColors),
                    (this.opacity = t.opacity),
                    (this.transparent = t.transparent),
                    (this.blendSrc = t.blendSrc),
                    (this.blendDst = t.blendDst),
                    (this.blendEquation = t.blendEquation),
                    (this.blendSrcAlpha = t.blendSrcAlpha),
                    (this.blendDstAlpha = t.blendDstAlpha),
                    (this.blendEquationAlpha = t.blendEquationAlpha),
                    (this.depthFunc = t.depthFunc),
                    (this.depthTest = t.depthTest),
                    (this.depthWrite = t.depthWrite),
                    (this.stencilWriteMask = t.stencilWriteMask),
                    (this.stencilFunc = t.stencilFunc),
                    (this.stencilRef = t.stencilRef),
                    (this.stencilFuncMask = t.stencilFuncMask),
                    (this.stencilFail = t.stencilFail),
                    (this.stencilZFail = t.stencilZFail),
                    (this.stencilZPass = t.stencilZPass),
                    (this.stencilWrite = t.stencilWrite)
                  var e = t.clippingPlanes,
                    n = null
                  if (null !== e)
                    for (
                      var r = e.length, n = new Array(r), i = 0;
                      i !== r;
                      ++i
                    )
                      n[i] = e[i].clone()
                  return (
                    (this.clippingPlanes = n),
                    (this.clipIntersection = t.clipIntersection),
                    (this.clipShadows = t.clipShadows),
                    (this.shadowSide = t.shadowSide),
                    (this.colorWrite = t.colorWrite),
                    (this.precision = t.precision),
                    (this.polygonOffset = t.polygonOffset),
                    (this.polygonOffsetFactor = t.polygonOffsetFactor),
                    (this.polygonOffsetUnits = t.polygonOffsetUnits),
                    (this.dithering = t.dithering),
                    (this.alphaTest = t.alphaTest),
                    (this.premultipliedAlpha = t.premultipliedAlpha),
                    (this.visible = t.visible),
                    (this.toneMapped = t.toneMapped),
                    (this.userData = JSON.parse(JSON.stringify(t.userData))),
                    this
                  )
                },
                dispose: function () {
                  this.dispatchEvent({ type: 'dispose' })
                },
              })),
                Object.defineProperty(Rr.prototype, 'needsUpdate', {
                  set: function (t) {
                    !0 === t && this.version++
                  },
                }),
                (((Cr.prototype = Object.create(Rr.prototype)).constructor =
                  Cr).prototype.isMeshBasicMaterial = !0),
                (Cr.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    (this.map = t.map),
                    (this.lightMap = t.lightMap),
                    (this.lightMapIntensity = t.lightMapIntensity),
                    (this.aoMap = t.aoMap),
                    (this.aoMapIntensity = t.aoMapIntensity),
                    (this.specularMap = t.specularMap),
                    (this.alphaMap = t.alphaMap),
                    (this.envMap = t.envMap),
                    (this.combine = t.combine),
                    (this.reflectivity = t.reflectivity),
                    (this.refractionRatio = t.refractionRatio),
                    (this.wireframe = t.wireframe),
                    (this.wireframeLinewidth = t.wireframeLinewidth),
                    (this.wireframeLinecap = t.wireframeLinecap),
                    (this.wireframeLinejoin = t.wireframeLinejoin),
                    (this.skinning = t.skinning),
                    (this.morphTargets = t.morphTargets),
                    this
                  )
                })
              var Pr = new on(),
                Or = new Ye()
              function Ir(t, e, n) {
                if (Array.isArray(t))
                  throw new TypeError(
                    'THREE.BufferAttribute: array should be a Typed Array.',
                  )
                ;(this.name = ''),
                  (this.array = t),
                  (this.itemSize = e),
                  (this.count = void 0 !== t ? t.length / e : 0),
                  (this.normalized = !0 === n),
                  (this.usage = Ge),
                  (this.updateRange = { offset: 0, count: -1 }),
                  (this.version = 0)
              }
              function Dr(t, e, n) {
                Ir.call(this, new Int8Array(t), e, n)
              }
              function Br(t, e, n) {
                Ir.call(this, new Uint8Array(t), e, n)
              }
              function Nr(t, e, n) {
                Ir.call(this, new Uint8ClampedArray(t), e, n)
              }
              function Ur(t, e, n) {
                Ir.call(this, new Int16Array(t), e, n)
              }
              function zr(t, e, n) {
                Ir.call(this, new Uint16Array(t), e, n)
              }
              function Fr(t, e, n) {
                Ir.call(this, new Int32Array(t), e, n)
              }
              function Hr(t, e, n) {
                Ir.call(this, new Uint32Array(t), e, n)
              }
              function Gr(t, e, n) {
                Ir.call(this, new Float32Array(t), e, n)
              }
              function kr(t, e, n) {
                Ir.call(this, new Float64Array(t), e, n)
              }
              function Vr() {
                ;(this.vertices = []),
                  (this.normals = []),
                  (this.colors = []),
                  (this.uvs = []),
                  (this.uvs2 = []),
                  (this.groups = []),
                  (this.morphTargets = {}),
                  (this.skinWeights = []),
                  (this.skinIndices = []),
                  (this.boundingBox = null),
                  (this.boundingSphere = null),
                  (this.verticesNeedUpdate = !1),
                  (this.normalsNeedUpdate = !1),
                  (this.colorsNeedUpdate = !1),
                  (this.uvsNeedUpdate = !1),
                  (this.groupsNeedUpdate = !1)
              }
              function jr(t) {
                if (0 === t.length) return -1 / 0
                for (var e = t[0], n = 1, r = t.length; n < r; ++n)
                  t[n] > e && (e = t[n])
                return e
              }
              Object.defineProperty(Ir.prototype, 'needsUpdate', {
                set: function (t) {
                  !0 === t && this.version++
                },
              }),
                Object.assign(Ir.prototype, {
                  isBufferAttribute: !0,
                  onUploadCallback: function () {},
                  setUsage: function (t) {
                    return (this.usage = t), this
                  },
                  copy: function (t) {
                    return (
                      (this.name = t.name),
                      (this.array = new t.array.constructor(t.array)),
                      (this.itemSize = t.itemSize),
                      (this.count = t.count),
                      (this.normalized = t.normalized),
                      (this.usage = t.usage),
                      this
                    )
                  },
                  copyAt: function (t, e, n) {
                    ;(t *= this.itemSize), (n *= e.itemSize)
                    for (var r = 0, i = this.itemSize; r < i; r++)
                      this.array[t + r] = e.array[n + r]
                    return this
                  },
                  copyArray: function (t) {
                    return this.array.set(t), this
                  },
                  copyColorsArray: function (t) {
                    for (
                      var e = this.array, n = 0, r = 0, i = t.length;
                      r < i;
                      r++
                    ) {
                      var a = t[r]
                      void 0 === a &&
                        (console.warn(
                          'THREE.BufferAttribute.copyColorsArray(): color is undefined',
                          r,
                        ),
                        (a = new Mr())),
                        (e[n++] = a.r),
                        (e[n++] = a.g),
                        (e[n++] = a.b)
                    }
                    return this
                  },
                  copyVector2sArray: function (t) {
                    for (
                      var e = this.array, n = 0, r = 0, i = t.length;
                      r < i;
                      r++
                    ) {
                      var a = t[r]
                      void 0 === a &&
                        (console.warn(
                          'THREE.BufferAttribute.copyVector2sArray(): vector is undefined',
                          r,
                        ),
                        (a = new Ye())),
                        (e[n++] = a.x),
                        (e[n++] = a.y)
                    }
                    return this
                  },
                  copyVector3sArray: function (t) {
                    for (
                      var e = this.array, n = 0, r = 0, i = t.length;
                      r < i;
                      r++
                    ) {
                      var a = t[r]
                      void 0 === a &&
                        (console.warn(
                          'THREE.BufferAttribute.copyVector3sArray(): vector is undefined',
                          r,
                        ),
                        (a = new on())),
                        (e[n++] = a.x),
                        (e[n++] = a.y),
                        (e[n++] = a.z)
                    }
                    return this
                  },
                  copyVector4sArray: function (t) {
                    for (
                      var e = this.array, n = 0, r = 0, i = t.length;
                      r < i;
                      r++
                    ) {
                      var a = t[r]
                      void 0 === a &&
                        (console.warn(
                          'THREE.BufferAttribute.copyVector4sArray(): vector is undefined',
                          r,
                        ),
                        (a = new $e())),
                        (e[n++] = a.x),
                        (e[n++] = a.y),
                        (e[n++] = a.z),
                        (e[n++] = a.w)
                    }
                    return this
                  },
                  applyMatrix3: function (t) {
                    if (2 === this.itemSize)
                      for (var e = 0, n = this.count; e < n; e++)
                        Or.fromBufferAttribute(this, e),
                          Or.applyMatrix3(t),
                          this.setXY(e, Or.x, Or.y)
                    else if (3 === this.itemSize)
                      for (var r = 0, i = this.count; r < i; r++)
                        Pr.fromBufferAttribute(this, r),
                          Pr.applyMatrix3(t),
                          this.setXYZ(r, Pr.x, Pr.y, Pr.z)
                    return this
                  },
                  applyMatrix4: function (t) {
                    for (var e = 0, n = this.count; e < n; e++)
                      (Pr.x = this.getX(e)),
                        (Pr.y = this.getY(e)),
                        (Pr.z = this.getZ(e)),
                        Pr.applyMatrix4(t),
                        this.setXYZ(e, Pr.x, Pr.y, Pr.z)
                    return this
                  },
                  applyNormalMatrix: function (t) {
                    for (var e = 0, n = this.count; e < n; e++)
                      (Pr.x = this.getX(e)),
                        (Pr.y = this.getY(e)),
                        (Pr.z = this.getZ(e)),
                        Pr.applyNormalMatrix(t),
                        this.setXYZ(e, Pr.x, Pr.y, Pr.z)
                    return this
                  },
                  transformDirection: function (t) {
                    for (var e = 0, n = this.count; e < n; e++)
                      (Pr.x = this.getX(e)),
                        (Pr.y = this.getY(e)),
                        (Pr.z = this.getZ(e)),
                        Pr.transformDirection(t),
                        this.setXYZ(e, Pr.x, Pr.y, Pr.z)
                    return this
                  },
                  set: function (t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                  },
                  getX: function (t) {
                    return this.array[t * this.itemSize]
                  },
                  setX: function (t, e) {
                    return (this.array[t * this.itemSize] = e), this
                  },
                  getY: function (t) {
                    return this.array[t * this.itemSize + 1]
                  },
                  setY: function (t, e) {
                    return (this.array[t * this.itemSize + 1] = e), this
                  },
                  getZ: function (t) {
                    return this.array[t * this.itemSize + 2]
                  },
                  setZ: function (t, e) {
                    return (this.array[t * this.itemSize + 2] = e), this
                  },
                  getW: function (t) {
                    return this.array[t * this.itemSize + 3]
                  },
                  setW: function (t, e) {
                    return (this.array[t * this.itemSize + 3] = e), this
                  },
                  setXY: function (t, e, n) {
                    return (
                      (t *= this.itemSize),
                      (this.array[t + 0] = e),
                      (this.array[t + 1] = n),
                      this
                    )
                  },
                  setXYZ: function (t, e, n, r) {
                    return (
                      (t *= this.itemSize),
                      (this.array[t + 0] = e),
                      (this.array[t + 1] = n),
                      (this.array[t + 2] = r),
                      this
                    )
                  },
                  setXYZW: function (t, e, n, r, i) {
                    return (
                      (t *= this.itemSize),
                      (this.array[t + 0] = e),
                      (this.array[t + 1] = n),
                      (this.array[t + 2] = r),
                      (this.array[t + 3] = i),
                      this
                    )
                  },
                  onUpload: function (t) {
                    return (this.onUploadCallback = t), this
                  },
                  clone: function () {
                    return new this.constructor(this.array, this.itemSize).copy(
                      this,
                    )
                  },
                  toJSON: function () {
                    return {
                      itemSize: this.itemSize,
                      type: this.array.constructor.name,
                      array: Array.prototype.slice.call(this.array),
                      normalized: this.normalized,
                    }
                  },
                }),
                ((Dr.prototype = Object.create(Ir.prototype)).constructor = Dr),
                ((Br.prototype = Object.create(Ir.prototype)).constructor = Br),
                ((Nr.prototype = Object.create(Ir.prototype)).constructor = Nr),
                ((Ur.prototype = Object.create(Ir.prototype)).constructor = Ur),
                ((zr.prototype = Object.create(Ir.prototype)).constructor = zr),
                ((Fr.prototype = Object.create(Ir.prototype)).constructor = Fr),
                ((Hr.prototype = Object.create(Ir.prototype)).constructor = Hr),
                ((Gr.prototype = Object.create(Ir.prototype)).constructor = Gr),
                ((kr.prototype = Object.create(Ir.prototype)).constructor = kr),
                Object.assign(Vr.prototype, {
                  computeGroups: function (t) {
                    for (
                      var e, n = [], r = void 0, i = t.faces, a = 0;
                      a < i.length;
                      a++
                    ) {
                      var o = i[a]
                      o.materialIndex !== r &&
                        ((r = o.materialIndex),
                        void 0 !== e &&
                          ((e.count = 3 * a - e.start), n.push(e)),
                        (e = { start: 3 * a, materialIndex: r }))
                    }
                    void 0 !== e && ((e.count = 3 * a - e.start), n.push(e)),
                      (this.groups = n)
                  },
                  fromGeometry: function (t) {
                    var e,
                      n = t.faces,
                      r = t.vertices,
                      i = t.faceVertexUvs,
                      a = i[0] && 0 < i[0].length,
                      o = i[1] && 0 < i[1].length,
                      s = t.morphTargets,
                      c = s.length
                    if (0 < c) {
                      e = []
                      for (var l = 0; l < c; l++)
                        e[l] = { name: s[l].name, data: [] }
                      this.morphTargets.position = e
                    }
                    var h,
                      u = t.morphNormals,
                      p = u.length
                    if (0 < p) {
                      h = []
                      for (var d = 0; d < p; d++)
                        h[d] = { name: u[d].name, data: [] }
                      this.morphTargets.normal = h
                    }
                    var f = t.skinIndices,
                      m = t.skinWeights,
                      v = f.length === r.length,
                      g = m.length === r.length
                    0 < r.length &&
                      0 === n.length &&
                      console.error(
                        'THREE.DirectGeometry: Faceless geometries are not supported.',
                      )
                    for (var y = 0; y < n.length; y++) {
                      var x = n[y]
                      this.vertices.push(r[x.a], r[x.b], r[x.c])
                      var b,
                        _ = x.vertexNormals
                      3 === _.length
                        ? this.normals.push(_[0], _[1], _[2])
                        : ((b = x.normal), this.normals.push(b, b, b))
                      var w,
                        M,
                        S,
                        E = x.vertexColors
                      3 === E.length
                        ? this.colors.push(E[0], E[1], E[2])
                        : ((w = x.color), this.colors.push(w, w, w)),
                        !0 === a &&
                          (void 0 !== (M = i[0][y])
                            ? this.uvs.push(M[0], M[1], M[2])
                            : (console.warn(
                                'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',
                                y,
                              ),
                              this.uvs.push(new Ye(), new Ye(), new Ye()))),
                        !0 === o &&
                          (void 0 !== (S = i[1][y])
                            ? this.uvs2.push(S[0], S[1], S[2])
                            : (console.warn(
                                'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',
                                y,
                              ),
                              this.uvs2.push(new Ye(), new Ye(), new Ye())))
                      for (var T = 0; T < c; T++) {
                        var A = s[T].vertices
                        e[T].data.push(A[x.a], A[x.b], A[x.c])
                      }
                      for (var L = 0; L < p; L++) {
                        var R = u[L].vertexNormals[y]
                        h[L].data.push(R.a, R.b, R.c)
                      }
                      v && this.skinIndices.push(f[x.a], f[x.b], f[x.c]),
                        g && this.skinWeights.push(m[x.a], m[x.b], m[x.c])
                    }
                    return (
                      this.computeGroups(t),
                      (this.verticesNeedUpdate = t.verticesNeedUpdate),
                      (this.normalsNeedUpdate = t.normalsNeedUpdate),
                      (this.colorsNeedUpdate = t.colorsNeedUpdate),
                      (this.uvsNeedUpdate = t.uvsNeedUpdate),
                      (this.groupsNeedUpdate = t.groupsNeedUpdate),
                      null !== t.boundingSphere &&
                        (this.boundingSphere = t.boundingSphere.clone()),
                      null !== t.boundingBox &&
                        (this.boundingBox = t.boundingBox.clone()),
                      this
                    )
                  },
                })
              var Wr = 1,
                qr = new fn(),
                Xr = new On(),
                Yr = new on(),
                Zr = new Xn(),
                Jr = new Xn(),
                Qr = new on()
              function Kr() {
                Object.defineProperty(this, 'id', { value: (Wr += 2) }),
                  (this.uuid = Xe.generateUUID()),
                  (this.name = ''),
                  (this.type = 'BufferGeometry'),
                  (this.index = null),
                  (this.attributes = {}),
                  (this.morphAttributes = {}),
                  (this.morphTargetsRelative = !1),
                  (this.groups = []),
                  (this.boundingBox = null),
                  (this.boundingSphere = null),
                  (this.drawRange = { start: 0, count: 1 / 0 }),
                  (this.userData = {})
              }
              Kr.prototype = Object.assign(Object.create(Ve.prototype), {
                constructor: Kr,
                isBufferGeometry: !0,
                getIndex: function () {
                  return this.index
                },
                setIndex: function (t) {
                  Array.isArray(t)
                    ? (this.index = new (65535 < jr(t) ? Hr : zr)(t, 1))
                    : (this.index = t)
                },
                getAttribute: function (t) {
                  return this.attributes[t]
                },
                setAttribute: function (t, e) {
                  return (this.attributes[t] = e), this
                },
                deleteAttribute: function (t) {
                  return delete this.attributes[t], this
                },
                addGroup: function (t, e, n) {
                  this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: void 0 !== n ? n : 0,
                  })
                },
                clearGroups: function () {
                  this.groups = []
                },
                setDrawRange: function (t, e) {
                  ;(this.drawRange.start = t), (this.drawRange.count = e)
                },
                applyMatrix4: function (t) {
                  var e = this.attributes.position
                  void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0))
                  var n,
                    r = this.attributes.normal
                  void 0 !== r &&
                    ((n = new Ze().getNormalMatrix(t)),
                    r.applyNormalMatrix(n),
                    (r.needsUpdate = !0))
                  var i = this.attributes.tangent
                  return (
                    void 0 !== i &&
                      (i.transformDirection(t), (i.needsUpdate = !0)),
                    null !== this.boundingBox && this.computeBoundingBox(),
                    null !== this.boundingSphere &&
                      this.computeBoundingSphere(),
                    this
                  )
                },
                rotateX: function (t) {
                  return qr.makeRotationX(t), this.applyMatrix4(qr), this
                },
                rotateY: function (t) {
                  return qr.makeRotationY(t), this.applyMatrix4(qr), this
                },
                rotateZ: function (t) {
                  return qr.makeRotationZ(t), this.applyMatrix4(qr), this
                },
                translate: function (t, e, n) {
                  return (
                    qr.makeTranslation(t, e, n), this.applyMatrix4(qr), this
                  )
                },
                scale: function (t, e, n) {
                  return qr.makeScale(t, e, n), this.applyMatrix4(qr), this
                },
                lookAt: function (t) {
                  return (
                    Xr.lookAt(t),
                    Xr.updateMatrix(),
                    this.applyMatrix4(Xr.matrix),
                    this
                  )
                },
                center: function () {
                  return (
                    this.computeBoundingBox(),
                    this.boundingBox.getCenter(Yr).negate(),
                    this.translate(Yr.x, Yr.y, Yr.z),
                    this
                  )
                },
                setFromObject: function (t) {
                  var e,
                    n,
                    r,
                    i = t.geometry
                  return (
                    t.isPoints || t.isLine
                      ? ((e = new Gr(3 * i.vertices.length, 3)),
                        (n = new Gr(3 * i.colors.length, 3)),
                        this.setAttribute(
                          'position',
                          e.copyVector3sArray(i.vertices),
                        ),
                        this.setAttribute('color', n.copyColorsArray(i.colors)),
                        i.lineDistances &&
                          i.lineDistances.length === i.vertices.length &&
                          ((r = new Gr(i.lineDistances.length, 1)),
                          this.setAttribute(
                            'lineDistance',
                            r.copyArray(i.lineDistances),
                          )),
                        null !== i.boundingSphere &&
                          (this.boundingSphere = i.boundingSphere.clone()),
                        null !== i.boundingBox &&
                          (this.boundingBox = i.boundingBox.clone()))
                      : t.isMesh && i && i.isGeometry && this.fromGeometry(i),
                    this
                  )
                },
                setFromPoints: function (t) {
                  for (var e = [], n = 0, r = t.length; n < r; n++) {
                    var i = t[n]
                    e.push(i.x, i.y, i.z || 0)
                  }
                  return this.setAttribute('position', new Gr(e, 3)), this
                },
                updateFromObject: function (t) {
                  var e,
                    n,
                    r,
                    i,
                    a,
                    o = t.geometry
                  if (t.isMesh) {
                    var s = o.__directGeometry
                    if (
                      (!0 === o.elementsNeedUpdate &&
                        ((s = void 0), (o.elementsNeedUpdate = !1)),
                      void 0 === s)
                    )
                      return this.fromGeometry(o)
                    ;(s.verticesNeedUpdate = o.verticesNeedUpdate),
                      (s.normalsNeedUpdate = o.normalsNeedUpdate),
                      (s.colorsNeedUpdate = o.colorsNeedUpdate),
                      (s.uvsNeedUpdate = o.uvsNeedUpdate),
                      (s.groupsNeedUpdate = o.groupsNeedUpdate),
                      (o.verticesNeedUpdate = !1),
                      (o.normalsNeedUpdate = !1),
                      (o.colorsNeedUpdate = !1),
                      (o.uvsNeedUpdate = !1),
                      (o.groupsNeedUpdate = !1),
                      (o = s)
                  }
                  return (
                    !0 === o.verticesNeedUpdate &&
                      (void 0 !== (e = this.attributes.position) &&
                        (e.copyVector3sArray(o.vertices), (e.needsUpdate = !0)),
                      (o.verticesNeedUpdate = !1)),
                    !0 === o.normalsNeedUpdate &&
                      (void 0 !== (n = this.attributes.normal) &&
                        (n.copyVector3sArray(o.normals), (n.needsUpdate = !0)),
                      (o.normalsNeedUpdate = !1)),
                    !0 === o.colorsNeedUpdate &&
                      (void 0 !== (r = this.attributes.color) &&
                        (r.copyColorsArray(o.colors), (r.needsUpdate = !0)),
                      (o.colorsNeedUpdate = !1)),
                    o.uvsNeedUpdate &&
                      (void 0 !== (i = this.attributes.uv) &&
                        (i.copyVector2sArray(o.uvs), (i.needsUpdate = !0)),
                      (o.uvsNeedUpdate = !1)),
                    o.lineDistancesNeedUpdate &&
                      (void 0 !== (a = this.attributes.lineDistance) &&
                        (a.copyArray(o.lineDistances), (a.needsUpdate = !0)),
                      (o.lineDistancesNeedUpdate = !1)),
                    o.groupsNeedUpdate &&
                      (o.computeGroups(t.geometry),
                      (this.groups = o.groups),
                      (o.groupsNeedUpdate = !1)),
                    this
                  )
                },
                fromGeometry: function (t) {
                  return (
                    (t.__directGeometry = new Vr().fromGeometry(t)),
                    this.fromDirectGeometry(t.__directGeometry)
                  )
                },
                fromDirectGeometry: function (t) {
                  var e,
                    n,
                    r,
                    i,
                    a,
                    o,
                    s = new Float32Array(3 * t.vertices.length)
                  for (var c in (this.setAttribute(
                    'position',
                    new Ir(s, 3).copyVector3sArray(t.vertices),
                  ),
                  0 < t.normals.length &&
                    ((e = new Float32Array(3 * t.normals.length)),
                    this.setAttribute(
                      'normal',
                      new Ir(e, 3).copyVector3sArray(t.normals),
                    )),
                  0 < t.colors.length &&
                    ((n = new Float32Array(3 * t.colors.length)),
                    this.setAttribute(
                      'color',
                      new Ir(n, 3).copyColorsArray(t.colors),
                    )),
                  0 < t.uvs.length &&
                    ((r = new Float32Array(2 * t.uvs.length)),
                    this.setAttribute(
                      'uv',
                      new Ir(r, 2).copyVector2sArray(t.uvs),
                    )),
                  0 < t.uvs2.length &&
                    ((i = new Float32Array(2 * t.uvs2.length)),
                    this.setAttribute(
                      'uv2',
                      new Ir(i, 2).copyVector2sArray(t.uvs2),
                    )),
                  (this.groups = t.groups),
                  t.morphTargets)) {
                    for (
                      var l = [], h = t.morphTargets[c], u = 0, p = h.length;
                      u < p;
                      u++
                    ) {
                      var d = h[u],
                        f = new Gr(3 * d.data.length, 3)
                      ;(f.name = d.name), l.push(f.copyVector3sArray(d.data))
                    }
                    this.morphAttributes[c] = l
                  }
                  return (
                    0 < t.skinIndices.length &&
                      ((a = new Gr(4 * t.skinIndices.length, 4)),
                      this.setAttribute(
                        'skinIndex',
                        a.copyVector4sArray(t.skinIndices),
                      )),
                    0 < t.skinWeights.length &&
                      ((o = new Gr(4 * t.skinWeights.length, 4)),
                      this.setAttribute(
                        'skinWeight',
                        o.copyVector4sArray(t.skinWeights),
                      )),
                    null !== t.boundingSphere &&
                      (this.boundingSphere = t.boundingSphere.clone()),
                    null !== t.boundingBox &&
                      (this.boundingBox = t.boundingBox.clone()),
                    this
                  )
                },
                computeBoundingBox: function () {
                  null === this.boundingBox && (this.boundingBox = new Xn())
                  var t = this.attributes.position,
                    e = this.morphAttributes.position
                  if (void 0 !== t) {
                    if ((this.boundingBox.setFromBufferAttribute(t), e))
                      for (var n = 0, r = e.length; n < r; n++) {
                        var i = e[n]
                        Zr.setFromBufferAttribute(i),
                          this.morphTargetsRelative
                            ? (Qr.addVectors(this.boundingBox.min, Zr.min),
                              this.boundingBox.expandByPoint(Qr),
                              Qr.addVectors(this.boundingBox.max, Zr.max),
                              this.boundingBox.expandByPoint(Qr))
                            : (this.boundingBox.expandByPoint(Zr.min),
                              this.boundingBox.expandByPoint(Zr.max))
                      }
                  } else this.boundingBox.makeEmpty()
                  ;(isNaN(this.boundingBox.min.x) ||
                    isNaN(this.boundingBox.min.y) ||
                    isNaN(this.boundingBox.min.z)) &&
                    console.error(
                      'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                      this,
                    )
                },
                computeBoundingSphere: function () {
                  null === this.boundingSphere &&
                    (this.boundingSphere = new Jn())
                  var t = this.attributes.position,
                    e = this.morphAttributes.position
                  if (t) {
                    var n = this.boundingSphere.center
                    if ((Zr.setFromBufferAttribute(t), e))
                      for (var r = 0, i = e.length; r < i; r++) {
                        var a = e[r]
                        Jr.setFromBufferAttribute(a),
                          this.morphTargetsRelative
                            ? (Qr.addVectors(Zr.min, Jr.min),
                              Zr.expandByPoint(Qr),
                              Qr.addVectors(Zr.max, Jr.max),
                              Zr.expandByPoint(Qr))
                            : (Zr.expandByPoint(Jr.min),
                              Zr.expandByPoint(Jr.max))
                      }
                    Zr.getCenter(n)
                    for (var o = 0, s = 0, c = t.count; s < c; s++)
                      Qr.fromBufferAttribute(t, s),
                        (o = Math.max(o, n.distanceToSquared(Qr)))
                    if (e)
                      for (var l = 0, h = e.length; l < h; l++)
                        for (
                          var u = e[l],
                            p = this.morphTargetsRelative,
                            d = 0,
                            f = u.count;
                          d < f;
                          d++
                        )
                          Qr.fromBufferAttribute(u, d),
                            p && (Yr.fromBufferAttribute(t, d), Qr.add(Yr)),
                            (o = Math.max(o, n.distanceToSquared(Qr)))
                    ;(this.boundingSphere.radius = Math.sqrt(o)),
                      isNaN(this.boundingSphere.radius) &&
                        console.error(
                          'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                          this,
                        )
                  }
                },
                computeFaceNormals: function () {},
                computeVertexNormals: function () {
                  var t = this.index,
                    e = this.getAttribute('position')
                  if (void 0 !== e) {
                    var n = this.getAttribute('normal')
                    if (void 0 === n)
                      (n = new Ir(new Float32Array(3 * e.count), 3)),
                        this.setAttribute('normal', n)
                    else
                      for (var r = 0, i = n.count; r < i; r++)
                        n.setXYZ(r, 0, 0, 0)
                    var a = new on(),
                      o = new on(),
                      s = new on(),
                      c = new on(),
                      l = new on(),
                      h = new on(),
                      u = new on(),
                      p = new on()
                    if (t)
                      for (var d = 0, f = t.count; d < f; d += 3) {
                        var m = t.getX(d + 0),
                          v = t.getX(d + 1),
                          g = t.getX(d + 2)
                        a.fromBufferAttribute(e, m),
                          o.fromBufferAttribute(e, v),
                          s.fromBufferAttribute(e, g),
                          u.subVectors(s, o),
                          p.subVectors(a, o),
                          u.cross(p),
                          c.fromBufferAttribute(n, m),
                          l.fromBufferAttribute(n, v),
                          h.fromBufferAttribute(n, g),
                          c.add(u),
                          l.add(u),
                          h.add(u),
                          n.setXYZ(m, c.x, c.y, c.z),
                          n.setXYZ(v, l.x, l.y, l.z),
                          n.setXYZ(g, h.x, h.y, h.z)
                      }
                    else
                      for (var y = 0, x = e.count; y < x; y += 3)
                        a.fromBufferAttribute(e, y + 0),
                          o.fromBufferAttribute(e, y + 1),
                          s.fromBufferAttribute(e, y + 2),
                          u.subVectors(s, o),
                          p.subVectors(a, o),
                          u.cross(p),
                          n.setXYZ(y + 0, u.x, u.y, u.z),
                          n.setXYZ(y + 1, u.x, u.y, u.z),
                          n.setXYZ(y + 2, u.x, u.y, u.z)
                    this.normalizeNormals(), (n.needsUpdate = !0)
                  }
                },
                merge: function (t, e) {
                  if (t && t.isBufferGeometry) {
                    void 0 === e &&
                      ((e = 0),
                      console.warn(
                        'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.',
                      ))
                    var n = this.attributes
                    for (var r in n)
                      if (void 0 !== t.attributes[r])
                        for (
                          var i = n[r].array,
                            a = t.attributes[r],
                            o = a.array,
                            s = a.itemSize * e,
                            c = Math.min(o.length, i.length - s),
                            l = 0,
                            h = s;
                          l < c;
                          l++, h++
                        )
                          i[h] = o[l]
                    return this
                  }
                  console.error(
                    'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
                    t,
                  )
                },
                normalizeNormals: function () {
                  for (
                    var t = this.attributes.normal, e = 0, n = t.count;
                    e < n;
                    e++
                  )
                    Qr.fromBufferAttribute(t, e),
                      Qr.normalize(),
                      t.setXYZ(e, Qr.x, Qr.y, Qr.z)
                },
                toNonIndexed: function () {
                  function t(t, e) {
                    for (
                      var n = t.array,
                        r = t.itemSize,
                        i = t.normalized,
                        a = new n.constructor(e.length * r),
                        o = 0,
                        s = 0,
                        c = 0,
                        l = e.length;
                      c < l;
                      c++
                    ) {
                      o = e[c] * r
                      for (var h = 0; h < r; h++) a[s++] = n[o++]
                    }
                    return new Ir(a, r, i)
                  }
                  if (null === this.index)
                    return (
                      console.warn(
                        'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.',
                      ),
                      this
                    )
                  var e = new Kr(),
                    n = this.index.array,
                    r = this.attributes
                  for (var i in r) {
                    var a = t(r[i], n)
                    e.setAttribute(i, a)
                  }
                  var o = this.morphAttributes
                  for (var s in o) {
                    for (
                      var c = [], l = o[s], h = 0, u = l.length;
                      h < u;
                      h++
                    ) {
                      var p = t(l[h], n)
                      c.push(p)
                    }
                    e.morphAttributes[s] = c
                  }
                  e.morphTargetsRelative = this.morphTargetsRelative
                  for (var d = this.groups, f = 0, m = d.length; f < m; f++) {
                    var v = d[f]
                    e.addGroup(v.start, v.count, v.materialIndex)
                  }
                  return e
                },
                toJSON: function () {
                  var t = {
                    metadata: {
                      version: 4.5,
                      type: 'BufferGeometry',
                      generator: 'BufferGeometry.toJSON',
                    },
                  }
                  if (
                    ((t.uuid = this.uuid),
                    (t.type = this.type),
                    '' !== this.name && (t.name = this.name),
                    0 < Object.keys(this.userData).length &&
                      (t.userData = this.userData),
                    void 0 !== this.parameters)
                  ) {
                    var e = this.parameters
                    for (var n in e) void 0 !== e[n] && (t[n] = e[n])
                    return t
                  }
                  t.data = { attributes: {} }
                  var r = this.index
                  null !== r &&
                    (t.data.index = {
                      type: r.array.constructor.name,
                      array: Array.prototype.slice.call(r.array),
                    })
                  var i = this.attributes
                  for (var a in i) {
                    var o = i[a],
                      s = o.toJSON(t.data)
                    '' !== o.name && (s.name = o.name),
                      (t.data.attributes[a] = s)
                  }
                  var c = {},
                    l = !1
                  for (var h in this.morphAttributes) {
                    for (
                      var u = this.morphAttributes[h],
                        p = [],
                        d = 0,
                        f = u.length;
                      d < f;
                      d++
                    ) {
                      var m = u[d],
                        v = m.toJSON(t.data)
                      '' !== m.name && (v.name = m.name), p.push(v)
                    }
                    0 < p.length && ((c[h] = p), (l = !0))
                  }
                  l &&
                    ((t.data.morphAttributes = c),
                    (t.data.morphTargetsRelative = this.morphTargetsRelative))
                  var g = this.groups
                  0 < g.length &&
                    (t.data.groups = JSON.parse(JSON.stringify(g)))
                  var y = this.boundingSphere
                  return (
                    null !== y &&
                      (t.data.boundingSphere = {
                        center: y.center.toArray(),
                        radius: y.radius,
                      }),
                    t
                  )
                },
                clone: function () {
                  return new Kr().copy(this)
                },
                copy: function (t) {
                  ;(this.index = null),
                    (this.attributes = {}),
                    (this.morphAttributes = {}),
                    (this.groups = []),
                    (this.boundingBox = null),
                    (this.boundingSphere = null)
                  var e = {}
                  this.name = t.name
                  var n = t.index
                  null !== n && this.setIndex(n.clone(e))
                  var r = t.attributes
                  for (var i in r) {
                    var a = r[i]
                    this.setAttribute(i, a.clone(e))
                  }
                  var o = t.morphAttributes
                  for (var s in o) {
                    for (var c = [], l = o[s], h = 0, u = l.length; h < u; h++)
                      c.push(l[h].clone(e))
                    this.morphAttributes[s] = c
                  }
                  this.morphTargetsRelative = t.morphTargetsRelative
                  for (var p = t.groups, d = 0, f = p.length; d < f; d++) {
                    var m = p[d]
                    this.addGroup(m.start, m.count, m.materialIndex)
                  }
                  var v = t.boundingBox
                  null !== v && (this.boundingBox = v.clone())
                  var g = t.boundingSphere
                  return (
                    null !== g && (this.boundingSphere = g.clone()),
                    (this.drawRange.start = t.drawRange.start),
                    (this.drawRange.count = t.drawRange.count),
                    (this.userData = t.userData),
                    this
                  )
                },
                dispose: function () {
                  this.dispatchEvent({ type: 'dispose' })
                },
              })
              var $r = new fn(),
                ti = new ir(),
                ei = new Jn(),
                ni = new on(),
                ri = new on(),
                ii = new on(),
                ai = new on(),
                oi = new on(),
                si = new on(),
                ci = new on(),
                li = new on(),
                hi = new on(),
                ui = new Ye(),
                pi = new Ye(),
                di = new Ye(),
                fi = new on(),
                mi = new on()
              function vi(t, e) {
                On.call(this),
                  (this.type = 'Mesh'),
                  (this.geometry = void 0 !== t ? t : new Kr()),
                  (this.material = void 0 !== e ? e : new Cr()),
                  this.updateMorphTargets()
              }
              function gi(t, e, n, r, i, a, o, s) {
                var c =
                  e.side === q
                    ? r.intersectTriangle(o, a, i, !0, s)
                    : r.intersectTriangle(i, a, o, e.side !== X, s)
                if (null === c) return null
                mi.copy(s), mi.applyMatrix4(t.matrixWorld)
                var l = n.ray.origin.distanceTo(mi)
                return l < n.near || l > n.far
                  ? null
                  : { distance: l, point: mi.clone(), object: t }
              }
              function yi(t, e, n, r, i, a, o, s, c, l, h, u) {
                ni.fromBufferAttribute(i, l),
                  ri.fromBufferAttribute(i, h),
                  ii.fromBufferAttribute(i, u)
                var p = t.morphTargetInfluences
                if (e.morphTargets && a && p) {
                  ci.set(0, 0, 0), li.set(0, 0, 0), hi.set(0, 0, 0)
                  for (var d = 0, f = a.length; d < f; d++) {
                    var m = p[d],
                      v = a[d]
                    0 !== m &&
                      (ai.fromBufferAttribute(v, l),
                      oi.fromBufferAttribute(v, h),
                      si.fromBufferAttribute(v, u),
                      o
                        ? (ci.addScaledVector(ai, m),
                          li.addScaledVector(oi, m),
                          hi.addScaledVector(si, m))
                        : (ci.addScaledVector(ai.sub(ni), m),
                          li.addScaledVector(oi.sub(ri), m),
                          hi.addScaledVector(si.sub(ii), m)))
                  }
                  ni.add(ci), ri.add(li), ii.add(hi)
                }
                t.isSkinnedMesh &&
                  (t.boneTransform(l, ni),
                  t.boneTransform(h, ri),
                  t.boneTransform(u, ii))
                var g,
                  y = gi(t, e, n, r, ni, ri, ii, fi)
                return (
                  y &&
                    (s &&
                      (ui.fromBufferAttribute(s, l),
                      pi.fromBufferAttribute(s, h),
                      di.fromBufferAttribute(s, u),
                      (y.uv = xr.getUV(fi, ni, ri, ii, ui, pi, di, new Ye()))),
                    c &&
                      (ui.fromBufferAttribute(c, l),
                      pi.fromBufferAttribute(c, h),
                      di.fromBufferAttribute(c, u),
                      (y.uv2 = xr.getUV(fi, ni, ri, ii, ui, pi, di, new Ye()))),
                    (g = new Ar(l, h, u)),
                    xr.getNormal(ni, ri, ii, g.normal),
                    (y.face = g)),
                  y
                )
              }
              vi.prototype = Object.assign(Object.create(On.prototype), {
                constructor: vi,
                isMesh: !0,
                copy: function (t) {
                  return (
                    On.prototype.copy.call(this, t),
                    void 0 !== t.morphTargetInfluences &&
                      (this.morphTargetInfluences =
                        t.morphTargetInfluences.slice()),
                    void 0 !== t.morphTargetDictionary &&
                      (this.morphTargetDictionary = Object.assign(
                        {},
                        t.morphTargetDictionary,
                      )),
                    (this.material = t.material),
                    (this.geometry = t.geometry),
                    this
                  )
                },
                updateMorphTargets: function () {
                  var t = this.geometry
                  if (t.isBufferGeometry) {
                    var e = t.morphAttributes,
                      n = Object.keys(e)
                    if (0 < n.length) {
                      var r = e[n[0]]
                      if (void 0 !== r) {
                        ;(this.morphTargetInfluences = []),
                          (this.morphTargetDictionary = {})
                        for (var i = 0, a = r.length; i < a; i++) {
                          var o = r[i].name || String(i)
                          this.morphTargetInfluences.push(0),
                            (this.morphTargetDictionary[o] = i)
                        }
                      }
                    }
                  } else {
                    var s = t.morphTargets
                    void 0 !== s &&
                      0 < s.length &&
                      console.error(
                        'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                      )
                  }
                },
                raycast: function (t, e) {
                  var n = this.geometry,
                    r = this.material,
                    i = this.matrixWorld
                  if (
                    void 0 !== r &&
                    (null === n.boundingSphere && n.computeBoundingSphere(),
                    ei.copy(n.boundingSphere),
                    ei.applyMatrix4(i),
                    !1 !== t.ray.intersectsSphere(ei) &&
                      ($r.getInverse(i),
                      ti.copy(t.ray).applyMatrix4($r),
                      null === n.boundingBox ||
                        !1 !== ti.intersectsBox(n.boundingBox)))
                  )
                    if (n.isBufferGeometry) {
                      var a = n.index,
                        o = n.attributes.position,
                        s = n.morphAttributes.position,
                        c = n.morphTargetsRelative,
                        l = n.attributes.uv,
                        h = n.attributes.uv2,
                        u = n.groups,
                        p = n.drawRange
                      if (null !== a)
                        if (Array.isArray(r))
                          for (var d = 0, f = u.length; d < f; d++)
                            for (
                              var m = u[d],
                                v = r[m.materialIndex],
                                g = Math.max(m.start, p.start),
                                y = Math.min(
                                  m.start + m.count,
                                  p.start + p.count,
                                );
                              g < y;
                              g += 3
                            ) {
                              var x,
                                b = a.getX(g),
                                _ = a.getX(g + 1),
                                w = a.getX(g + 2)
                              ;(x = yi(
                                this,
                                v,
                                t,
                                ti,
                                o,
                                s,
                                c,
                                l,
                                h,
                                b,
                                _,
                                w,
                              )) &&
                                ((x.faceIndex = Math.floor(g / 3)),
                                (x.face.materialIndex = m.materialIndex),
                                e.push(x))
                            }
                        else
                          for (
                            var M = Math.max(0, p.start),
                              S = Math.min(a.count, p.start + p.count);
                            M < S;
                            M += 3
                          ) {
                            var E = a.getX(M),
                              T = a.getX(M + 1),
                              A = a.getX(M + 2)
                            ;(x = yi(this, r, t, ti, o, s, c, l, h, E, T, A)) &&
                              ((x.faceIndex = Math.floor(M / 3)), e.push(x))
                          }
                      else if (void 0 !== o)
                        if (Array.isArray(r))
                          for (var L = 0, R = u.length; L < R; L++)
                            for (
                              var C = u[L],
                                P = r[C.materialIndex],
                                O = Math.max(C.start, p.start),
                                I = Math.min(
                                  C.start + C.count,
                                  p.start + p.count,
                                );
                              O < I;
                              O += 3
                            ) {
                              ;(x = yi(
                                this,
                                P,
                                t,
                                ti,
                                o,
                                s,
                                c,
                                l,
                                h,
                                O,
                                O + 1,
                                O + 2,
                              )) &&
                                ((x.faceIndex = Math.floor(O / 3)),
                                (x.face.materialIndex = C.materialIndex),
                                e.push(x))
                            }
                        else
                          for (
                            var D = Math.max(0, p.start),
                              B = Math.min(o.count, p.start + p.count);
                            D < B;
                            D += 3
                          ) {
                            ;(x = yi(
                              this,
                              r,
                              t,
                              ti,
                              o,
                              s,
                              c,
                              l,
                              h,
                              D,
                              D + 1,
                              D + 2,
                            )) && ((x.faceIndex = Math.floor(D / 3)), e.push(x))
                          }
                    } else if (n.isGeometry) {
                      var N,
                        U = Array.isArray(r),
                        z = n.vertices,
                        F = n.faces,
                        H = n.faceVertexUvs[0]
                      0 < H.length && (N = H)
                      for (var G = 0, k = F.length; G < k; G++) {
                        var V,
                          j,
                          W,
                          q,
                          X = F[G],
                          Y = U ? r[X.materialIndex] : r
                        void 0 !== Y &&
                          ((V = z[X.a]),
                          (j = z[X.b]),
                          (W = z[X.c]),
                          (x = gi(this, Y, t, ti, V, j, W, fi)) &&
                            (N &&
                              N[G] &&
                              ((q = N[G]),
                              ui.copy(q[0]),
                              pi.copy(q[1]),
                              di.copy(q[2]),
                              (x.uv = xr.getUV(
                                fi,
                                V,
                                j,
                                W,
                                ui,
                                pi,
                                di,
                                new Ye(),
                              ))),
                            (x.face = X),
                            (x.faceIndex = G),
                            e.push(x)))
                      }
                    }
                },
              })
              var xi = 0,
                bi = new fn(),
                _i = new On(),
                wi = new on()
              function Mi() {
                Object.defineProperty(this, 'id', { value: (xi += 2) }),
                  (this.uuid = Xe.generateUUID()),
                  (this.name = ''),
                  (this.type = 'Geometry'),
                  (this.vertices = []),
                  (this.colors = []),
                  (this.faces = []),
                  (this.faceVertexUvs = [[]]),
                  (this.morphTargets = []),
                  (this.morphNormals = []),
                  (this.skinWeights = []),
                  (this.skinIndices = []),
                  (this.lineDistances = []),
                  (this.boundingBox = null),
                  (this.boundingSphere = null),
                  (this.elementsNeedUpdate = !1),
                  (this.verticesNeedUpdate = !1),
                  (this.uvsNeedUpdate = !1),
                  (this.normalsNeedUpdate = !1),
                  (this.colorsNeedUpdate = !1),
                  (this.lineDistancesNeedUpdate = !1),
                  (this.groupsNeedUpdate = !1)
              }
              Mi.prototype = Object.assign(Object.create(Ve.prototype), {
                constructor: Mi,
                isGeometry: !0,
                applyMatrix4: function (t) {
                  for (
                    var e = new Ze().getNormalMatrix(t),
                      n = 0,
                      r = this.vertices.length;
                    n < r;
                    n++
                  ) {
                    this.vertices[n].applyMatrix4(t)
                  }
                  for (var i = 0, a = this.faces.length; i < a; i++) {
                    var o = this.faces[i]
                    o.normal.applyMatrix3(e).normalize()
                    for (var s = 0, c = o.vertexNormals.length; s < c; s++)
                      o.vertexNormals[s].applyMatrix3(e).normalize()
                  }
                  return (
                    null !== this.boundingBox && this.computeBoundingBox(),
                    null !== this.boundingSphere &&
                      this.computeBoundingSphere(),
                    (this.verticesNeedUpdate = !0),
                    (this.normalsNeedUpdate = !0),
                    this
                  )
                },
                rotateX: function (t) {
                  return bi.makeRotationX(t), this.applyMatrix4(bi), this
                },
                rotateY: function (t) {
                  return bi.makeRotationY(t), this.applyMatrix4(bi), this
                },
                rotateZ: function (t) {
                  return bi.makeRotationZ(t), this.applyMatrix4(bi), this
                },
                translate: function (t, e, n) {
                  return (
                    bi.makeTranslation(t, e, n), this.applyMatrix4(bi), this
                  )
                },
                scale: function (t, e, n) {
                  return bi.makeScale(t, e, n), this.applyMatrix4(bi), this
                },
                lookAt: function (t) {
                  return (
                    _i.lookAt(t),
                    _i.updateMatrix(),
                    this.applyMatrix4(_i.matrix),
                    this
                  )
                },
                fromBufferGeometry: function (t) {
                  var o = this,
                    e = null !== t.index ? t.index : void 0,
                    n = t.attributes
                  if (void 0 === n.position)
                    return (
                      console.error(
                        'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.',
                      ),
                      this
                    )
                  var r = n.position,
                    s = n.normal,
                    c = n.color,
                    l = n.uv,
                    h = n.uv2
                  void 0 !== h && (this.faceVertexUvs[1] = [])
                  for (var i = 0; i < r.count; i++)
                    o.vertices.push(new on().fromBufferAttribute(r, i)),
                      void 0 !== c &&
                        o.colors.push(new Mr().fromBufferAttribute(c, i))
                  function a(t, e, n, r) {
                    var i =
                        void 0 === c
                          ? []
                          : [
                              o.colors[t].clone(),
                              o.colors[e].clone(),
                              o.colors[n].clone(),
                            ],
                      a = new Ar(
                        t,
                        e,
                        n,
                        void 0 === s
                          ? []
                          : [
                              new on().fromBufferAttribute(s, t),
                              new on().fromBufferAttribute(s, e),
                              new on().fromBufferAttribute(s, n),
                            ],
                        i,
                        r,
                      )
                    o.faces.push(a),
                      void 0 !== l &&
                        o.faceVertexUvs[0].push([
                          new Ye().fromBufferAttribute(l, t),
                          new Ye().fromBufferAttribute(l, e),
                          new Ye().fromBufferAttribute(l, n),
                        ]),
                      void 0 !== h &&
                        o.faceVertexUvs[1].push([
                          new Ye().fromBufferAttribute(h, t),
                          new Ye().fromBufferAttribute(h, e),
                          new Ye().fromBufferAttribute(h, n),
                        ])
                  }
                  var u = t.groups
                  if (0 < u.length)
                    for (var p = 0; p < u.length; p++)
                      for (
                        var d = u[p], f = d.start, m = f, v = f + d.count;
                        m < v;
                        m += 3
                      )
                        void 0 !== e
                          ? a(
                              e.getX(m),
                              e.getX(m + 1),
                              e.getX(m + 2),
                              d.materialIndex,
                            )
                          : a(m, m + 1, m + 2, d.materialIndex)
                  else if (void 0 !== e)
                    for (var g = 0; g < e.count; g += 3)
                      a(e.getX(g), e.getX(g + 1), e.getX(g + 2))
                  else for (var y = 0; y < r.count; y += 3) a(y, y + 1, y + 2)
                  return (
                    this.computeFaceNormals(),
                    null !== t.boundingBox &&
                      (this.boundingBox = t.boundingBox.clone()),
                    null !== t.boundingSphere &&
                      (this.boundingSphere = t.boundingSphere.clone()),
                    this
                  )
                },
                center: function () {
                  return (
                    this.computeBoundingBox(),
                    this.boundingBox.getCenter(wi).negate(),
                    this.translate(wi.x, wi.y, wi.z),
                    this
                  )
                },
                normalize: function () {
                  this.computeBoundingSphere()
                  var t = this.boundingSphere.center,
                    e = this.boundingSphere.radius,
                    n = 0 === e ? 1 : 1 / e,
                    r = new fn()
                  return (
                    r.set(
                      n,
                      0,
                      0,
                      -n * t.x,
                      0,
                      n,
                      0,
                      -n * t.y,
                      0,
                      0,
                      n,
                      -n * t.z,
                      0,
                      0,
                      0,
                      1,
                    ),
                    this.applyMatrix4(r),
                    this
                  )
                },
                computeFaceNormals: function () {
                  for (
                    var t = new on(),
                      e = new on(),
                      n = 0,
                      r = this.faces.length;
                    n < r;
                    n++
                  ) {
                    var i = this.faces[n],
                      a = this.vertices[i.a],
                      o = this.vertices[i.b],
                      s = this.vertices[i.c]
                    t.subVectors(s, o),
                      e.subVectors(a, o),
                      t.cross(e),
                      t.normalize(),
                      i.normal.copy(t)
                  }
                },
                computeVertexNormals: function (t) {
                  void 0 === t && (t = !0)
                  for (
                    var e = new Array(this.vertices.length),
                      n = 0,
                      r = this.vertices.length;
                    n < r;
                    n++
                  )
                    e[n] = new on()
                  if (t)
                    for (
                      var i = new on(),
                        a = new on(),
                        o = 0,
                        s = this.faces.length;
                      o < s;
                      o++
                    ) {
                      var c = this.faces[o],
                        l = this.vertices[c.a],
                        h = this.vertices[c.b],
                        u = this.vertices[c.c]
                      i.subVectors(u, h),
                        a.subVectors(l, h),
                        i.cross(a),
                        e[c.a].add(i),
                        e[c.b].add(i),
                        e[c.c].add(i)
                    }
                  else {
                    this.computeFaceNormals()
                    for (var p = 0, d = this.faces.length; p < d; p++) {
                      var f = this.faces[p]
                      e[f.a].add(f.normal),
                        e[f.b].add(f.normal),
                        e[f.c].add(f.normal)
                    }
                  }
                  for (var m = 0, v = this.vertices.length; m < v; m++)
                    e[m].normalize()
                  for (var g = 0, y = this.faces.length; g < y; g++) {
                    var x = this.faces[g],
                      b = x.vertexNormals
                    3 === b.length
                      ? (b[0].copy(e[x.a]),
                        b[1].copy(e[x.b]),
                        b[2].copy(e[x.c]))
                      : ((b[0] = e[x.a].clone()),
                        (b[1] = e[x.b].clone()),
                        (b[2] = e[x.c].clone()))
                  }
                  0 < this.faces.length && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function () {
                  this.computeFaceNormals()
                  for (var t = 0, e = this.faces.length; t < e; t++) {
                    var n = this.faces[t],
                      r = n.vertexNormals
                    3 === r.length
                      ? (r[0].copy(n.normal),
                        r[1].copy(n.normal),
                        r[2].copy(n.normal))
                      : ((r[0] = n.normal.clone()),
                        (r[1] = n.normal.clone()),
                        (r[2] = n.normal.clone()))
                  }
                  0 < this.faces.length && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function () {
                  for (var t = 0, e = this.faces.length; t < e; t++) {
                    var n = this.faces[t]
                    n.__originalFaceNormal
                      ? n.__originalFaceNormal.copy(n.normal)
                      : (n.__originalFaceNormal = n.normal.clone()),
                      n.__originalVertexNormals ||
                        (n.__originalVertexNormals = [])
                    for (var r = 0, i = n.vertexNormals.length; r < i; r++)
                      n.__originalVertexNormals[r]
                        ? n.__originalVertexNormals[r].copy(n.vertexNormals[r])
                        : (n.__originalVertexNormals[r] =
                            n.vertexNormals[r].clone())
                  }
                  var a = new Mi()
                  a.faces = this.faces
                  for (var o = 0, s = this.morphTargets.length; o < s; o++) {
                    if (!this.morphNormals[o]) {
                      ;(this.morphNormals[o] = {}),
                        (this.morphNormals[o].faceNormals = []),
                        (this.morphNormals[o].vertexNormals = [])
                      for (
                        var c = this.morphNormals[o].faceNormals,
                          l = this.morphNormals[o].vertexNormals,
                          h = 0,
                          u = this.faces.length;
                        h < u;
                        h++
                      ) {
                        var p = new on(),
                          d = { a: new on(), b: new on(), c: new on() }
                        c.push(p), l.push(d)
                      }
                    }
                    var f = this.morphNormals[o]
                    ;(a.vertices = this.morphTargets[o].vertices),
                      a.computeFaceNormals(),
                      a.computeVertexNormals()
                    for (var m = 0, v = this.faces.length; m < v; m++) {
                      var g = this.faces[m],
                        y = f.faceNormals[m],
                        x = f.vertexNormals[m]
                      y.copy(g.normal),
                        x.a.copy(g.vertexNormals[0]),
                        x.b.copy(g.vertexNormals[1]),
                        x.c.copy(g.vertexNormals[2])
                    }
                  }
                  for (var b = 0, _ = this.faces.length; b < _; b++) {
                    var w = this.faces[b]
                    ;(w.normal = w.__originalFaceNormal),
                      (w.vertexNormals = w.__originalVertexNormals)
                  }
                },
                computeBoundingBox: function () {
                  null === this.boundingBox && (this.boundingBox = new Xn()),
                    this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function () {
                  null === this.boundingSphere &&
                    (this.boundingSphere = new Jn()),
                    this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function (t, e, n) {
                  if (t && t.isGeometry) {
                    var r,
                      i = this.vertices.length,
                      a = this.vertices,
                      o = t.vertices,
                      s = this.faces,
                      c = t.faces,
                      l = this.colors,
                      h = t.colors
                    void 0 === n && (n = 0),
                      void 0 !== e && (r = new Ze().getNormalMatrix(e))
                    for (var u = 0, p = o.length; u < p; u++) {
                      var d = o[u].clone()
                      void 0 !== e && d.applyMatrix4(e), a.push(d)
                    }
                    for (var f = 0, m = h.length; f < m; f++)
                      l.push(h[f].clone())
                    for (var v = 0, g = c.length; v < g; v++) {
                      var y = c[v],
                        x = void 0,
                        b = void 0,
                        _ = void 0,
                        w = y.vertexNormals,
                        M = y.vertexColors
                      ;(x = new Ar(y.a + i, y.b + i, y.c + i)).normal.copy(
                        y.normal,
                      ),
                        void 0 !== r && x.normal.applyMatrix3(r).normalize()
                      for (var S = 0, E = w.length; S < E; S++)
                        (b = w[S].clone()),
                          void 0 !== r && b.applyMatrix3(r).normalize(),
                          x.vertexNormals.push(b)
                      x.color.copy(y.color)
                      for (var T = 0, A = M.length; T < A; T++)
                        (_ = M[T]), x.vertexColors.push(_.clone())
                      ;(x.materialIndex = y.materialIndex + n), s.push(x)
                    }
                    for (var L = 0, R = t.faceVertexUvs.length; L < R; L++) {
                      var C = t.faceVertexUvs[L]
                      void 0 === this.faceVertexUvs[L] &&
                        (this.faceVertexUvs[L] = [])
                      for (var P = 0, O = C.length; P < O; P++) {
                        for (
                          var I = C[P], D = [], B = 0, N = I.length;
                          B < N;
                          B++
                        )
                          D.push(I[B].clone())
                        this.faceVertexUvs[L].push(D)
                      }
                    }
                  } else
                    console.error(
                      'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',
                      t,
                    )
                },
                mergeMesh: function (t) {
                  t && t.isMesh
                    ? (t.matrixAutoUpdate && t.updateMatrix(),
                      this.merge(t.geometry, t.matrix))
                    : console.error(
                        'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',
                        t,
                      )
                },
                mergeVertices: function () {
                  for (
                    var t = {},
                      e = [],
                      n = [],
                      r = Math.pow(10, 4),
                      i = 0,
                      a = this.vertices.length;
                    i < a;
                    i++
                  ) {
                    var o = this.vertices[i],
                      s =
                        Math.round(o.x * r) +
                        '_' +
                        Math.round(o.y * r) +
                        '_' +
                        Math.round(o.z * r)
                    void 0 === t[s]
                      ? ((t[s] = i),
                        e.push(this.vertices[i]),
                        (n[i] = e.length - 1))
                      : (n[i] = n[t[s]])
                  }
                  for (var c = [], l = 0, h = this.faces.length; l < h; l++) {
                    var u = this.faces[l]
                    ;(u.a = n[u.a]), (u.b = n[u.b]), (u.c = n[u.c])
                    for (var p = [u.a, u.b, u.c], d = 0; d < 3; d++)
                      if (p[d] === p[(d + 1) % 3]) {
                        c.push(l)
                        break
                      }
                  }
                  for (var f = c.length - 1; 0 <= f; f--) {
                    var m = c[f]
                    this.faces.splice(m, 1)
                    for (var v = 0, g = this.faceVertexUvs.length; v < g; v++)
                      this.faceVertexUvs[v].splice(m, 1)
                  }
                  var y = this.vertices.length - e.length
                  return (this.vertices = e), y
                },
                setFromPoints: function (t) {
                  this.vertices = []
                  for (var e = 0, n = t.length; e < n; e++) {
                    var r = t[e]
                    this.vertices.push(new on(r.x, r.y, r.z || 0))
                  }
                  return this
                },
                sortFacesByMaterialIndex: function () {
                  for (var t = this.faces, e = t.length, n = 0; n < e; n++)
                    t[n]._id = n
                  t.sort(function (t, e) {
                    return t.materialIndex - e.materialIndex
                  })
                  var r,
                    i,
                    a = this.faceVertexUvs[0],
                    o = this.faceVertexUvs[1]
                  a && a.length === e && (r = []),
                    o && o.length === e && (i = [])
                  for (var s = 0; s < e; s++) {
                    var c = t[s]._id
                    r && r.push(a[c]), i && i.push(o[c])
                  }
                  r && (this.faceVertexUvs[0] = r),
                    i && (this.faceVertexUvs[1] = i)
                },
                toJSON: function () {
                  var t = {
                    metadata: {
                      version: 4.5,
                      type: 'Geometry',
                      generator: 'Geometry.toJSON',
                    },
                  }
                  if (
                    ((t.uuid = this.uuid),
                    (t.type = this.type),
                    '' !== this.name && (t.name = this.name),
                    void 0 !== this.parameters)
                  ) {
                    var e = this.parameters
                    for (var n in e) void 0 !== e[n] && (t[n] = e[n])
                    return t
                  }
                  for (var r = [], i = 0; i < this.vertices.length; i++) {
                    var a = this.vertices[i]
                    r.push(a.x, a.y, a.z)
                  }
                  for (
                    var o = [],
                      s = [],
                      c = {},
                      l = [],
                      h = {},
                      u = [],
                      p = {},
                      d = 0;
                    d < this.faces.length;
                    d++
                  ) {
                    var f,
                      m,
                      v,
                      g,
                      y = this.faces[d],
                      x = void 0 !== this.faceVertexUvs[0][d],
                      b = 0 < y.normal.length(),
                      _ = 0 < y.vertexNormals.length,
                      w = 1 !== y.color.r || 1 !== y.color.g || 1 !== y.color.b,
                      M = 0 < y.vertexColors.length
                    ;(g = S(2, 3, x)),
                      (g = S(g, 4, b)),
                      (g = S(g, 5, _)),
                      (g = S(g, 6, w)),
                      (g = S(g, 7, M)),
                      o.push(g),
                      o.push(y.a, y.b, y.c),
                      o.push(y.materialIndex),
                      x &&
                        ((f = this.faceVertexUvs[0][d]),
                        o.push(A(f[0]), A(f[1]), A(f[2]))),
                      b && o.push(E(y.normal)),
                      _ &&
                        ((m = y.vertexNormals),
                        o.push(E(m[0]), E(m[1]), E(m[2]))),
                      w && o.push(T(y.color)),
                      M &&
                        ((v = y.vertexColors),
                        o.push(T(v[0]), T(v[1]), T(v[2])))
                  }
                  function S(t, e, n) {
                    return n ? t | (1 << e) : t & ~(1 << e)
                  }
                  function E(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString()
                    return (
                      void 0 !== c[e] ||
                        ((c[e] = s.length / 3), s.push(t.x, t.y, t.z)),
                      c[e]
                    )
                  }
                  function T(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString()
                    return (
                      void 0 !== h[e] ||
                        ((h[e] = l.length), l.push(t.getHex())),
                      h[e]
                    )
                  }
                  function A(t) {
                    var e = t.x.toString() + t.y.toString()
                    return (
                      void 0 !== p[e] ||
                        ((p[e] = u.length / 2), u.push(t.x, t.y)),
                      p[e]
                    )
                  }
                  return (
                    (t.data = {}),
                    (t.data.vertices = r),
                    (t.data.normals = s),
                    0 < l.length && (t.data.colors = l),
                    0 < u.length && (t.data.uvs = [u]),
                    (t.data.faces = o),
                    t
                  )
                },
                clone: function () {
                  return new Mi().copy(this)
                },
                copy: function (t) {
                  ;(this.vertices = []),
                    (this.colors = []),
                    (this.faces = []),
                    (this.faceVertexUvs = [[]]),
                    (this.morphTargets = []),
                    (this.morphNormals = []),
                    (this.skinWeights = []),
                    (this.skinIndices = []),
                    (this.lineDistances = []),
                    (this.boundingBox = null),
                    (this.boundingSphere = null),
                    (this.name = t.name)
                  for (var e = t.vertices, n = 0, r = e.length; n < r; n++)
                    this.vertices.push(e[n].clone())
                  for (var i = t.colors, a = 0, o = i.length; a < o; a++)
                    this.colors.push(i[a].clone())
                  for (var s = t.faces, c = 0, l = s.length; c < l; c++)
                    this.faces.push(s[c].clone())
                  for (var h = 0, u = t.faceVertexUvs.length; h < u; h++) {
                    var p = t.faceVertexUvs[h]
                    void 0 === this.faceVertexUvs[h] &&
                      (this.faceVertexUvs[h] = [])
                    for (var d = 0, f = p.length; d < f; d++) {
                      for (
                        var m = p[d], v = [], g = 0, y = m.length;
                        g < y;
                        g++
                      ) {
                        var x = m[g]
                        v.push(x.clone())
                      }
                      this.faceVertexUvs[h].push(v)
                    }
                  }
                  for (
                    var b = t.morphTargets, _ = 0, w = b.length;
                    _ < w;
                    _++
                  ) {
                    var M = {}
                    if (((M.name = b[_].name), void 0 !== b[_].vertices)) {
                      M.vertices = []
                      for (var S = 0, E = b[_].vertices.length; S < E; S++)
                        M.vertices.push(b[_].vertices[S].clone())
                    }
                    if (void 0 !== b[_].normals) {
                      M.normals = []
                      for (var T = 0, A = b[_].normals.length; T < A; T++)
                        M.normals.push(b[_].normals[T].clone())
                    }
                    this.morphTargets.push(M)
                  }
                  for (
                    var L = t.morphNormals, R = 0, C = L.length;
                    R < C;
                    R++
                  ) {
                    var P = {}
                    if (void 0 !== L[R].vertexNormals) {
                      P.vertexNormals = []
                      for (
                        var O = 0, I = L[R].vertexNormals.length;
                        O < I;
                        O++
                      ) {
                        var D = L[R].vertexNormals[O],
                          B = {}
                        ;(B.a = D.a.clone()),
                          (B.b = D.b.clone()),
                          (B.c = D.c.clone()),
                          P.vertexNormals.push(B)
                      }
                    }
                    if (void 0 !== L[R].faceNormals) {
                      P.faceNormals = []
                      for (var N = 0, U = L[R].faceNormals.length; N < U; N++)
                        P.faceNormals.push(L[R].faceNormals[N].clone())
                    }
                    this.morphNormals.push(P)
                  }
                  for (var z = t.skinWeights, F = 0, H = z.length; F < H; F++)
                    this.skinWeights.push(z[F].clone())
                  for (var G = t.skinIndices, k = 0, V = G.length; k < V; k++)
                    this.skinIndices.push(G[k].clone())
                  for (var j = t.lineDistances, W = 0, q = j.length; W < q; W++)
                    this.lineDistances.push(j[W])
                  var X = t.boundingBox
                  null !== X && (this.boundingBox = X.clone())
                  var Y = t.boundingSphere
                  return (
                    null !== Y && (this.boundingSphere = Y.clone()),
                    (this.elementsNeedUpdate = t.elementsNeedUpdate),
                    (this.verticesNeedUpdate = t.verticesNeedUpdate),
                    (this.uvsNeedUpdate = t.uvsNeedUpdate),
                    (this.normalsNeedUpdate = t.normalsNeedUpdate),
                    (this.colorsNeedUpdate = t.colorsNeedUpdate),
                    (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
                    (this.groupsNeedUpdate = t.groupsNeedUpdate),
                    this
                  )
                },
                dispose: function () {
                  this.dispatchEvent({ type: 'dispose' })
                },
              })
              var Si = (function (o) {
                  function t(t, e, n, r, i, a) {
                    o.call(this),
                      (this.type = 'BoxGeometry'),
                      (this.parameters = {
                        width: t,
                        height: e,
                        depth: n,
                        widthSegments: r,
                        heightSegments: i,
                        depthSegments: a,
                      }),
                      this.fromBufferGeometry(new Ei(t, e, n, r, i, a)),
                      this.mergeVertices()
                  }
                  return (
                    o && (t.__proto__ = o),
                    ((t.prototype = Object.create(
                      o && o.prototype,
                    )).constructor = t)
                  )
                })(Mi),
                Ei = (function (s) {
                  function t(t, e, n, r, i, a) {
                    s.call(this),
                      (this.type = 'BoxBufferGeometry'),
                      (this.parameters = {
                        width: t,
                        height: e,
                        depth: n,
                        widthSegments: r,
                        heightSegments: i,
                        depthSegments: a,
                      })
                    var P = this
                    ;(t = t || 1),
                      (e = e || 1),
                      (n = n || 1),
                      (r = Math.floor(r) || 1),
                      (i = Math.floor(i) || 1),
                      (a = Math.floor(a) || 1)
                    var O = [],
                      I = [],
                      D = [],
                      B = [],
                      N = 0,
                      U = 0
                    function o(t, e, n, r, i, a, o, s, c, l, h) {
                      for (
                        var u = a / c,
                          p = o / l,
                          d = a / 2,
                          f = o / 2,
                          m = s / 2,
                          v = c + 1,
                          g = l + 1,
                          y = 0,
                          x = 0,
                          b = new on(),
                          _ = 0;
                        _ < g;
                        _++
                      )
                        for (var w = _ * p - f, M = 0; M < v; M++) {
                          var S = M * u - d
                          ;(b[t] = S * r),
                            (b[e] = w * i),
                            (b[n] = m),
                            I.push(b.x, b.y, b.z),
                            (b[t] = 0),
                            (b[e] = 0),
                            (b[n] = 0 < s ? 1 : -1),
                            D.push(b.x, b.y, b.z),
                            B.push(M / c),
                            B.push(1 - _ / l),
                            (y += 1)
                        }
                      for (var E = 0; E < l; E++)
                        for (var T = 0; T < c; T++) {
                          var A = N + T + v * E,
                            L = N + T + v * (E + 1),
                            R = N + (T + 1) + v * (E + 1),
                            C = N + (T + 1) + v * E
                          O.push(A, L, C), O.push(L, R, C), (x += 6)
                        }
                      P.addGroup(U, x, h), (U += x), (N += y)
                    }
                    o('z', 'y', 'x', -1, -1, n, e, t, a, i, 0),
                      o('z', 'y', 'x', 1, -1, n, e, -t, a, i, 1),
                      o('x', 'z', 'y', 1, 1, t, n, e, r, a, 2),
                      o('x', 'z', 'y', 1, -1, t, n, -e, r, a, 3),
                      o('x', 'y', 'z', 1, -1, t, e, n, r, i, 4),
                      o('x', 'y', 'z', -1, -1, t, e, -n, r, i, 5),
                      this.setIndex(O),
                      this.setAttribute('position', new Gr(I, 3)),
                      this.setAttribute('normal', new Gr(D, 3)),
                      this.setAttribute('uv', new Gr(B, 2))
                  }
                  return (
                    s && (t.__proto__ = s),
                    ((t.prototype = Object.create(
                      s && s.prototype,
                    )).constructor = t)
                  )
                })(Kr)
              function Ti(t) {
                var e = {}
                for (var n in t)
                  for (var r in ((e[n] = {}), t[n])) {
                    var i = t[n][r]
                    i &&
                    (i.isColor ||
                      i.isMatrix3 ||
                      i.isMatrix4 ||
                      i.isVector2 ||
                      i.isVector3 ||
                      i.isVector4 ||
                      i.isTexture)
                      ? (e[n][r] = i.clone())
                      : Array.isArray(i)
                        ? (e[n][r] = i.slice())
                        : (e[n][r] = i)
                  }
                return e
              }
              function Ai(t) {
                for (var e = {}, n = 0; n < t.length; n++) {
                  var r = Ti(t[n])
                  for (var i in r) e[i] = r[i]
                }
                return e
              }
              var Li = { clone: Ti, merge: Ai },
                Ri =
                  'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}',
                Ci =
                  'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'
              function Pi(t) {
                Rr.call(this),
                  (this.type = 'ShaderMaterial'),
                  (this.defines = {}),
                  (this.uniforms = {}),
                  (this.vertexShader = Ri),
                  (this.fragmentShader = Ci),
                  (this.linewidth = 1),
                  (this.wireframe = !1),
                  (this.wireframeLinewidth = 1),
                  (this.fog = !1),
                  (this.lights = !1),
                  (this.clipping = !1),
                  (this.skinning = !1),
                  (this.morphTargets = !1),
                  (this.morphNormals = !1),
                  (this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1,
                  }),
                  (this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0],
                  }),
                  (this.index0AttributeName = void 0),
                  (this.uniformsNeedUpdate = !1),
                  void 0 !== t &&
                    (void 0 !== t.attributes &&
                      console.error(
                        'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.',
                      ),
                    this.setValues(t))
              }
              function Oi() {
                On.call(this),
                  (this.type = 'Camera'),
                  (this.matrixWorldInverse = new fn()),
                  (this.projectionMatrix = new fn()),
                  (this.projectionMatrixInverse = new fn())
              }
              function Ii(t, e, n, r) {
                Oi.call(this),
                  (this.type = 'PerspectiveCamera'),
                  (this.fov = void 0 !== t ? t : 50),
                  (this.zoom = 1),
                  (this.near = void 0 !== n ? n : 0.1),
                  (this.far = void 0 !== r ? r : 2e3),
                  (this.focus = 10),
                  (this.aspect = void 0 !== e ? e : 1),
                  (this.view = null),
                  (this.filmGauge = 35),
                  (this.filmOffset = 0),
                  this.updateProjectionMatrix()
              }
              ;(((Pi.prototype = Object.create(Rr.prototype)).constructor =
                Pi).prototype.isShaderMaterial = !0),
                (Pi.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    (this.fragmentShader = t.fragmentShader),
                    (this.vertexShader = t.vertexShader),
                    (this.uniforms = Ti(t.uniforms)),
                    (this.defines = Object.assign({}, t.defines)),
                    (this.wireframe = t.wireframe),
                    (this.wireframeLinewidth = t.wireframeLinewidth),
                    (this.lights = t.lights),
                    (this.clipping = t.clipping),
                    (this.skinning = t.skinning),
                    (this.morphTargets = t.morphTargets),
                    (this.morphNormals = t.morphNormals),
                    (this.extensions = Object.assign({}, t.extensions)),
                    this
                  )
                }),
                (Pi.prototype.toJSON = function (t) {
                  var e = Rr.prototype.toJSON.call(this, t)
                  for (var n in ((e.uniforms = {}), this.uniforms)) {
                    var r = this.uniforms[n].value
                    r && r.isTexture
                      ? (e.uniforms[n] = { type: 't', value: r.toJSON(t).uuid })
                      : r && r.isColor
                        ? (e.uniforms[n] = { type: 'c', value: r.getHex() })
                        : r && r.isVector2
                          ? (e.uniforms[n] = { type: 'v2', value: r.toArray() })
                          : r && r.isVector3
                            ? (e.uniforms[n] = {
                                type: 'v3',
                                value: r.toArray(),
                              })
                            : r && r.isVector4
                              ? (e.uniforms[n] = {
                                  type: 'v4',
                                  value: r.toArray(),
                                })
                              : r && r.isMatrix3
                                ? (e.uniforms[n] = {
                                    type: 'm3',
                                    value: r.toArray(),
                                  })
                                : r && r.isMatrix4
                                  ? (e.uniforms[n] = {
                                      type: 'm4',
                                      value: r.toArray(),
                                    })
                                  : (e.uniforms[n] = { value: r })
                  }
                  0 < Object.keys(this.defines).length &&
                    (e.defines = this.defines),
                    (e.vertexShader = this.vertexShader),
                    (e.fragmentShader = this.fragmentShader)
                  var i = {}
                  for (var a in this.extensions)
                    !0 === this.extensions[a] && (i[a] = !0)
                  return 0 < Object.keys(i).length && (e.extensions = i), e
                }),
                (Oi.prototype = Object.assign(Object.create(On.prototype), {
                  constructor: Oi,
                  isCamera: !0,
                  copy: function (t, e) {
                    return (
                      On.prototype.copy.call(this, t, e),
                      this.matrixWorldInverse.copy(t.matrixWorldInverse),
                      this.projectionMatrix.copy(t.projectionMatrix),
                      this.projectionMatrixInverse.copy(
                        t.projectionMatrixInverse,
                      ),
                      this
                    )
                  },
                  getWorldDirection: function (t) {
                    void 0 === t &&
                      (console.warn(
                        'THREE.Camera: .getWorldDirection() target is now required',
                      ),
                      (t = new on())),
                      this.updateMatrixWorld(!0)
                    var e = this.matrixWorld.elements
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                  },
                  updateMatrixWorld: function (t) {
                    On.prototype.updateMatrixWorld.call(this, t),
                      this.matrixWorldInverse.getInverse(this.matrixWorld)
                  },
                  updateWorldMatrix: function (t, e) {
                    On.prototype.updateWorldMatrix.call(this, t, e),
                      this.matrixWorldInverse.getInverse(this.matrixWorld)
                  },
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                })),
                (Ii.prototype = Object.assign(Object.create(Oi.prototype), {
                  constructor: Ii,
                  isPerspectiveCamera: !0,
                  copy: function (t, e) {
                    return (
                      Oi.prototype.copy.call(this, t, e),
                      (this.fov = t.fov),
                      (this.zoom = t.zoom),
                      (this.near = t.near),
                      (this.far = t.far),
                      (this.focus = t.focus),
                      (this.aspect = t.aspect),
                      (this.view =
                        null === t.view ? null : Object.assign({}, t.view)),
                      (this.filmGauge = t.filmGauge),
                      (this.filmOffset = t.filmOffset),
                      this
                    )
                  },
                  setFocalLength: function (t) {
                    var e = (0.5 * this.getFilmHeight()) / t
                    ;(this.fov = 2 * Xe.RAD2DEG * Math.atan(e)),
                      this.updateProjectionMatrix()
                  },
                  getFocalLength: function () {
                    var t = Math.tan(0.5 * Xe.DEG2RAD * this.fov)
                    return (0.5 * this.getFilmHeight()) / t
                  },
                  getEffectiveFOV: function () {
                    return (
                      2 *
                      Xe.RAD2DEG *
                      Math.atan(
                        Math.tan(0.5 * Xe.DEG2RAD * this.fov) / this.zoom,
                      )
                    )
                  },
                  getFilmWidth: function () {
                    return this.filmGauge * Math.min(this.aspect, 1)
                  },
                  getFilmHeight: function () {
                    return this.filmGauge / Math.max(this.aspect, 1)
                  },
                  setViewOffset: function (t, e, n, r, i, a) {
                    ;(this.aspect = t / e),
                      null === this.view &&
                        (this.view = {
                          enabled: !0,
                          fullWidth: 1,
                          fullHeight: 1,
                          offsetX: 0,
                          offsetY: 0,
                          width: 1,
                          height: 1,
                        }),
                      (this.view.enabled = !0),
                      (this.view.fullWidth = t),
                      (this.view.fullHeight = e),
                      (this.view.offsetX = n),
                      (this.view.offsetY = r),
                      (this.view.width = i),
                      (this.view.height = a),
                      this.updateProjectionMatrix()
                  },
                  clearViewOffset: function () {
                    null !== this.view && (this.view.enabled = !1),
                      this.updateProjectionMatrix()
                  },
                  updateProjectionMatrix: function () {
                    var t,
                      e,
                      n = this.near,
                      r =
                        (n * Math.tan(0.5 * Xe.DEG2RAD * this.fov)) / this.zoom,
                      i = 2 * r,
                      a = this.aspect * i,
                      o = -0.5 * a,
                      s = this.view
                    null !== this.view &&
                      this.view.enabled &&
                      ((t = s.fullWidth),
                      (e = s.fullHeight),
                      (o += (s.offsetX * a) / t),
                      (r -= (s.offsetY * i) / e),
                      (a *= s.width / t),
                      (i *= s.height / e))
                    var c = this.filmOffset
                    0 !== c && (o += (n * c) / this.getFilmWidth()),
                      this.projectionMatrix.makePerspective(
                        o,
                        o + a,
                        r,
                        r - i,
                        n,
                        this.far,
                      ),
                      this.projectionMatrixInverse.getInverse(
                        this.projectionMatrix,
                      )
                  },
                  toJSON: function (t) {
                    var e = On.prototype.toJSON.call(this, t)
                    return (
                      (e.object.fov = this.fov),
                      (e.object.zoom = this.zoom),
                      (e.object.near = this.near),
                      (e.object.far = this.far),
                      (e.object.focus = this.focus),
                      (e.object.aspect = this.aspect),
                      null !== this.view &&
                        (e.object.view = Object.assign({}, this.view)),
                      (e.object.filmGauge = this.filmGauge),
                      (e.object.filmOffset = this.filmOffset),
                      e
                    )
                  },
                }))
              function Di(t, e, o) {
                var a, s, c, l, h, u
                On.call(this),
                  (this.type = 'CubeCamera'),
                  !0 === o.isWebGLCubeRenderTarget
                    ? ((this.renderTarget = o),
                      ((a = new Ii(90, 1, t, e)).layers = this.layers),
                      a.up.set(0, -1, 0),
                      a.lookAt(new on(1, 0, 0)),
                      this.add(a),
                      ((s = new Ii(90, 1, t, e)).layers = this.layers),
                      s.up.set(0, -1, 0),
                      s.lookAt(new on(-1, 0, 0)),
                      this.add(s),
                      ((c = new Ii(90, 1, t, e)).layers = this.layers),
                      c.up.set(0, 0, 1),
                      c.lookAt(new on(0, 1, 0)),
                      this.add(c),
                      ((l = new Ii(90, 1, t, e)).layers = this.layers),
                      l.up.set(0, 0, -1),
                      l.lookAt(new on(0, -1, 0)),
                      this.add(l),
                      ((h = new Ii(90, 1, t, e)).layers = this.layers),
                      h.up.set(0, -1, 0),
                      h.lookAt(new on(0, 0, 1)),
                      this.add(h),
                      ((u = new Ii(90, 1, t, e)).layers = this.layers),
                      u.up.set(0, -1, 0),
                      u.lookAt(new on(0, 0, -1)),
                      this.add(u),
                      (this.update = function (t, e) {
                        null === this.parent && this.updateMatrixWorld()
                        var n = t.xr.enabled,
                          r = t.getRenderTarget()
                        t.xr.enabled = !1
                        var i = o.texture.generateMipmaps
                        ;(o.texture.generateMipmaps = !1),
                          t.setRenderTarget(o, 0),
                          t.render(e, a),
                          t.setRenderTarget(o, 1),
                          t.render(e, s),
                          t.setRenderTarget(o, 2),
                          t.render(e, c),
                          t.setRenderTarget(o, 3),
                          t.render(e, l),
                          t.setRenderTarget(o, 4),
                          t.render(e, h),
                          (o.texture.generateMipmaps = i),
                          t.setRenderTarget(o, 5),
                          t.render(e, u),
                          t.setRenderTarget(r),
                          (t.xr.enabled = n)
                      }),
                      (this.clear = function (t, e, n, r) {
                        for (var i = t.getRenderTarget(), a = 0; a < 6; a++)
                          t.setRenderTarget(o, a), t.clear(e, n, r)
                        t.setRenderTarget(i)
                      }))
                    : console.error(
                        'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.',
                      )
              }
              function Bi(t, e, n) {
                Number.isInteger(e) &&
                  (console.warn(
                    'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )',
                  ),
                  (e = n)),
                  tn.call(this, t, t, e)
              }
              function Ni(t, e, n, r, i, a, o, s, c, l, h, u) {
                Ke.call(this, null, a, o, s, c, l, r, i, h, u),
                  (this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1,
                  }),
                  (this.magFilter = void 0 !== c ? c : Ht),
                  (this.minFilter = void 0 !== l ? l : Ht),
                  (this.generateMipmaps = !1),
                  (this.flipY = !1),
                  (this.unpackAlignment = 1),
                  (this.needsUpdate = !0)
              }
              ;((Di.prototype = Object.create(On.prototype)).constructor = Di),
                (((Bi.prototype = Object.create(tn.prototype)).constructor =
                  Bi).prototype.isWebGLCubeRenderTarget = !0),
                (Bi.prototype.fromEquirectangularTexture = function (t, e) {
                  ;(this.texture.type = e.type),
                    (this.texture.format = e.format),
                    (this.texture.encoding = e.encoding)
                  var n = new In(),
                    r = {
                      uniforms: { tEquirect: { value: null } },
                      vertexShader: [
                        'varying vec3 vWorldDirection;',
                        'vec3 transformDirection( in vec3 dir, in mat4 matrix ) {',
                        '\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );',
                        '}',
                        'void main() {',
                        '\tvWorldDirection = transformDirection( position, modelMatrix );',
                        '\t#include <begin_vertex>',
                        '\t#include <project_vertex>',
                        '}',
                      ].join('\n'),
                      fragmentShader: [
                        'uniform sampler2D tEquirect;',
                        'varying vec3 vWorldDirection;',
                        '#include <common>',
                        'void main() {',
                        '\tvec3 direction = normalize( vWorldDirection );',
                        '\tvec2 sampleUV = equirectUv( direction );',
                        '\tgl_FragColor = texture2D( tEquirect, sampleUV );',
                        '}',
                      ].join('\n'),
                    },
                    i = new Pi({
                      name: 'CubemapFromEquirect',
                      uniforms: Ti(r.uniforms),
                      vertexShader: r.vertexShader,
                      fragmentShader: r.fragmentShader,
                      side: q,
                      blending: Y,
                    })
                  i.uniforms.tEquirect.value = e
                  var a = new vi(new Ei(5, 5, 5), i)
                  return (
                    n.add(a),
                    new Di(1, 10, this).update(t, n),
                    a.geometry.dispose(),
                    a.material.dispose(),
                    this
                  )
                }),
                (((Ni.prototype = Object.create(Ke.prototype)).constructor =
                  Ni).prototype.isDataTexture = !0)
              var Ui = new Jn(),
                zi = new on()
              function Fi(t, e, n, r, i, a) {
                this.planes = [
                  void 0 !== t ? t : new cr(),
                  void 0 !== e ? e : new cr(),
                  void 0 !== n ? n : new cr(),
                  void 0 !== r ? r : new cr(),
                  void 0 !== i ? i : new cr(),
                  void 0 !== a ? a : new cr(),
                ]
              }
              Object.assign(Fi.prototype, {
                set: function (t, e, n, r, i, a) {
                  var o = this.planes
                  return (
                    o[0].copy(t),
                    o[1].copy(e),
                    o[2].copy(n),
                    o[3].copy(r),
                    o[4].copy(i),
                    o[5].copy(a),
                    this
                  )
                },
                clone: function () {
                  return new this.constructor().copy(this)
                },
                copy: function (t) {
                  for (var e = this.planes, n = 0; n < 6; n++)
                    e[n].copy(t.planes[n])
                  return this
                },
                setFromProjectionMatrix: function (t) {
                  var e = this.planes,
                    n = t.elements,
                    r = n[0],
                    i = n[1],
                    a = n[2],
                    o = n[3],
                    s = n[4],
                    c = n[5],
                    l = n[6],
                    h = n[7],
                    u = n[8],
                    p = n[9],
                    d = n[10],
                    f = n[11],
                    m = n[12],
                    v = n[13],
                    g = n[14],
                    y = n[15]
                  return (
                    e[0].setComponents(o - r, h - s, f - u, y - m).normalize(),
                    e[1].setComponents(o + r, h + s, f + u, y + m).normalize(),
                    e[2].setComponents(o + i, h + c, f + p, y + v).normalize(),
                    e[3].setComponents(o - i, h - c, f - p, y - v).normalize(),
                    e[4].setComponents(o - a, h - l, f - d, y - g).normalize(),
                    e[5].setComponents(o + a, h + l, f + d, y + g).normalize(),
                    this
                  )
                },
                intersectsObject: function (t) {
                  var e = t.geometry
                  return (
                    null === e.boundingSphere && e.computeBoundingSphere(),
                    Ui.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
                    this.intersectsSphere(Ui)
                  )
                },
                intersectsSprite: function (t) {
                  return (
                    Ui.center.set(0, 0, 0),
                    (Ui.radius = 0.7071067811865476),
                    Ui.applyMatrix4(t.matrixWorld),
                    this.intersectsSphere(Ui)
                  )
                },
                intersectsSphere: function (t) {
                  for (
                    var e = this.planes, n = t.center, r = -t.radius, i = 0;
                    i < 6;
                    i++
                  ) {
                    if (e[i].distanceToPoint(n) < r) return !1
                  }
                  return !0
                },
                intersectsBox: function (t) {
                  for (var e = this.planes, n = 0; n < 6; n++) {
                    var r = e[n]
                    if (
                      ((zi.x = 0 < r.normal.x ? t.max.x : t.min.x),
                      (zi.y = 0 < r.normal.y ? t.max.y : t.min.y),
                      (zi.z = 0 < r.normal.z ? t.max.z : t.min.z),
                      r.distanceToPoint(zi) < 0)
                    )
                      return !1
                  }
                  return !0
                },
                containsPoint: function (t) {
                  for (var e = this.planes, n = 0; n < 6; n++)
                    if (e[n].distanceToPoint(t) < 0) return !1
                  return !0
                },
              })
              var Hi = {
                common: {
                  diffuse: { value: new Mr(15658734) },
                  opacity: { value: 1 },
                  map: { value: null },
                  uvTransform: { value: new Ze() },
                  uv2Transform: { value: new Ze() },
                  alphaMap: { value: null },
                },
                specularmap: { specularMap: { value: null } },
                envmap: {
                  envMap: { value: null },
                  flipEnvMap: { value: -1 },
                  reflectivity: { value: 1 },
                  refractionRatio: { value: 0.98 },
                  maxMipLevel: { value: 0 },
                },
                aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
                lightmap: {
                  lightMap: { value: null },
                  lightMapIntensity: { value: 1 },
                },
                emissivemap: { emissiveMap: { value: null } },
                bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
                normalmap: {
                  normalMap: { value: null },
                  normalScale: { value: new Ye(1, 1) },
                },
                displacementmap: {
                  displacementMap: { value: null },
                  displacementScale: { value: 1 },
                  displacementBias: { value: 0 },
                },
                roughnessmap: { roughnessMap: { value: null } },
                metalnessmap: { metalnessMap: { value: null } },
                gradientmap: { gradientMap: { value: null } },
                fog: {
                  fogDensity: { value: 25e-5 },
                  fogNear: { value: 1 },
                  fogFar: { value: 2e3 },
                  fogColor: { value: new Mr(16777215) },
                },
                lights: {
                  ambientLightColor: { value: [] },
                  lightProbe: { value: [] },
                  directionalLights: {
                    value: [],
                    properties: { direction: {}, color: {} },
                  },
                  directionalLightShadows: {
                    value: [],
                    properties: {
                      shadowBias: {},
                      shadowNormalBias: {},
                      shadowRadius: {},
                      shadowMapSize: {},
                    },
                  },
                  directionalShadowMap: { value: [] },
                  directionalShadowMatrix: { value: [] },
                  spotLights: {
                    value: [],
                    properties: {
                      color: {},
                      position: {},
                      direction: {},
                      distance: {},
                      coneCos: {},
                      penumbraCos: {},
                      decay: {},
                    },
                  },
                  spotLightShadows: {
                    value: [],
                    properties: {
                      shadowBias: {},
                      shadowNormalBias: {},
                      shadowRadius: {},
                      shadowMapSize: {},
                    },
                  },
                  spotShadowMap: { value: [] },
                  spotShadowMatrix: { value: [] },
                  pointLights: {
                    value: [],
                    properties: {
                      color: {},
                      position: {},
                      decay: {},
                      distance: {},
                    },
                  },
                  pointLightShadows: {
                    value: [],
                    properties: {
                      shadowBias: {},
                      shadowNormalBias: {},
                      shadowRadius: {},
                      shadowMapSize: {},
                      shadowCameraNear: {},
                      shadowCameraFar: {},
                    },
                  },
                  pointShadowMap: { value: [] },
                  pointShadowMatrix: { value: [] },
                  hemisphereLights: {
                    value: [],
                    properties: {
                      direction: {},
                      skyColor: {},
                      groundColor: {},
                    },
                  },
                  rectAreaLights: {
                    value: [],
                    properties: {
                      color: {},
                      position: {},
                      width: {},
                      height: {},
                    },
                  },
                },
                points: {
                  diffuse: { value: new Mr(15658734) },
                  opacity: { value: 1 },
                  size: { value: 1 },
                  scale: { value: 1 },
                  map: { value: null },
                  alphaMap: { value: null },
                  uvTransform: { value: new Ze() },
                },
                sprite: {
                  diffuse: { value: new Mr(15658734) },
                  opacity: { value: 1 },
                  center: { value: new Ye(0.5, 0.5) },
                  rotation: { value: 0 },
                  map: { value: null },
                  alphaMap: { value: null },
                  uvTransform: { value: new Ze() },
                },
              }
              function Gi() {
                var n = null,
                  t = !1,
                  r = null,
                  i = null
                function a(t, e) {
                  r(t, e), (i = n.requestAnimationFrame(a))
                }
                return {
                  start: function () {
                    !0 !== t &&
                      null !== r &&
                      ((i = n.requestAnimationFrame(a)), (t = !0))
                  },
                  stop: function () {
                    n.cancelAnimationFrame(i), (t = !1)
                  },
                  setAnimationLoop: function (t) {
                    r = t
                  },
                  setContext: function (t) {
                    n = t
                  },
                }
              }
              function ki(c, t) {
                var l = t.isWebGL2,
                  h = new WeakMap()
                return {
                  get: function (t) {
                    return (
                      t.isInterleavedBufferAttribute && (t = t.data), h.get(t)
                    )
                  },
                  remove: function (t) {
                    t.isInterleavedBufferAttribute && (t = t.data)
                    var e = h.get(t)
                    e && (c.deleteBuffer(e.buffer), h.delete(t))
                  },
                  update: function (t, e) {
                    t.isInterleavedBufferAttribute && (t = t.data)
                    var n,
                      r,
                      i,
                      a,
                      o,
                      s = h.get(t)
                    void 0 === s
                      ? h.set(
                          t,
                          (function (t, e) {
                            var n = t.array,
                              r = t.usage,
                              i = c.createBuffer()
                            c.bindBuffer(e, i),
                              c.bufferData(e, n, r),
                              t.onUploadCallback()
                            var a = 5126
                            return (
                              n instanceof Float32Array
                                ? (a = 5126)
                                : n instanceof Float64Array
                                  ? console.warn(
                                      'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.',
                                    )
                                  : n instanceof Uint16Array
                                    ? (a = 5123)
                                    : n instanceof Int16Array
                                      ? (a = 5122)
                                      : n instanceof Uint32Array
                                        ? (a = 5125)
                                        : n instanceof Int32Array
                                          ? (a = 5124)
                                          : n instanceof Int8Array
                                            ? (a = 5120)
                                            : n instanceof Uint8Array &&
                                              (a = 5121),
                              {
                                buffer: i,
                                type: a,
                                bytesPerElement: n.BYTES_PER_ELEMENT,
                                version: t.version,
                              }
                            )
                          })(t, e),
                        )
                      : s.version < t.version &&
                        ((n = s.buffer),
                        (i = e),
                        (a = (r = t).array),
                        (o = r.updateRange),
                        c.bindBuffer(i, n),
                        -1 === o.count
                          ? c.bufferSubData(i, 0, a)
                          : (l
                              ? c.bufferSubData(
                                  i,
                                  o.offset * a.BYTES_PER_ELEMENT,
                                  a,
                                  o.offset,
                                  o.count,
                                )
                              : c.bufferSubData(
                                  i,
                                  o.offset * a.BYTES_PER_ELEMENT,
                                  a.subarray(o.offset, o.offset + o.count),
                                ),
                            (o.count = -1)),
                        (s.version = t.version))
                  },
                }
              }
              function Vi(t, e, n, r) {
                Mi.call(this),
                  (this.type = 'PlaneGeometry'),
                  (this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: r,
                  }),
                  this.fromBufferGeometry(new ji(t, e, n, r)),
                  this.mergeVertices()
              }
              function ji(t, e, n, r) {
                Kr.call(this),
                  (this.type = 'PlaneBufferGeometry'),
                  (this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: r,
                  })
                for (
                  var i = (t = t || 1) / 2,
                    a = (e = e || 1) / 2,
                    o = Math.floor(n) || 1,
                    s = Math.floor(r) || 1,
                    c = o + 1,
                    l = s + 1,
                    h = t / o,
                    u = e / s,
                    p = [],
                    d = [],
                    f = [],
                    m = [],
                    v = 0;
                  v < l;
                  v++
                )
                  for (var g = v * u - a, y = 0; y < c; y++) {
                    var x = y * h - i
                    d.push(x, -g, 0),
                      f.push(0, 0, 1),
                      m.push(y / o),
                      m.push(1 - v / s)
                  }
                for (var b = 0; b < s; b++)
                  for (var _ = 0; _ < o; _++) {
                    var w = _ + c * b,
                      M = _ + c * (b + 1),
                      S = _ + 1 + c * (b + 1),
                      E = _ + 1 + c * b
                    p.push(w, M, E), p.push(M, S, E)
                  }
                this.setIndex(p),
                  this.setAttribute('position', new Gr(d, 3)),
                  this.setAttribute('normal', new Gr(f, 3)),
                  this.setAttribute('uv', new Gr(m, 2))
              }
              ;((Vi.prototype = Object.create(Mi.prototype)).constructor = Vi),
                ((ji.prototype = Object.create(Kr.prototype)).constructor = ji)
              var Wi = {
                  alphamap_fragment:
                    '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif',
                  alphamap_pars_fragment:
                    '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
                  alphatest_fragment:
                    '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif',
                  aomap_fragment:
                    '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif',
                  aomap_pars_fragment:
                    '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
                  begin_vertex: 'vec3 transformed = vec3( position );',
                  beginnormal_vertex:
                    'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif',
                  bsdfs:
                    'vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif',
                  bumpmap_pars_fragment:
                    '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif',
                  clipping_planes_fragment:
                    '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif',
                  clipping_planes_pars_fragment:
                    '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
                  clipping_planes_pars_vertex:
                    '#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif',
                  clipping_planes_vertex:
                    '#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif',
                  color_fragment:
                    '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif',
                  color_pars_fragment:
                    '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
                  color_pars_vertex:
                    '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
                  color_vertex:
                    '#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif',
                  common:
                    '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}',
                  cube_uv_reflection_fragment:
                    '#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif',
                  defaultnormal_vertex:
                    'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif',
                  displacementmap_pars_vertex:
                    '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif',
                  displacementmap_vertex:
                    '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif',
                  emissivemap_fragment:
                    '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
                  emissivemap_pars_fragment:
                    '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif',
                  encodings_fragment:
                    'gl_FragColor = linearToOutputTexel( gl_FragColor );',
                  encodings_pars_fragment:
                    '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}',
                  envmap_fragment:
                    '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif',
                  envmap_common_pars_fragment:
                    '#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif',
                  envmap_pars_fragment:
                    '#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif',
                  envmap_pars_vertex:
                    '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif',
                  envmap_physical_pars_fragment:
                    '#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif',
                  envmap_vertex:
                    '#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif',
                  fog_vertex:
                    '#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif',
                  fog_pars_vertex:
                    '#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif',
                  fog_fragment:
                    '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
                  fog_pars_fragment:
                    '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif',
                  gradientmap_pars_fragment:
                    '#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}',
                  lightmap_fragment:
                    '#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif',
                  lightmap_pars_fragment:
                    '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
                  lights_lambert_vertex:
                    'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif',
                  lights_pars_begin:
                    'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif',
                  lights_toon_fragment:
                    'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
                  lights_toon_pars_fragment:
                    'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)',
                  lights_phong_fragment:
                    'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
                  lights_phong_pars_fragment:
                    'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)',
                  lights_physical_fragment:
                    'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif',
                  lights_physical_pars_fragment:
                    'struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
                  lights_fragment_begin:
                    '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
                  lights_fragment_maps:
                    '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif',
                  lights_fragment_end:
                    '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif',
                  logdepthbuf_fragment:
                    '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
                  logdepthbuf_pars_fragment:
                    '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif',
                  logdepthbuf_pars_vertex:
                    '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif',
                  logdepthbuf_vertex:
                    '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif',
                  map_fragment:
                    '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif',
                  map_pars_fragment:
                    '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif',
                  map_particle_fragment:
                    '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
                  map_particle_pars_fragment:
                    '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif',
                  metalnessmap_fragment:
                    'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif',
                  metalnessmap_pars_fragment:
                    '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
                  morphnormal_vertex:
                    '#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif',
                  morphtarget_pars_vertex:
                    '#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
                  morphtarget_vertex:
                    '#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif',
                  normal_fragment_begin:
                    '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;',
                  normal_fragment_maps:
                    '#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif',
                  normalmap_pars_fragment:
                    '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif',
                  clearcoat_normal_fragment_begin:
                    '#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif',
                  clearcoat_normal_fragment_maps:
                    '#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif',
                  clearcoat_pars_fragment:
                    '#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif',
                  packing:
                    'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}',
                  premultiplied_alpha_fragment:
                    '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif',
                  project_vertex:
                    'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
                  dithering_fragment:
                    '#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
                  dithering_pars_fragment:
                    '#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif',
                  roughnessmap_fragment:
                    'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif',
                  roughnessmap_pars_fragment:
                    '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
                  shadowmap_pars_fragment:
                    '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif',
                  shadowmap_pars_vertex:
                    '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif',
                  shadowmap_vertex:
                    '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif',
                  shadowmask_pars_fragment:
                    'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}',
                  skinbase_vertex:
                    '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
                  skinning_pars_vertex:
                    '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif',
                  skinning_vertex:
                    '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
                  skinnormal_vertex:
                    '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif',
                  specularmap_fragment:
                    'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
                  specularmap_pars_fragment:
                    '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
                  tonemapping_fragment:
                    '#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
                  tonemapping_pars_fragment:
                    '#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
                  uv_pars_fragment:
                    '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif',
                  uv_pars_vertex:
                    '#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif',
                  uv_vertex:
                    '#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
                  uv2_pars_fragment:
                    '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
                  uv2_pars_vertex:
                    '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif',
                  uv2_vertex:
                    '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif',
                  worldpos_vertex:
                    '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif',
                  background_frag:
                    'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
                  background_vert:
                    'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
                  cube_frag:
                    '#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
                  cube_vert:
                    'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}',
                  depth_frag:
                    '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}',
                  depth_vert:
                    '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}',
                  distanceRGBA_frag:
                    '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}',
                  distanceRGBA_vert:
                    '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}',
                  equirect_frag:
                    'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}',
                  equirect_vert:
                    'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}',
                  linedashed_frag:
                    'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
                  linedashed_vert:
                    'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
                  meshbasic_frag:
                    'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                  meshbasic_vert:
                    '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}',
                  meshlambert_frag:
                    'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                  meshlambert_vert:
                    '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                  meshmatcap_frag:
                    '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                  meshmatcap_vert:
                    '#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}',
                  meshtoon_frag:
                    '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                  meshtoon_vert:
                    '#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                  meshphong_frag:
                    '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                  meshphong_vert:
                    '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                  meshphysical_frag:
                    '#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}',
                  meshphysical_vert:
                    '#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                  normal_frag:
                    '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}',
                  normal_vert:
                    '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}',
                  points_frag:
                    'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}',
                  points_vert:
                    'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}',
                  shadow_frag:
                    'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
                  shadow_vert:
                    '#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}',
                  sprite_frag:
                    'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}',
                  sprite_vert:
                    'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}',
                },
                qi = {
                  basic: {
                    uniforms: Ai([
                      Hi.common,
                      Hi.specularmap,
                      Hi.envmap,
                      Hi.aomap,
                      Hi.lightmap,
                      Hi.fog,
                    ]),
                    vertexShader: Wi.meshbasic_vert,
                    fragmentShader: Wi.meshbasic_frag,
                  },
                  lambert: {
                    uniforms: Ai([
                      Hi.common,
                      Hi.specularmap,
                      Hi.envmap,
                      Hi.aomap,
                      Hi.lightmap,
                      Hi.emissivemap,
                      Hi.fog,
                      Hi.lights,
                      { emissive: { value: new Mr(0) } },
                    ]),
                    vertexShader: Wi.meshlambert_vert,
                    fragmentShader: Wi.meshlambert_frag,
                  },
                  phong: {
                    uniforms: Ai([
                      Hi.common,
                      Hi.specularmap,
                      Hi.envmap,
                      Hi.aomap,
                      Hi.lightmap,
                      Hi.emissivemap,
                      Hi.bumpmap,
                      Hi.normalmap,
                      Hi.displacementmap,
                      Hi.fog,
                      Hi.lights,
                      {
                        emissive: { value: new Mr(0) },
                        specular: { value: new Mr(1118481) },
                        shininess: { value: 30 },
                      },
                    ]),
                    vertexShader: Wi.meshphong_vert,
                    fragmentShader: Wi.meshphong_frag,
                  },
                  standard: {
                    uniforms: Ai([
                      Hi.common,
                      Hi.envmap,
                      Hi.aomap,
                      Hi.lightmap,
                      Hi.emissivemap,
                      Hi.bumpmap,
                      Hi.normalmap,
                      Hi.displacementmap,
                      Hi.roughnessmap,
                      Hi.metalnessmap,
                      Hi.fog,
                      Hi.lights,
                      {
                        emissive: { value: new Mr(0) },
                        roughness: { value: 1 },
                        metalness: { value: 0 },
                        envMapIntensity: { value: 1 },
                      },
                    ]),
                    vertexShader: Wi.meshphysical_vert,
                    fragmentShader: Wi.meshphysical_frag,
                  },
                  toon: {
                    uniforms: Ai([
                      Hi.common,
                      Hi.aomap,
                      Hi.lightmap,
                      Hi.emissivemap,
                      Hi.bumpmap,
                      Hi.normalmap,
                      Hi.displacementmap,
                      Hi.gradientmap,
                      Hi.fog,
                      Hi.lights,
                      { emissive: { value: new Mr(0) } },
                    ]),
                    vertexShader: Wi.meshtoon_vert,
                    fragmentShader: Wi.meshtoon_frag,
                  },
                  matcap: {
                    uniforms: Ai([
                      Hi.common,
                      Hi.bumpmap,
                      Hi.normalmap,
                      Hi.displacementmap,
                      Hi.fog,
                      { matcap: { value: null } },
                    ]),
                    vertexShader: Wi.meshmatcap_vert,
                    fragmentShader: Wi.meshmatcap_frag,
                  },
                  points: {
                    uniforms: Ai([Hi.points, Hi.fog]),
                    vertexShader: Wi.points_vert,
                    fragmentShader: Wi.points_frag,
                  },
                  dashed: {
                    uniforms: Ai([
                      Hi.common,
                      Hi.fog,
                      {
                        scale: { value: 1 },
                        dashSize: { value: 1 },
                        totalSize: { value: 2 },
                      },
                    ]),
                    vertexShader: Wi.linedashed_vert,
                    fragmentShader: Wi.linedashed_frag,
                  },
                  depth: {
                    uniforms: Ai([Hi.common, Hi.displacementmap]),
                    vertexShader: Wi.depth_vert,
                    fragmentShader: Wi.depth_frag,
                  },
                  normal: {
                    uniforms: Ai([
                      Hi.common,
                      Hi.bumpmap,
                      Hi.normalmap,
                      Hi.displacementmap,
                      { opacity: { value: 1 } },
                    ]),
                    vertexShader: Wi.normal_vert,
                    fragmentShader: Wi.normal_frag,
                  },
                  sprite: {
                    uniforms: Ai([Hi.sprite, Hi.fog]),
                    vertexShader: Wi.sprite_vert,
                    fragmentShader: Wi.sprite_frag,
                  },
                  background: {
                    uniforms: {
                      uvTransform: { value: new Ze() },
                      t2D: { value: null },
                    },
                    vertexShader: Wi.background_vert,
                    fragmentShader: Wi.background_frag,
                  },
                  cube: {
                    uniforms: Ai([Hi.envmap, { opacity: { value: 1 } }]),
                    vertexShader: Wi.cube_vert,
                    fragmentShader: Wi.cube_frag,
                  },
                  equirect: {
                    uniforms: { tEquirect: { value: null } },
                    vertexShader: Wi.equirect_vert,
                    fragmentShader: Wi.equirect_frag,
                  },
                  distanceRGBA: {
                    uniforms: Ai([
                      Hi.common,
                      Hi.displacementmap,
                      {
                        referencePosition: { value: new on() },
                        nearDistance: { value: 1 },
                        farDistance: { value: 1e3 },
                      },
                    ]),
                    vertexShader: Wi.distanceRGBA_vert,
                    fragmentShader: Wi.distanceRGBA_frag,
                  },
                  shadow: {
                    uniforms: Ai([
                      Hi.lights,
                      Hi.fog,
                      { color: { value: new Mr(0) }, opacity: { value: 1 } },
                    ]),
                    vertexShader: Wi.shadow_vert,
                    fragmentShader: Wi.shadow_frag,
                  },
                }
              function Xi(c, n, l, r) {
                var h,
                  u,
                  p = new Mr(0),
                  d = 0,
                  f = null,
                  m = 0,
                  v = null
                function g(t, e) {
                  n.buffers.color.setClear(t.r, t.g, t.b, e, r)
                }
                return {
                  getClearColor: function () {
                    return p
                  },
                  setClearColor: function (t, e) {
                    p.set(t), g(p, (d = void 0 !== e ? e : 1))
                  },
                  getClearAlpha: function () {
                    return d
                  },
                  setClearAlpha: function (t) {
                    g(p, (d = t))
                  },
                  render: function (t, e, n, r) {
                    var i,
                      a = !0 === e.isScene ? e.background : null,
                      o = c.xr,
                      s = o.getSession && o.getSession()
                    s && 'additive' === s.environmentBlendMode && (a = null),
                      null === a
                        ? g(p, d)
                        : a && a.isColor && (g(a, 1), (r = !0)),
                      (c.autoClear || r) &&
                        c.clear(
                          c.autoClearColor,
                          c.autoClearDepth,
                          c.autoClearStencil,
                        ),
                      a &&
                      (a.isCubeTexture ||
                        a.isWebGLCubeRenderTarget ||
                        a.mapping === Bt)
                        ? (void 0 === u &&
                            ((u = new vi(
                              new Ei(1, 1, 1),
                              new Pi({
                                name: 'BackgroundCubeMaterial',
                                uniforms: Ti(qi.cube.uniforms),
                                vertexShader: qi.cube.vertexShader,
                                fragmentShader: qi.cube.fragmentShader,
                                side: q,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1,
                              }),
                            )).geometry.deleteAttribute('normal'),
                            u.geometry.deleteAttribute('uv'),
                            (u.onBeforeRender = function (t, e, n) {
                              this.matrixWorld.copyPosition(n.matrixWorld)
                            }),
                            Object.defineProperty(u.material, 'envMap', {
                              get: function () {
                                return this.uniforms.envMap.value
                              },
                            }),
                            l.update(u)),
                          (i = a.isWebGLCubeRenderTarget ? a.texture : a),
                          (u.material.uniforms.envMap.value = i),
                          (u.material.uniforms.flipEnvMap.value =
                            i.isCubeTexture ? -1 : 1),
                          (f === a && m === i.version && v === c.toneMapping) ||
                            ((u.material.needsUpdate = !0),
                            (f = a),
                            (m = i.version),
                            (v = c.toneMapping)),
                          t.unshift(u, u.geometry, u.material, 0, 0, null))
                        : a &&
                          a.isTexture &&
                          (void 0 === h &&
                            ((h = new vi(
                              new ji(2, 2),
                              new Pi({
                                name: 'BackgroundMaterial',
                                uniforms: Ti(qi.background.uniforms),
                                vertexShader: qi.background.vertexShader,
                                fragmentShader: qi.background.fragmentShader,
                                side: O,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1,
                              }),
                            )).geometry.deleteAttribute('normal'),
                            Object.defineProperty(h.material, 'map', {
                              get: function () {
                                return this.uniforms.t2D.value
                              },
                            }),
                            l.update(h)),
                          !0 ===
                            (h.material.uniforms.t2D.value = a)
                              .matrixAutoUpdate && a.updateMatrix(),
                          h.material.uniforms.uvTransform.value.copy(a.matrix),
                          (f === a && m === a.version && v === c.toneMapping) ||
                            ((h.material.needsUpdate = !0),
                            (m = (f = a).version),
                            (v = c.toneMapping)),
                          t.unshift(h, h.geometry, h.material, 0, 0, null))
                  },
                }
              }
              function Yi(M, S, E, T) {
                var a = M.getParameter(34921),
                  c = T.isWebGL2 ? null : S.get('OES_vertex_array_object'),
                  l = T.isWebGL2 || null !== c,
                  h = {},
                  t = d(null),
                  u = t
                function p(t) {
                  return T.isWebGL2
                    ? M.bindVertexArray(t)
                    : c.bindVertexArrayOES(t)
                }
                function o(t) {
                  return T.isWebGL2
                    ? M.deleteVertexArray(t)
                    : c.deleteVertexArrayOES(t)
                }
                function d(t) {
                  for (var e = [], n = [], r = [], i = 0; i < a; i++)
                    (e[i] = 0), (n[i] = 0), (r[i] = 0)
                  return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: e,
                    enabledAttributes: n,
                    attributeDivisors: r,
                    object: t,
                    attributes: {},
                  }
                }
                function A() {
                  for (var t = u.newAttributes, e = 0, n = t.length; e < n; e++)
                    t[e] = 0
                }
                function L(t) {
                  R(t, 0)
                }
                function R(t, e) {
                  var n = u.newAttributes,
                    r = u.enabledAttributes,
                    i = u.attributeDivisors
                  ;(n[t] = 1),
                    0 === r[t] && (M.enableVertexAttribArray(t), (r[t] = 1)),
                    i[t] !== e &&
                      ((T.isWebGL2 ? M : S.get('ANGLE_instanced_arrays'))[
                        T.isWebGL2
                          ? 'vertexAttribDivisor'
                          : 'vertexAttribDivisorANGLE'
                      ](t, e),
                      (i[t] = e))
                }
                function C() {
                  for (
                    var t = u.newAttributes,
                      e = u.enabledAttributes,
                      n = 0,
                      r = e.length;
                    n < r;
                    n++
                  )
                    e[n] !== t[n] && (M.disableVertexAttribArray(n), (e[n] = 0))
                }
                function P(t, e, n, r, i, a) {
                  !0 !== T.isWebGL2 || (5124 !== n && 5125 !== n)
                    ? M.vertexAttribPointer(t, e, n, r, i, a)
                    : M.vertexAttribIPointer(t, e, n, r, i, a)
                }
                function s() {
                  e(), u !== t && p((u = t).object)
                }
                function e() {
                  ;(t.geometry = null), (t.program = null), (t.wireframe = !1)
                }
                return {
                  setup: function (t, e, n, r, i) {
                    var a,
                      o,
                      s = !1
                    l
                      ? ((a = (function (t, e, n) {
                          var r = !0 === n.wireframe,
                            i = h[t.id]
                          void 0 === i && ((i = {}), (h[t.id] = i))
                          var a = i[e.id]
                          void 0 === a && ((a = {}), (i[e.id] = a))
                          var o = a[r]
                          void 0 === o &&
                            ((o = d(
                              (function () {
                                if (T.isWebGL2) return M.createVertexArray()
                                return c.createVertexArrayOES()
                              })(),
                            )),
                            (a[r] = o))
                          return o
                        })(r, n, e)),
                        u !== a && p((u = a).object),
                        (s = (function (t) {
                          var e = u.attributes,
                            n = t.attributes
                          if (Object.keys(e).length !== Object.keys(n).length)
                            return !0
                          for (var r in n) {
                            var i = e[r],
                              a = n[r]
                            if (i.attribute !== a) return !0
                            if (i.data !== a.data) return !0
                          }
                          return !1
                        })(r)) &&
                          (function (t) {
                            var e = {},
                              n = t.attributes
                            for (var r in n) {
                              var i = n[r],
                                a = {}
                              ;(a.attribute = i).data && (a.data = i.data),
                                (e[r] = a)
                            }
                            u.attributes = e
                          })(r))
                      : ((o = !0 === e.wireframe),
                        (u.geometry === r.id &&
                          u.program === n.id &&
                          u.wireframe === o) ||
                          ((u.geometry = r.id),
                          (u.program = n.id),
                          (u.wireframe = o),
                          (s = !0))),
                      !0 === t.isInstancedMesh && (s = !0),
                      null !== i && E.update(i, 34963),
                      s &&
                        ((function (t, e, n, r) {
                          if (
                            !1 === T.isWebGL2 &&
                            (t.isInstancedMesh ||
                              r.isInstancedBufferGeometry) &&
                            null === S.get('ANGLE_instanced_arrays')
                          )
                            return
                          A()
                          var i = r.attributes,
                            a = n.getAttributes(),
                            o = e.defaultAttributeValues
                          for (var s in a) {
                            var c = a[s]
                            if (0 <= c) {
                              var l = i[s]
                              if (void 0 !== l) {
                                var h = l.normalized,
                                  u = l.itemSize,
                                  p = E.get(l)
                                if (void 0 === p) continue
                                var d,
                                  f,
                                  m,
                                  v = p.buffer,
                                  g = p.type,
                                  y = p.bytesPerElement
                                l.isInterleavedBufferAttribute
                                  ? ((d = l.data),
                                    (f = d.stride),
                                    (m = l.offset),
                                    d && d.isInstancedInterleavedBuffer
                                      ? (R(c, d.meshPerAttribute),
                                        void 0 === r._maxInstanceCount &&
                                          (r._maxInstanceCount =
                                            d.meshPerAttribute * d.count))
                                      : L(c),
                                    M.bindBuffer(34962, v),
                                    P(c, u, g, h, f * y, m * y))
                                  : (l.isInstancedBufferAttribute
                                      ? (R(c, l.meshPerAttribute),
                                        void 0 === r._maxInstanceCount &&
                                          (r._maxInstanceCount =
                                            l.meshPerAttribute * l.count))
                                      : L(c),
                                    M.bindBuffer(34962, v),
                                    P(c, u, g, h, 0, 0))
                              } else if ('instanceMatrix' === s) {
                                var x = E.get(t.instanceMatrix)
                                if (void 0 === x) continue
                                var b = x.buffer,
                                  _ = x.type
                                R(c + 0, 1),
                                  R(c + 1, 1),
                                  R(c + 2, 1),
                                  R(c + 3, 1),
                                  M.bindBuffer(34962, b),
                                  M.vertexAttribPointer(c + 0, 4, _, !1, 64, 0),
                                  M.vertexAttribPointer(
                                    c + 1,
                                    4,
                                    _,
                                    !1,
                                    64,
                                    16,
                                  ),
                                  M.vertexAttribPointer(
                                    c + 2,
                                    4,
                                    _,
                                    !1,
                                    64,
                                    32,
                                  ),
                                  M.vertexAttribPointer(c + 3, 4, _, !1, 64, 48)
                              } else if (void 0 !== o) {
                                var w = o[s]
                                if (void 0 !== w)
                                  switch (w.length) {
                                    case 2:
                                      M.vertexAttrib2fv(c, w)
                                      break
                                    case 3:
                                      M.vertexAttrib3fv(c, w)
                                      break
                                    case 4:
                                      M.vertexAttrib4fv(c, w)
                                      break
                                    default:
                                      M.vertexAttrib1fv(c, w)
                                  }
                              }
                            }
                          }
                          C()
                        })(t, e, n, r),
                        null !== i && M.bindBuffer(34963, E.get(i).buffer))
                  },
                  reset: s,
                  resetDefaultState: e,
                  dispose: function () {
                    for (var t in (s(), h)) {
                      var e = h[t]
                      for (var n in e) {
                        var r = e[n]
                        for (var i in r) o(r[i].object), delete r[i]
                        delete e[n]
                      }
                      delete h[t]
                    }
                  },
                  releaseStatesOfGeometry: function (t) {
                    if (void 0 !== h[t.id]) {
                      var e = h[t.id]
                      for (var n in e) {
                        var r = e[n]
                        for (var i in r) o(r[i].object), delete r[i]
                        delete e[n]
                      }
                      delete h[t.id]
                    }
                  },
                  releaseStatesOfProgram: function (t) {
                    for (var e in h) {
                      var n = h[e]
                      if (void 0 !== n[t.id]) {
                        var r = n[t.id]
                        for (var i in r) o(r[i].object), delete r[i]
                        delete n[t.id]
                      }
                    }
                  },
                  initAttributes: A,
                  enableAttribute: L,
                  disableUnusedAttributes: C,
                }
              }
              function Zi(o, s, c, t) {
                var l,
                  h = t.isWebGL2
                ;(this.setMode = function (t) {
                  l = t
                }),
                  (this.render = function (t, e) {
                    o.drawArrays(l, t, e), c.update(e, l)
                  }),
                  (this.renderInstances = function (t, e, n, r) {
                    if (0 !== r) {
                      var i, a
                      if (h) (i = o), (a = 'drawArraysInstanced')
                      else if (
                        ((a = 'drawArraysInstancedANGLE'),
                        null === (i = s.get('ANGLE_instanced_arrays')))
                      )
                        return void console.error(
                          'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
                        )
                      i[a](l, e, n, r), c.update(n, l, r)
                    }
                  })
              }
              function Ji(e, n, t) {
                var r
                function i(t) {
                  if ('highp' === t) {
                    if (
                      0 < e.getShaderPrecisionFormat(35633, 36338).precision &&
                      0 < e.getShaderPrecisionFormat(35632, 36338).precision
                    )
                      return 'highp'
                    t = 'mediump'
                  }
                  return 'mediump' === t &&
                    0 < e.getShaderPrecisionFormat(35633, 36337).precision &&
                    0 < e.getShaderPrecisionFormat(35632, 36337).precision
                    ? 'mediump'
                    : 'lowp'
                }
                var a =
                    ('undefined' != typeof WebGL2RenderingContext &&
                      e instanceof WebGL2RenderingContext) ||
                    ('undefined' != typeof WebGL2ComputeRenderingContext &&
                      e instanceof WebGL2ComputeRenderingContext),
                  o = void 0 !== t.precision ? t.precision : 'highp',
                  s = i(o)
                s !== o &&
                  (console.warn(
                    'THREE.WebGLRenderer:',
                    o,
                    'not supported, using',
                    s,
                    'instead.',
                  ),
                  (o = s))
                var c = !0 === t.logarithmicDepthBuffer,
                  l = e.getParameter(34930),
                  h = e.getParameter(35660),
                  u = e.getParameter(3379),
                  p = e.getParameter(34076),
                  d = e.getParameter(34921),
                  f = e.getParameter(36347),
                  m = e.getParameter(36348),
                  v = e.getParameter(36349),
                  g = 0 < h,
                  y = a || !!n.get('OES_texture_float')
                return {
                  isWebGL2: a,
                  getMaxAnisotropy: function () {
                    if (void 0 !== r) return r
                    var t = n.get('EXT_texture_filter_anisotropic')
                    return (r =
                      null !== t
                        ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        : 0)
                  },
                  getMaxPrecision: i,
                  precision: o,
                  logarithmicDepthBuffer: c,
                  maxTextures: l,
                  maxVertexTextures: h,
                  maxTextureSize: u,
                  maxCubemapSize: p,
                  maxAttributes: d,
                  maxVertexUniforms: f,
                  maxVaryings: m,
                  maxFragmentUniforms: v,
                  vertexTextures: g,
                  floatFragmentTextures: y,
                  floatVertexTextures: g && y,
                  maxSamples: a ? e.getParameter(36183) : 0,
                }
              }
              function Qi() {
                var h = this,
                  u = null,
                  p = 0,
                  d = !1,
                  f = !1,
                  m = new cr(),
                  v = new Ze(),
                  g = { value: null, needsUpdate: !1 }
                function y() {
                  g.value !== u && ((g.value = u), (g.needsUpdate = 0 < p)),
                    (h.numPlanes = p),
                    (h.numIntersection = 0)
                }
                function x(t, e, n, r) {
                  var i = null !== t ? t.length : 0,
                    a = null
                  if (0 !== i) {
                    if (((a = g.value), !0 !== r || null === a)) {
                      var o = n + 4 * i,
                        s = e.matrixWorldInverse
                      v.getNormalMatrix(s),
                        (null === a || a.length < o) &&
                          (a = new Float32Array(o))
                      for (var c = 0, l = n; c !== i; ++c, l += 4)
                        m.copy(t[c]).applyMatrix4(s, v),
                          m.normal.toArray(a, l),
                          (a[l + 3] = m.constant)
                    }
                    ;(g.value = a), (g.needsUpdate = !0)
                  }
                  return (h.numPlanes = i), (h.numIntersection = 0), a
                }
                ;(this.uniform = g),
                  (this.numPlanes = 0),
                  (this.numIntersection = 0),
                  (this.init = function (t, e, n) {
                    var r = 0 !== t.length || e || 0 !== p || d
                    return (d = e), (u = x(t, n, 0)), (p = t.length), r
                  }),
                  (this.beginShadows = function () {
                    ;(f = !0), x(null)
                  }),
                  (this.endShadows = function () {
                    ;(f = !1), y()
                  }),
                  (this.setState = function (t, e, n, r, i, a) {
                    if (!d || null === t || 0 === t.length || (f && !n))
                      f ? x(null) : y()
                    else {
                      var o = f ? 0 : p,
                        s = 4 * o,
                        c = i.clippingState || null
                      ;(g.value = c), (c = x(t, r, s, a))
                      for (var l = 0; l !== s; ++l) c[l] = u[l]
                      ;(i.clippingState = c),
                        (this.numIntersection = e ? this.numPlanes : 0),
                        (this.numPlanes += o)
                    }
                  })
              }
              function Ki(n) {
                var r = {}
                return {
                  get: function (t) {
                    if (void 0 !== r[t]) return r[t]
                    var e
                    switch (t) {
                      case 'WEBGL_depth_texture':
                        e =
                          n.getExtension('WEBGL_depth_texture') ||
                          n.getExtension('MOZ_WEBGL_depth_texture') ||
                          n.getExtension('WEBKIT_WEBGL_depth_texture')
                        break
                      case 'EXT_texture_filter_anisotropic':
                        e =
                          n.getExtension('EXT_texture_filter_anisotropic') ||
                          n.getExtension(
                            'MOZ_EXT_texture_filter_anisotropic',
                          ) ||
                          n.getExtension(
                            'WEBKIT_EXT_texture_filter_anisotropic',
                          )
                        break
                      case 'WEBGL_compressed_texture_s3tc':
                        e =
                          n.getExtension('WEBGL_compressed_texture_s3tc') ||
                          n.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                          n.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
                        break
                      case 'WEBGL_compressed_texture_pvrtc':
                        e =
                          n.getExtension('WEBGL_compressed_texture_pvrtc') ||
                          n.getExtension(
                            'WEBKIT_WEBGL_compressed_texture_pvrtc',
                          )
                        break
                      default:
                        e = n.getExtension(t)
                    }
                    return (
                      null === e &&
                        console.warn(
                          'THREE.WebGLRenderer: ' +
                            t +
                            ' extension not supported.',
                        ),
                      (r[t] = e)
                    )
                  },
                }
              }
              function $i(t, x, a, o) {
                var s = new WeakMap(),
                  b = new WeakMap()
                function c(t) {
                  var e = t.target,
                    n = s.get(e)
                  for (var r in (null !== n.index && x.remove(n.index),
                  n.attributes))
                    x.remove(n.attributes[r])
                  e.removeEventListener('dispose', c), s.delete(e)
                  var i = b.get(n)
                  i && (x.remove(i), b.delete(n)),
                    o.releaseStatesOfGeometry(e),
                    !0 === e.isInstancedBufferGeometry &&
                      delete e._maxInstanceCount,
                    a.memory.geometries--
                }
                function r(t) {
                  var e = [],
                    n = t.index,
                    r = t.attributes.position,
                    i = 0
                  if (null !== n)
                    for (
                      var a = n.array, i = n.version, o = 0, s = a.length;
                      o < s;
                      o += 3
                    ) {
                      var c = a[o + 0],
                        l = a[o + 1],
                        h = a[o + 2]
                      e.push(c, l, l, h, h, c)
                    }
                  else {
                    var u = r.array
                    i = r.version
                    for (var p = 0, d = u.length / 3 - 1; p < d; p += 3) {
                      var f = p + 0,
                        m = p + 1,
                        v = p + 2
                      e.push(f, m, m, v, v, f)
                    }
                  }
                  var g = new (65535 < jr(e) ? Hr : zr)(e, 1)
                  g.version = i
                  var y = b.get(t)
                  y && x.remove(y), b.set(t, g)
                }
                return {
                  get: function (t, e) {
                    var n = s.get(e)
                    return (
                      n ||
                      (e.addEventListener('dispose', c),
                      e.isBufferGeometry
                        ? (n = e)
                        : e.isGeometry &&
                          (void 0 === e._bufferGeometry &&
                            (e._bufferGeometry = new Kr().setFromObject(t)),
                          (n = e._bufferGeometry)),
                      s.set(e, n),
                      a.memory.geometries++,
                      n)
                    )
                  },
                  update: function (t) {
                    var e = t.attributes
                    for (var n in e) x.update(e[n], 34962)
                    var r = t.morphAttributes
                    for (var i in r)
                      for (var a = r[i], o = 0, s = a.length; o < s; o++)
                        x.update(a[o], 34962)
                  },
                  getWireframeAttribute: function (t) {
                    var e,
                      n = b.get(t)
                    return (
                      (!n ||
                        (null !== (e = t.index) && n.version < e.version)) &&
                        r(t),
                      b.get(t)
                    )
                  },
                }
              }
              function ta(o, s, c, t) {
                var l,
                  h,
                  u,
                  p = t.isWebGL2
                ;(this.setMode = function (t) {
                  l = t
                }),
                  (this.setIndex = function (t) {
                    ;(h = t.type), (u = t.bytesPerElement)
                  }),
                  (this.render = function (t, e) {
                    o.drawElements(l, e, h, t * u), c.update(e, l)
                  }),
                  (this.renderInstances = function (t, e, n, r) {
                    if (0 !== r) {
                      var i, a
                      if (p) (i = o), (a = 'drawElementsInstanced')
                      else if (
                        ((a = 'drawElementsInstancedANGLE'),
                        null === (i = s.get('ANGLE_instanced_arrays')))
                      )
                        return void console.error(
                          'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
                        )
                      i[a](l, n, h, e * u, r), c.update(n, l, r)
                    }
                  })
              }
              function ea(t) {
                var r = {
                  frame: 0,
                  calls: 0,
                  triangles: 0,
                  points: 0,
                  lines: 0,
                }
                return {
                  memory: { geometries: 0, textures: 0 },
                  render: r,
                  programs: null,
                  autoReset: !0,
                  reset: function () {
                    r.frame++,
                      (r.calls = 0),
                      (r.triangles = 0),
                      (r.points = 0),
                      (r.lines = 0)
                  },
                  update: function (t, e, n) {
                    switch (((n = n || 1), r.calls++, e)) {
                      case 4:
                        r.triangles += n * (t / 3)
                        break
                      case 1:
                        r.lines += n * (t / 2)
                        break
                      case 3:
                        r.lines += n * (t - 1)
                        break
                      case 2:
                        r.lines += n * t
                        break
                      case 0:
                        r.points += n * t
                        break
                      default:
                        console.error('THREE.WebGLInfo: Unknown draw mode:', e)
                    }
                  },
                }
              }
              function na(t, e) {
                return t[0] - e[0]
              }
              function ra(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
              }
              function ia(x) {
                for (
                  var b = {}, _ = new Float32Array(8), w = [], t = 0;
                  t < 8;
                  t++
                )
                  w[t] = [t, 0]
                return {
                  update: function (t, e, n, r) {
                    var i = t.morphTargetInfluences,
                      a = void 0 === i ? 0 : i.length,
                      o = b[e.id]
                    if (void 0 === o) {
                      o = []
                      for (var s = 0; s < a; s++) o[s] = [s, 0]
                      b[e.id] = o
                    }
                    for (var c = 0; c < a; c++) {
                      var l = o[c]
                      ;(l[0] = c), (l[1] = i[c])
                    }
                    o.sort(ra)
                    for (var h = 0; h < 8; h++)
                      h < a && o[h][1]
                        ? ((w[h][0] = o[h][0]), (w[h][1] = o[h][1]))
                        : ((w[h][0] = Number.MAX_SAFE_INTEGER), (w[h][1] = 0))
                    w.sort(na)
                    for (
                      var u = n.morphTargets && e.morphAttributes.position,
                        p = n.morphNormals && e.morphAttributes.normal,
                        d = 0,
                        f = 0;
                      f < 8;
                      f++
                    ) {
                      var m = w[f],
                        v = m[0],
                        g = m[1]
                      v !== Number.MAX_SAFE_INTEGER && g
                        ? (u &&
                            e.getAttribute('morphTarget' + f) !== u[v] &&
                            e.setAttribute('morphTarget' + f, u[v]),
                          p &&
                            e.getAttribute('morphNormal' + f) !== p[v] &&
                            e.setAttribute('morphNormal' + f, p[v]),
                          (d += _[f] = g))
                        : (u &&
                            void 0 !== e.getAttribute('morphTarget' + f) &&
                            e.deleteAttribute('morphTarget' + f),
                          p &&
                            void 0 !== e.getAttribute('morphNormal' + f) &&
                            e.deleteAttribute('morphNormal' + f),
                          (_[f] = 0))
                    }
                    var y = e.morphTargetsRelative ? 1 : 1 - d
                    r.getUniforms().setValue(x, 'morphTargetBaseInfluence', y),
                      r.getUniforms().setValue(x, 'morphTargetInfluences', _)
                  },
                }
              }
              function aa(t, i, a, o) {
                var s = new WeakMap()
                return {
                  update: function (t) {
                    var e = o.render.frame,
                      n = t.geometry,
                      r = i.get(t, n)
                    return (
                      s.get(r) !== e &&
                        (n.isGeometry && r.updateFromObject(t),
                        i.update(r),
                        s.set(r, e)),
                      t.isInstancedMesh && a.update(t.instanceMatrix, 34962),
                      r
                    )
                  },
                  dispose: function () {
                    s = new WeakMap()
                  },
                }
              }
              function oa(t, e, n, r, i, a, o, s, c, l) {
                Ke.call(
                  this,
                  (t = void 0 !== t ? t : []),
                  (e = void 0 !== e ? e : Pt),
                  n,
                  r,
                  i,
                  a,
                  (o = void 0 !== o ? o : Kt),
                  s,
                  c,
                  l,
                ),
                  (this.flipY = !1)
              }
              function sa(t, e, n, r) {
                Ke.call(this, null),
                  (this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1,
                    depth: r || 1,
                  }),
                  (this.magFilter = Ht),
                  (this.minFilter = Ht),
                  (this.wrapR = zt),
                  (this.generateMipmaps = !1),
                  (this.flipY = !1),
                  (this.needsUpdate = !0)
              }
              function ca(t, e, n, r) {
                Ke.call(this, null),
                  (this.image = {
                    data: t || null,
                    width: e || 1,
                    height: n || 1,
                    depth: r || 1,
                  }),
                  (this.magFilter = Ht),
                  (this.minFilter = Ht),
                  (this.wrapR = zt),
                  (this.generateMipmaps = !1),
                  (this.flipY = !1),
                  (this.needsUpdate = !0)
              }
              ;(qi.physical = {
                uniforms: Ai([
                  qi.standard.uniforms,
                  {
                    clearcoat: { value: 0 },
                    clearcoatMap: { value: null },
                    clearcoatRoughness: { value: 0 },
                    clearcoatRoughnessMap: { value: null },
                    clearcoatNormalScale: { value: new Ye(1, 1) },
                    clearcoatNormalMap: { value: null },
                    sheen: { value: new Mr(0) },
                    transparency: { value: 0 },
                  },
                ]),
                vertexShader: Wi.meshphysical_vert,
                fragmentShader: Wi.meshphysical_frag,
              }),
                (((oa.prototype = Object.create(Ke.prototype)).constructor =
                  oa).prototype.isCubeTexture = !0),
                Object.defineProperty(oa.prototype, 'images', {
                  get: function () {
                    return this.image
                  },
                  set: function (t) {
                    this.image = t
                  },
                }),
                (((sa.prototype = Object.create(Ke.prototype)).constructor =
                  sa).prototype.isDataTexture2DArray = !0),
                (((ca.prototype = Object.create(Ke.prototype)).constructor =
                  ca).prototype.isDataTexture3D = !0)
              var la = new Ke(),
                ha = new sa(),
                ua = new ca(),
                pa = new oa(),
                da = [],
                fa = [],
                ma = new Float32Array(16),
                va = new Float32Array(9),
                ga = new Float32Array(4)
              function ya(t, e, n) {
                var r = t[0]
                if (r <= 0 || 0 < r) return t
                var i = e * n,
                  a = da[i]
                if (
                  (void 0 === a && ((a = new Float32Array(i)), (da[i] = a)),
                  0 !== e)
                ) {
                  r.toArray(a, 0)
                  for (var o = 1, s = 0; o !== e; ++o)
                    (s += n), t[o].toArray(a, s)
                }
                return a
              }
              function xa(t, e) {
                if (t.length === e.length) {
                  for (var n = 0, r = t.length; n < r; n++)
                    if (t[n] !== e[n]) return
                  return 1
                }
              }
              function ba(t, e) {
                for (var n = 0, r = e.length; n < r; n++) t[n] = e[n]
              }
              function _a(t, e) {
                var n = fa[e]
                void 0 === n && ((n = new Int32Array(e)), (fa[e] = n))
                for (var r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit()
                return n
              }
              function wa(t, e) {
                var n = this.cache
                n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e))
              }
              function Ma(t, e) {
                var n = this.cache
                if (void 0 !== e.x)
                  (n[0] === e.x && n[1] === e.y) ||
                    (t.uniform2f(this.addr, e.x, e.y),
                    (n[0] = e.x),
                    (n[1] = e.y))
                else {
                  if (xa(n, e)) return
                  t.uniform2fv(this.addr, e), ba(n, e)
                }
              }
              function Sa(t, e) {
                var n = this.cache
                if (void 0 !== e.x)
                  (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
                    (t.uniform3f(this.addr, e.x, e.y, e.z),
                    (n[0] = e.x),
                    (n[1] = e.y),
                    (n[2] = e.z))
                else if (void 0 !== e.r)
                  (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
                    (t.uniform3f(this.addr, e.r, e.g, e.b),
                    (n[0] = e.r),
                    (n[1] = e.g),
                    (n[2] = e.b))
                else {
                  if (xa(n, e)) return
                  t.uniform3fv(this.addr, e), ba(n, e)
                }
              }
              function Ea(t, e) {
                var n = this.cache
                if (void 0 !== e.x)
                  (n[0] === e.x &&
                    n[1] === e.y &&
                    n[2] === e.z &&
                    n[3] === e.w) ||
                    (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
                    (n[0] = e.x),
                    (n[1] = e.y),
                    (n[2] = e.z),
                    (n[3] = e.w))
                else {
                  if (xa(n, e)) return
                  t.uniform4fv(this.addr, e), ba(n, e)
                }
              }
              function Ta(t, e) {
                var n = this.cache,
                  r = e.elements
                if (void 0 === r) {
                  if (xa(n, e)) return
                  t.uniformMatrix2fv(this.addr, !1, e), ba(n, e)
                } else {
                  if (xa(n, r)) return
                  ga.set(r), t.uniformMatrix2fv(this.addr, !1, ga), ba(n, r)
                }
              }
              function Aa(t, e) {
                var n = this.cache,
                  r = e.elements
                if (void 0 === r) {
                  if (xa(n, e)) return
                  t.uniformMatrix3fv(this.addr, !1, e), ba(n, e)
                } else {
                  if (xa(n, r)) return
                  va.set(r), t.uniformMatrix3fv(this.addr, !1, va), ba(n, r)
                }
              }
              function La(t, e) {
                var n = this.cache,
                  r = e.elements
                if (void 0 === r) {
                  if (xa(n, e)) return
                  t.uniformMatrix4fv(this.addr, !1, e), ba(n, e)
                } else {
                  if (xa(n, r)) return
                  ma.set(r), t.uniformMatrix4fv(this.addr, !1, ma), ba(n, r)
                }
              }
              function Ra(t, e, n) {
                var r = this.cache,
                  i = n.allocateTextureUnit()
                r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
                  n.safeSetTexture2D(e || la, i)
              }
              function Ca(t, e, n) {
                var r = this.cache,
                  i = n.allocateTextureUnit()
                r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
                  n.setTexture2DArray(e || ha, i)
              }
              function Pa(t, e, n) {
                var r = this.cache,
                  i = n.allocateTextureUnit()
                r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
                  n.setTexture3D(e || ua, i)
              }
              function Oa(t, e, n) {
                var r = this.cache,
                  i = n.allocateTextureUnit()
                r[0] !== i && (t.uniform1i(this.addr, i), (r[0] = i)),
                  n.safeSetTextureCube(e || pa, i)
              }
              function Ia(t, e) {
                var n = this.cache
                n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e))
              }
              function Da(t, e) {
                var n = this.cache
                xa(n, e) || (t.uniform2iv(this.addr, e), ba(n, e))
              }
              function Ba(t, e) {
                var n = this.cache
                xa(n, e) || (t.uniform3iv(this.addr, e), ba(n, e))
              }
              function Na(t, e) {
                var n = this.cache
                xa(n, e) || (t.uniform4iv(this.addr, e), ba(n, e))
              }
              function Ua(t, e) {
                var n = this.cache
                n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e))
              }
              function za(t, e) {
                t.uniform1fv(this.addr, e)
              }
              function Fa(t, e) {
                t.uniform1iv(this.addr, e)
              }
              function Ha(t, e) {
                t.uniform2iv(this.addr, e)
              }
              function Ga(t, e) {
                t.uniform3iv(this.addr, e)
              }
              function ka(t, e) {
                t.uniform4iv(this.addr, e)
              }
              function Va(t, e) {
                var n = ya(e, this.size, 2)
                t.uniform2fv(this.addr, n)
              }
              function ja(t, e) {
                var n = ya(e, this.size, 3)
                t.uniform3fv(this.addr, n)
              }
              function Wa(t, e) {
                var n = ya(e, this.size, 4)
                t.uniform4fv(this.addr, n)
              }
              function qa(t, e) {
                var n = ya(e, this.size, 4)
                t.uniformMatrix2fv(this.addr, !1, n)
              }
              function Xa(t, e) {
                var n = ya(e, this.size, 9)
                t.uniformMatrix3fv(this.addr, !1, n)
              }
              function Ya(t, e) {
                var n = ya(e, this.size, 16)
                t.uniformMatrix4fv(this.addr, !1, n)
              }
              function Za(t, e, n) {
                var r = e.length,
                  i = _a(n, r)
                t.uniform1iv(this.addr, i)
                for (var a = 0; a !== r; ++a)
                  n.safeSetTexture2D(e[a] || la, i[a])
              }
              function Ja(t, e, n) {
                var r = e.length,
                  i = _a(n, r)
                t.uniform1iv(this.addr, i)
                for (var a = 0; a !== r; ++a)
                  n.safeSetTextureCube(e[a] || pa, i[a])
              }
              function Qa(t, e, n) {
                ;(this.id = t),
                  (this.addr = n),
                  (this.cache = []),
                  (this.setValue = (function (t) {
                    switch (t) {
                      case 5126:
                        return wa
                      case 35664:
                        return Ma
                      case 35665:
                        return Sa
                      case 35666:
                        return Ea
                      case 35674:
                        return Ta
                      case 35675:
                        return Aa
                      case 35676:
                        return La
                      case 5124:
                      case 35670:
                        return Ia
                      case 35667:
                      case 35671:
                        return Da
                      case 35668:
                      case 35672:
                        return Ba
                      case 35669:
                      case 35673:
                        return Na
                      case 5125:
                        return Ua
                      case 35678:
                      case 36198:
                      case 36298:
                      case 36306:
                      case 35682:
                        return Ra
                      case 35679:
                      case 36299:
                      case 36307:
                        return Pa
                      case 35680:
                      case 36300:
                      case 36308:
                      case 36293:
                        return Oa
                      case 36289:
                      case 36303:
                      case 36311:
                      case 36292:
                        return Ca
                    }
                  })(e.type))
              }
              function Ka(t, e, n) {
                ;(this.id = t),
                  (this.addr = n),
                  (this.cache = []),
                  (this.size = e.size),
                  (this.setValue = (function (t) {
                    switch (t) {
                      case 5126:
                        return za
                      case 35664:
                        return Va
                      case 35665:
                        return ja
                      case 35666:
                        return Wa
                      case 35674:
                        return qa
                      case 35675:
                        return Xa
                      case 35676:
                        return Ya
                      case 5124:
                      case 35670:
                        return Fa
                      case 35667:
                      case 35671:
                        return Ha
                      case 35668:
                      case 35672:
                        return Ga
                      case 35669:
                      case 35673:
                        return ka
                      case 35678:
                      case 36198:
                      case 36298:
                      case 36306:
                      case 35682:
                        return Za
                      case 35680:
                      case 36300:
                      case 36308:
                      case 36293:
                        return Ja
                    }
                  })(e.type))
              }
              function $a(t) {
                ;(this.id = t), (this.seq = []), (this.map = {})
              }
              ;(Ka.prototype.updateCache = function (t) {
                var e = this.cache
                t instanceof Float32Array &&
                  e.length !== t.length &&
                  (this.cache = new Float32Array(t.length)),
                  ba(e, t)
              }),
                ($a.prototype.setValue = function (t, e, n) {
                  for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
                    var o = r[i]
                    o.setValue(t, e[o.id], n)
                  }
                })
              var to = /([\w\d_]+)(\])?(\[|\.)?/g
              function eo(t, e) {
                t.seq.push(e), (t.map[e.id] = e)
              }
              function no(t, e) {
                ;(this.seq = []), (this.map = {})
                for (
                  var n = t.getProgramParameter(e, 35718), r = 0;
                  r < n;
                  ++r
                ) {
                  var i = t.getActiveUniform(e, r)
                  !(function (t, e, n) {
                    var r = t.name,
                      i = r.length
                    for (to.lastIndex = 0; ; ) {
                      var a = to.exec(r),
                        o = to.lastIndex,
                        s = a[1],
                        c = ']' === a[2],
                        l = a[3]
                      if (
                        (c && (s |= 0),
                        void 0 === l || ('[' === l && o + 2 === i))
                      ) {
                        eo(n, new (void 0 === l ? Qa : Ka)(s, t, e))
                        break
                      }
                      var h = n.map[s]
                      void 0 === h && eo(n, (h = new $a(s))), (n = h)
                    }
                  })(i, t.getUniformLocation(e, i.name), this)
                }
              }
              function ro(t, e, n) {
                var r = t.createShader(e)
                return t.shaderSource(r, n), t.compileShader(r), r
              }
              ;(no.prototype.setValue = function (t, e, n, r) {
                var i = this.map[e]
                void 0 !== i && i.setValue(t, n, r)
              }),
                (no.prototype.setOptional = function (t, e, n) {
                  var r = e[n]
                  void 0 !== r && this.setValue(t, n, r)
                }),
                (no.upload = function (t, e, n, r) {
                  for (var i = 0, a = e.length; i !== a; ++i) {
                    var o = e[i],
                      s = n[o.id]
                    !1 !== s.needsUpdate && o.setValue(t, s.value, r)
                  }
                }),
                (no.seqWithValue = function (t, e) {
                  for (var n = [], r = 0, i = t.length; r !== i; ++r) {
                    var a = t[r]
                    a.id in e && n.push(a)
                  }
                  return n
                })
              var io = 0
              function ao(t) {
                switch (t) {
                  case Re:
                    return ['Linear', '( value )']
                  case Ce:
                    return ['sRGB', '( value )']
                  case Oe:
                    return ['RGBE', '( value )']
                  case n:
                    return ['RGBM', '( value, 7.0 )']
                  case Ie:
                    return ['RGBM', '( value, 16.0 )']
                  case De:
                    return ['RGBD', '( value, 256.0 )']
                  case Pe:
                    return ['Gamma', '( value, float( GAMMA_FACTOR ) )']
                  case e:
                    return ['LogLuv', '( value )']
                  default:
                    return (
                      console.warn(
                        'THREE.WebGLProgram: Unsupported encoding:',
                        t,
                      ),
                      ['Linear', '( value )']
                    )
                }
              }
              function oo(t, e, n) {
                var r = t.getShaderParameter(e, 35713),
                  i = t.getShaderInfoLog(e).trim()
                return r && '' === i
                  ? ''
                  : 'THREE.WebGLShader: gl.getShaderInfoLog() ' +
                      n +
                      '\n' +
                      i +
                      (function (t) {
                        for (var e = t.split('\n'), n = 0; n < e.length; n++)
                          e[n] = n + 1 + ': ' + e[n]
                        return e.join('\n')
                      })(t.getShaderSource(e))
              }
              function so(t, e) {
                var n = ao(e)
                return (
                  'vec4 ' +
                  t +
                  '( vec4 value ) { return ' +
                  n[0] +
                  'ToLinear' +
                  n[1] +
                  '; }'
                )
              }
              function co(t) {
                return '' !== t
              }
              function lo(t, e) {
                return t
                  .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
                  .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
                  .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
                  .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
                  .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
                  .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
                  .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
                  .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
              }
              function ho(t, e) {
                return t
                  .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
                  .replace(
                    /UNION_CLIPPING_PLANES/g,
                    e.numClippingPlanes - e.numClipIntersection,
                  )
              }
              var uo = /^[ \t]*#include +<([\w\d./]+)>/gm
              function po(t) {
                return t.replace(uo, fo)
              }
              function fo(t, e) {
                var n = Wi[e]
                if (void 0 === n)
                  throw new Error('Can not resolve #include <' + e + '>')
                return po(n)
              }
              var mo =
                  /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                vo =
                  /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g
              function go(t) {
                return t.replace(vo, xo).replace(mo, yo)
              }
              function yo(t, e, n, r) {
                return (
                  console.warn(
                    'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.',
                  ),
                  xo(0, e, n, r)
                )
              }
              function xo(t, e, n, r) {
                for (var i = '', a = parseInt(e); a < parseInt(n); a++)
                  i += r
                    .replace(/\[ i \]/g, '[ ' + a + ' ]')
                    .replace(/UNROLLED_LOOP_INDEX/g, a)
                return i
              }
              function bo(t) {
                var e =
                  'precision ' +
                  t.precision +
                  ' float;\nprecision ' +
                  t.precision +
                  ' int;'
                return (
                  'highp' === t.precision
                    ? (e += '\n#define HIGH_PRECISION')
                    : 'mediump' === t.precision
                      ? (e += '\n#define MEDIUM_PRECISION')
                      : 'lowp' === t.precision &&
                        (e += '\n#define LOW_PRECISION'),
                  e
                )
              }
              function _o(t, e, n, r) {
                var i,
                  a,
                  o,
                  s,
                  c,
                  l,
                  h,
                  u,
                  p,
                  d,
                  f = t.getContext(),
                  m = n.defines,
                  v = n.vertexShader,
                  g = n.fragmentShader,
                  y =
                    ((a = 'SHADOWMAP_TYPE_BASIC'),
                    (i = n).shadowMapType === z
                      ? (a = 'SHADOWMAP_TYPE_PCF')
                      : i.shadowMapType === F
                        ? (a = 'SHADOWMAP_TYPE_PCF_SOFT')
                        : i.shadowMapType === H && (a = 'SHADOWMAP_TYPE_VSM'),
                    a),
                  x = (function (t) {
                    var e = 'ENVMAP_TYPE_CUBE'
                    if (t.envMap)
                      switch (t.envMapMode) {
                        case Pt:
                        case Ot:
                          e = 'ENVMAP_TYPE_CUBE'
                          break
                        case Bt:
                        case Nt:
                          e = 'ENVMAP_TYPE_CUBE_UV'
                          break
                        case It:
                        case Dt:
                          e = 'ENVMAP_TYPE_EQUIREC'
                      }
                    return e
                  })(n),
                  b = (function (t) {
                    var e = 'ENVMAP_MODE_REFLECTION'
                    if (t.envMap)
                      switch (t.envMapMode) {
                        case Ot:
                        case Dt:
                          e = 'ENVMAP_MODE_REFRACTION'
                      }
                    return e
                  })(n),
                  _ = (function (t) {
                    var e = 'ENVMAP_BLENDING_NONE'
                    if (t.envMap)
                      switch (t.combine) {
                        case G:
                          e = 'ENVMAP_BLENDING_MULTIPLY'
                          break
                        case k:
                          e = 'ENVMAP_BLENDING_MIX'
                          break
                        case St:
                          e = 'ENVMAP_BLENDING_ADD'
                      }
                    return e
                  })(n),
                  w = 0 < t.gammaFactor ? t.gammaFactor : 1,
                  M = n.isWebGL2
                    ? ''
                    : [
                        (o = n).extensionDerivatives ||
                        o.envMapCubeUV ||
                        o.bumpMap ||
                        o.tangentSpaceNormalMap ||
                        o.clearcoatNormalMap ||
                        o.flatShading ||
                        'physical' === o.shaderID
                          ? '#extension GL_OES_standard_derivatives : enable'
                          : '',
                        (o.extensionFragDepth || o.logarithmicDepthBuffer) &&
                        o.rendererExtensionFragDepth
                          ? '#extension GL_EXT_frag_depth : enable'
                          : '',
                        o.extensionDrawBuffers && o.rendererExtensionDrawBuffers
                          ? '#extension GL_EXT_draw_buffers : require'
                          : '',
                        (o.extensionShaderTextureLOD || o.envMap) &&
                        o.rendererExtensionShaderTextureLod
                          ? '#extension GL_EXT_shader_texture_lod : enable'
                          : '',
                      ]
                        .filter(co)
                        .join('\n'),
                  S = (function (t) {
                    var e = []
                    for (var n in t) {
                      var r = t[n]
                      !1 !== r && e.push('#define ' + n + ' ' + r)
                    }
                    return e.join('\n')
                  })(m),
                  E = f.createProgram()
                n.isRawShaderMaterial
                  ? (0 < (s = [S].filter(co).join('\n')).length && (s += '\n'),
                    0 < (c = [M, S].filter(co).join('\n')).length &&
                      (c += '\n'))
                  : ((s = [
                      bo(n),
                      '#define SHADER_NAME ' + n.shaderName,
                      S,
                      n.instancing ? '#define USE_INSTANCING' : '',
                      n.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                      '#define GAMMA_FACTOR ' + w,
                      '#define MAX_BONES ' + n.maxBones,
                      n.useFog && n.fog ? '#define USE_FOG' : '',
                      n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                      n.map ? '#define USE_MAP' : '',
                      n.envMap ? '#define USE_ENVMAP' : '',
                      n.envMap ? '#define ' + b : '',
                      n.lightMap ? '#define USE_LIGHTMAP' : '',
                      n.aoMap ? '#define USE_AOMAP' : '',
                      n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                      n.bumpMap ? '#define USE_BUMPMAP' : '',
                      n.normalMap ? '#define USE_NORMALMAP' : '',
                      n.normalMap && n.objectSpaceNormalMap
                        ? '#define OBJECTSPACE_NORMALMAP'
                        : '',
                      n.normalMap && n.tangentSpaceNormalMap
                        ? '#define TANGENTSPACE_NORMALMAP'
                        : '',
                      n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                      n.clearcoatRoughnessMap
                        ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
                        : '',
                      n.clearcoatNormalMap
                        ? '#define USE_CLEARCOAT_NORMALMAP'
                        : '',
                      n.displacementMap && n.supportsVertexTextures
                        ? '#define USE_DISPLACEMENTMAP'
                        : '',
                      n.specularMap ? '#define USE_SPECULARMAP' : '',
                      n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                      n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                      n.alphaMap ? '#define USE_ALPHAMAP' : '',
                      n.vertexTangents ? '#define USE_TANGENT' : '',
                      n.vertexColors ? '#define USE_COLOR' : '',
                      n.vertexUvs ? '#define USE_UV' : '',
                      n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                      n.flatShading ? '#define FLAT_SHADED' : '',
                      n.skinning ? '#define USE_SKINNING' : '',
                      n.useVertexTexture ? '#define BONE_TEXTURE' : '',
                      n.morphTargets ? '#define USE_MORPHTARGETS' : '',
                      n.morphNormals && !1 === n.flatShading
                        ? '#define USE_MORPHNORMALS'
                        : '',
                      n.doubleSided ? '#define DOUBLE_SIDED' : '',
                      n.flipSided ? '#define FLIP_SIDED' : '',
                      n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                      n.shadowMapEnabled ? '#define ' + y : '',
                      n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                      n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                      n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                        ? '#define USE_LOGDEPTHBUF_EXT'
                        : '',
                      'uniform mat4 modelMatrix;',
                      'uniform mat4 modelViewMatrix;',
                      'uniform mat4 projectionMatrix;',
                      'uniform mat4 viewMatrix;',
                      'uniform mat3 normalMatrix;',
                      'uniform vec3 cameraPosition;',
                      'uniform bool isOrthographic;',
                      '#ifdef USE_INSTANCING',
                      ' attribute mat4 instanceMatrix;',
                      '#endif',
                      'attribute vec3 position;',
                      'attribute vec3 normal;',
                      'attribute vec2 uv;',
                      '#ifdef USE_TANGENT',
                      '\tattribute vec4 tangent;',
                      '#endif',
                      '#ifdef USE_COLOR',
                      '\tattribute vec3 color;',
                      '#endif',
                      '#ifdef USE_MORPHTARGETS',
                      '\tattribute vec3 morphTarget0;',
                      '\tattribute vec3 morphTarget1;',
                      '\tattribute vec3 morphTarget2;',
                      '\tattribute vec3 morphTarget3;',
                      '\t#ifdef USE_MORPHNORMALS',
                      '\t\tattribute vec3 morphNormal0;',
                      '\t\tattribute vec3 morphNormal1;',
                      '\t\tattribute vec3 morphNormal2;',
                      '\t\tattribute vec3 morphNormal3;',
                      '\t#else',
                      '\t\tattribute vec3 morphTarget4;',
                      '\t\tattribute vec3 morphTarget5;',
                      '\t\tattribute vec3 morphTarget6;',
                      '\t\tattribute vec3 morphTarget7;',
                      '\t#endif',
                      '#endif',
                      '#ifdef USE_SKINNING',
                      '\tattribute vec4 skinIndex;',
                      '\tattribute vec4 skinWeight;',
                      '#endif',
                      '\n',
                    ]
                      .filter(co)
                      .join('\n')),
                    (c = [
                      M,
                      bo(n),
                      '#define SHADER_NAME ' + n.shaderName,
                      S,
                      n.alphaTest
                        ? '#define ALPHATEST ' +
                          n.alphaTest +
                          (n.alphaTest % 1 ? '' : '.0')
                        : '',
                      '#define GAMMA_FACTOR ' + w,
                      n.useFog && n.fog ? '#define USE_FOG' : '',
                      n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
                      n.map ? '#define USE_MAP' : '',
                      n.matcap ? '#define USE_MATCAP' : '',
                      n.envMap ? '#define USE_ENVMAP' : '',
                      n.envMap ? '#define ' + x : '',
                      n.envMap ? '#define ' + b : '',
                      n.envMap ? '#define ' + _ : '',
                      n.lightMap ? '#define USE_LIGHTMAP' : '',
                      n.aoMap ? '#define USE_AOMAP' : '',
                      n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                      n.bumpMap ? '#define USE_BUMPMAP' : '',
                      n.normalMap ? '#define USE_NORMALMAP' : '',
                      n.normalMap && n.objectSpaceNormalMap
                        ? '#define OBJECTSPACE_NORMALMAP'
                        : '',
                      n.normalMap && n.tangentSpaceNormalMap
                        ? '#define TANGENTSPACE_NORMALMAP'
                        : '',
                      n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                      n.clearcoatRoughnessMap
                        ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
                        : '',
                      n.clearcoatNormalMap
                        ? '#define USE_CLEARCOAT_NORMALMAP'
                        : '',
                      n.specularMap ? '#define USE_SPECULARMAP' : '',
                      n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                      n.metalnessMap ? '#define USE_METALNESSMAP' : '',
                      n.alphaMap ? '#define USE_ALPHAMAP' : '',
                      n.sheen ? '#define USE_SHEEN' : '',
                      n.vertexTangents ? '#define USE_TANGENT' : '',
                      n.vertexColors ? '#define USE_COLOR' : '',
                      n.vertexUvs ? '#define USE_UV' : '',
                      n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                      n.gradientMap ? '#define USE_GRADIENTMAP' : '',
                      n.flatShading ? '#define FLAT_SHADED' : '',
                      n.doubleSided ? '#define DOUBLE_SIDED' : '',
                      n.flipSided ? '#define FLIP_SIDED' : '',
                      n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                      n.shadowMapEnabled ? '#define ' + y : '',
                      n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                      n.physicallyCorrectLights
                        ? '#define PHYSICALLY_CORRECT_LIGHTS'
                        : '',
                      n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                      n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                        ? '#define USE_LOGDEPTHBUF_EXT'
                        : '',
                      (n.extensionShaderTextureLOD || n.envMap) &&
                      n.rendererExtensionShaderTextureLod
                        ? '#define TEXTURE_LOD_EXT'
                        : '',
                      'uniform mat4 viewMatrix;',
                      'uniform vec3 cameraPosition;',
                      'uniform bool isOrthographic;',
                      n.toneMapping !== Et ? '#define TONE_MAPPING' : '',
                      n.toneMapping !== Et ? Wi.tonemapping_pars_fragment : '',
                      n.toneMapping !== Et
                        ? (function (t, e) {
                            var n
                            switch (e) {
                              case Tt:
                                n = 'Linear'
                                break
                              case At:
                                n = 'Reinhard'
                                break
                              case Lt:
                                n = 'OptimizedCineon'
                                break
                              case Rt:
                                n = 'ACESFilmic'
                                break
                              case Ct:
                                n = 'Custom'
                                break
                              default:
                                console.warn(
                                  'THREE.WebGLProgram: Unsupported toneMapping:',
                                  e,
                                ),
                                  (n = 'Linear')
                            }
                            return (
                              'vec3 ' +
                              t +
                              '( vec3 color ) { return ' +
                              n +
                              'ToneMapping( color ); }'
                            )
                          })('toneMapping', n.toneMapping)
                        : '',
                      n.dithering ? '#define DITHERING' : '',
                      Wi.encodings_pars_fragment,
                      n.map ? so('mapTexelToLinear', n.mapEncoding) : '',
                      n.matcap
                        ? so('matcapTexelToLinear', n.matcapEncoding)
                        : '',
                      n.envMap
                        ? so('envMapTexelToLinear', n.envMapEncoding)
                        : '',
                      n.emissiveMap
                        ? so('emissiveMapTexelToLinear', n.emissiveMapEncoding)
                        : '',
                      n.lightMap
                        ? so('lightMapTexelToLinear', n.lightMapEncoding)
                        : '',
                      ((l = 'linearToOutputTexel'),
                      (h = n.outputEncoding),
                      (u = ao(h)),
                      'vec4 ' +
                        l +
                        '( vec4 value ) { return LinearTo' +
                        u[0] +
                        u[1] +
                        '; }'),
                      n.depthPacking
                        ? '#define DEPTH_PACKING ' + n.depthPacking
                        : '',
                      '\n',
                    ]
                      .filter(co)
                      .join('\n'))),
                  (v = ho((v = lo((v = po(v)), n)), n)),
                  (g = ho((g = lo((g = po(g)), n)), n)),
                  (v = go(v)),
                  (g = go(g)),
                  n.isWebGL2 &&
                    !n.isRawShaderMaterial &&
                    ((p = !1),
                    (d = /^\s*#version\s+300\s+es\s*\n/),
                    n.isShaderMaterial &&
                      null !== v.match(d) &&
                      null !== g.match(d) &&
                      ((p = !0),
                      (v = v.replace(d, '')),
                      (g = g.replace(d, ''))),
                    (s =
                      [
                        '#version 300 es\n',
                        '#define attribute in',
                        '#define varying out',
                        '#define texture2D texture',
                      ].join('\n') +
                      '\n' +
                      s),
                    (c =
                      [
                        '#version 300 es\n',
                        '#define varying in',
                        p ? '' : 'out highp vec4 pc_fragColor;',
                        p ? '' : '#define gl_FragColor pc_fragColor',
                        '#define gl_FragDepthEXT gl_FragDepth',
                        '#define texture2D texture',
                        '#define textureCube texture',
                        '#define texture2DProj textureProj',
                        '#define texture2DLodEXT textureLod',
                        '#define texture2DProjLodEXT textureProjLod',
                        '#define textureCubeLodEXT textureLod',
                        '#define texture2DGradEXT textureGrad',
                        '#define texture2DProjGradEXT textureProjGrad',
                        '#define textureCubeGradEXT textureGrad',
                      ].join('\n') +
                      '\n' +
                      c))
                var T,
                  A,
                  L,
                  R,
                  C,
                  P,
                  O,
                  I,
                  D,
                  B = c + g,
                  N = ro(f, 35633, s + v),
                  U = ro(f, 35632, B)
                return (
                  f.attachShader(E, N),
                  f.attachShader(E, U),
                  void 0 !== n.index0AttributeName
                    ? f.bindAttribLocation(E, 0, n.index0AttributeName)
                    : !0 === n.morphTargets &&
                      f.bindAttribLocation(E, 0, 'position'),
                  f.linkProgram(E),
                  t.debug.checkShaderErrors &&
                    ((T = f.getProgramInfoLog(E).trim()),
                    (A = f.getShaderInfoLog(N).trim()),
                    (L = f.getShaderInfoLog(U).trim()),
                    !(C = R = !0) === f.getProgramParameter(E, 35714)
                      ? ((R = !1),
                        (P = oo(f, N, 'vertex')),
                        (O = oo(f, U, 'fragment')),
                        console.error(
                          'THREE.WebGLProgram: shader error: ',
                          f.getError(),
                          '35715',
                          f.getProgramParameter(E, 35715),
                          'gl.getProgramInfoLog',
                          T,
                          P,
                          O,
                        ))
                      : '' !== T
                        ? console.warn(
                            'THREE.WebGLProgram: gl.getProgramInfoLog()',
                            T,
                          )
                        : ('' !== A && '' !== L) || (C = !1),
                    C &&
                      (this.diagnostics = {
                        runnable: R,
                        programLog: T,
                        vertexShader: { log: A, prefix: s },
                        fragmentShader: { log: L, prefix: c },
                      })),
                  f.deleteShader(N),
                  f.deleteShader(U),
                  (this.getUniforms = function () {
                    return void 0 === I && (I = new no(f, E)), I
                  }),
                  (this.getAttributes = function () {
                    return (
                      void 0 === D &&
                        (D = (function (t, e) {
                          for (
                            var n = {},
                              r = t.getProgramParameter(e, 35721),
                              i = 0;
                            i < r;
                            i++
                          ) {
                            var a = t.getActiveAttrib(e, i).name
                            n[a] = t.getAttribLocation(e, a)
                          }
                          return n
                        })(f, E)),
                      D
                    )
                  }),
                  (this.destroy = function () {
                    r.releaseStatesOfProgram(this),
                      f.deleteProgram(E),
                      (this.program = void 0)
                  }),
                  (this.name = n.shaderName),
                  (this.id = io++),
                  (this.cacheKey = e),
                  (this.usedTimes = 1),
                  (this.program = E),
                  (this.vertexShader = N),
                  (this.fragmentShader = U),
                  this
                )
              }
              function wo(g, y, x, o) {
                var s = [],
                  b = x.isWebGL2,
                  _ = x.logarithmicDepthBuffer,
                  w = x.floatVertexTextures,
                  M = x.maxVertexUniforms,
                  S = x.vertexTextures,
                  E = x.precision,
                  T = {
                    MeshDepthMaterial: 'depth',
                    MeshDistanceMaterial: 'distanceRGBA',
                    MeshNormalMaterial: 'normal',
                    MeshBasicMaterial: 'basic',
                    MeshLambertMaterial: 'lambert',
                    MeshPhongMaterial: 'phong',
                    MeshToonMaterial: 'toon',
                    MeshStandardMaterial: 'physical',
                    MeshPhysicalMaterial: 'physical',
                    MeshMatcapMaterial: 'matcap',
                    LineBasicMaterial: 'basic',
                    LineDashedMaterial: 'dashed',
                    PointsMaterial: 'points',
                    ShadowMaterial: 'shadow',
                    SpriteMaterial: 'sprite',
                  },
                  i = [
                    'precision',
                    'isWebGL2',
                    'supportsVertexTextures',
                    'outputEncoding',
                    'instancing',
                    'map',
                    'mapEncoding',
                    'matcap',
                    'matcapEncoding',
                    'envMap',
                    'envMapMode',
                    'envMapEncoding',
                    'envMapCubeUV',
                    'lightMap',
                    'lightMapEncoding',
                    'aoMap',
                    'emissiveMap',
                    'emissiveMapEncoding',
                    'bumpMap',
                    'normalMap',
                    'objectSpaceNormalMap',
                    'tangentSpaceNormalMap',
                    'clearcoatMap',
                    'clearcoatRoughnessMap',
                    'clearcoatNormalMap',
                    'displacementMap',
                    'specularMap',
                    'roughnessMap',
                    'metalnessMap',
                    'gradientMap',
                    'alphaMap',
                    'combine',
                    'vertexColors',
                    'vertexTangents',
                    'vertexUvs',
                    'uvsVertexOnly',
                    'fog',
                    'useFog',
                    'fogExp2',
                    'flatShading',
                    'sizeAttenuation',
                    'logarithmicDepthBuffer',
                    'skinning',
                    'maxBones',
                    'useVertexTexture',
                    'morphTargets',
                    'morphNormals',
                    'maxMorphTargets',
                    'maxMorphNormals',
                    'premultipliedAlpha',
                    'numDirLights',
                    'numPointLights',
                    'numSpotLights',
                    'numHemiLights',
                    'numRectAreaLights',
                    'numDirLightShadows',
                    'numPointLightShadows',
                    'numSpotLightShadows',
                    'shadowMapEnabled',
                    'shadowMapType',
                    'toneMapping',
                    'physicallyCorrectLights',
                    'alphaTest',
                    'doubleSided',
                    'flipSided',
                    'numClippingPlanes',
                    'numClipIntersection',
                    'depthPacking',
                    'dithering',
                    'sheen',
                  ]
                function A(t) {
                  var e
                  return (
                    t
                      ? t.isTexture
                        ? (e = t.encoding)
                        : t.isWebGLRenderTarget &&
                          (console.warn(
                            "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.",
                          ),
                          (e = t.texture.encoding))
                      : (e = Re),
                    e
                  )
                }
                return {
                  getParameters: function (t, e, n, r, i, a, o) {
                    var s = r.fog,
                      c = t.isMeshStandardMaterial ? r.environment : null,
                      l = t.envMap || c,
                      h = T[t.type],
                      u = o.isSkinnedMesh
                        ? (function (t) {
                            var e = t.skeleton.bones
                            if (w) return 1024
                            var n = Math.floor((M - 20) / 4),
                              r = Math.min(n, e.length)
                            return r < e.length
                              ? (console.warn(
                                  'THREE.WebGLRenderer: Skeleton has ' +
                                    e.length +
                                    ' bones. This GPU supports ' +
                                    r +
                                    '.',
                                ),
                                0)
                              : r
                          })(o)
                        : 0
                    null !== t.precision &&
                      (E = x.getMaxPrecision(t.precision)) !== t.precision &&
                      console.warn(
                        'THREE.WebGLProgram.getParameters:',
                        t.precision,
                        'not supported, using',
                        E,
                        'instead.',
                      )
                    var p,
                      d,
                      f,
                      m =
                        ((p = t),
                        (d = h)
                          ? ((f = qi[d]),
                            {
                              name: p.name || p.type,
                              uniforms: Li.clone(f.uniforms),
                              vertexShader: f.vertexShader,
                              fragmentShader: f.fragmentShader,
                            })
                          : {
                              name: p.name || p.type,
                              uniforms: p.uniforms,
                              vertexShader: p.vertexShader,
                              fragmentShader: p.fragmentShader,
                            })
                    t.onBeforeCompile(m, g)
                    var v = g.getRenderTarget()
                    return {
                      isWebGL2: b,
                      shaderID: h,
                      shaderName: m.name,
                      uniforms: m.uniforms,
                      vertexShader: m.vertexShader,
                      fragmentShader: m.fragmentShader,
                      defines: t.defines,
                      isRawShaderMaterial: t.isRawShaderMaterial,
                      isShaderMaterial: t.isShaderMaterial,
                      precision: E,
                      instancing: !0 === o.isInstancedMesh,
                      supportsVertexTextures: S,
                      outputEncoding:
                        null !== v ? A(v.texture) : g.outputEncoding,
                      map: !!t.map,
                      mapEncoding: A(t.map),
                      matcap: !!t.matcap,
                      matcapEncoding: A(t.matcap),
                      envMap: !!l,
                      envMapMode: l && l.mapping,
                      envMapEncoding: A(l),
                      envMapCubeUV:
                        !!l && (l.mapping === Bt || l.mapping === Nt),
                      lightMap: !!t.lightMap,
                      lightMapEncoding: A(t.lightMap),
                      aoMap: !!t.aoMap,
                      emissiveMap: !!t.emissiveMap,
                      emissiveMapEncoding: A(t.emissiveMap),
                      bumpMap: !!t.bumpMap,
                      normalMap: !!t.normalMap,
                      objectSpaceNormalMap: t.normalMapType === ze,
                      tangentSpaceNormalMap: t.normalMapType === Ue,
                      clearcoatMap: !!t.clearcoatMap,
                      clearcoatRoughnessMap: !!t.clearcoatRoughnessMap,
                      clearcoatNormalMap: !!t.clearcoatNormalMap,
                      displacementMap: !!t.displacementMap,
                      roughnessMap: !!t.roughnessMap,
                      metalnessMap: !!t.metalnessMap,
                      specularMap: !!t.specularMap,
                      alphaMap: !!t.alphaMap,
                      gradientMap: !!t.gradientMap,
                      sheen: !!t.sheen,
                      combine: t.combine,
                      vertexTangents: t.normalMap && t.vertexTangents,
                      vertexColors: t.vertexColors,
                      vertexUvs: !!(
                        t.map ||
                        t.bumpMap ||
                        t.normalMap ||
                        t.specularMap ||
                        t.alphaMap ||
                        t.emissiveMap ||
                        t.roughnessMap ||
                        t.metalnessMap ||
                        t.clearcoatMap ||
                        t.clearcoatRoughnessMap ||
                        t.clearcoatNormalMap ||
                        t.displacementMap
                      ),
                      uvsVertexOnly: !(
                        t.map ||
                        t.bumpMap ||
                        t.normalMap ||
                        t.specularMap ||
                        t.alphaMap ||
                        t.emissiveMap ||
                        t.roughnessMap ||
                        t.metalnessMap ||
                        t.clearcoatNormalMap ||
                        !t.displacementMap
                      ),
                      fog: !!s,
                      useFog: t.fog,
                      fogExp2: s && s.isFogExp2,
                      flatShading: t.flatShading,
                      sizeAttenuation: t.sizeAttenuation,
                      logarithmicDepthBuffer: _,
                      skinning: t.skinning && 0 < u,
                      maxBones: u,
                      useVertexTexture: w,
                      morphTargets: t.morphTargets,
                      morphNormals: t.morphNormals,
                      maxMorphTargets: g.maxMorphTargets,
                      maxMorphNormals: g.maxMorphNormals,
                      numDirLights: e.directional.length,
                      numPointLights: e.point.length,
                      numSpotLights: e.spot.length,
                      numRectAreaLights: e.rectArea.length,
                      numHemiLights: e.hemi.length,
                      numDirLightShadows: e.directionalShadowMap.length,
                      numPointLightShadows: e.pointShadowMap.length,
                      numSpotLightShadows: e.spotShadowMap.length,
                      numClippingPlanes: i,
                      numClipIntersection: a,
                      dithering: t.dithering,
                      shadowMapEnabled: g.shadowMap.enabled && 0 < n.length,
                      shadowMapType: g.shadowMap.type,
                      toneMapping: t.toneMapped ? g.toneMapping : Et,
                      physicallyCorrectLights: g.physicallyCorrectLights,
                      premultipliedAlpha: t.premultipliedAlpha,
                      alphaTest: t.alphaTest,
                      doubleSided: t.side === X,
                      flipSided: t.side === q,
                      depthPacking: void 0 !== t.depthPacking && t.depthPacking,
                      index0AttributeName: t.index0AttributeName,
                      extensionDerivatives:
                        t.extensions && t.extensions.derivatives,
                      extensionFragDepth:
                        t.extensions && t.extensions.fragDepth,
                      extensionDrawBuffers:
                        t.extensions && t.extensions.drawBuffers,
                      extensionShaderTextureLOD:
                        t.extensions && t.extensions.shaderTextureLOD,
                      rendererExtensionFragDepth:
                        b || null !== y.get('EXT_frag_depth'),
                      rendererExtensionDrawBuffers:
                        b || null !== y.get('WEBGL_draw_buffers'),
                      rendererExtensionShaderTextureLod:
                        b || null !== y.get('EXT_shader_texture_lod'),
                      customProgramCacheKey: t.customProgramCacheKey(),
                    }
                  },
                  getProgramCacheKey: function (t) {
                    var e = []
                    if (
                      (t.shaderID
                        ? e.push(t.shaderID)
                        : (e.push(t.fragmentShader), e.push(t.vertexShader)),
                      void 0 !== t.defines)
                    )
                      for (var n in t.defines) e.push(n), e.push(t.defines[n])
                    if (void 0 === t.isRawShaderMaterial) {
                      for (var r = 0; r < i.length; r++) e.push(t[i[r]])
                      e.push(g.outputEncoding), e.push(g.gammaFactor)
                    }
                    return e.push(t.customProgramCacheKey), e.join()
                  },
                  acquireProgram: function (t, e) {
                    for (var n, r = 0, i = s.length; r < i; r++) {
                      var a = s[r]
                      if (a.cacheKey === e) {
                        ++(n = a).usedTimes
                        break
                      }
                    }
                    return (
                      void 0 === n && ((n = new _o(g, e, t, o)), s.push(n)), n
                    )
                  },
                  releaseProgram: function (t) {
                    var e
                    0 == --t.usedTimes &&
                      ((e = s.indexOf(t)),
                      (s[e] = s[s.length - 1]),
                      s.pop(),
                      t.destroy())
                  },
                  programs: s,
                }
              }
              function Mo() {
                var r = new WeakMap()
                return {
                  get: function (t) {
                    var e = r.get(t)
                    return void 0 === e && ((e = {}), r.set(t, e)), e
                  },
                  remove: function (t) {
                    r.delete(t)
                  },
                  update: function (t, e, n) {
                    r.get(t)[e] = n
                  },
                  dispose: function () {
                    r = new WeakMap()
                  },
                }
              }
              function So(t, e) {
                return t.groupOrder !== e.groupOrder
                  ? t.groupOrder - e.groupOrder
                  : t.renderOrder !== e.renderOrder
                    ? t.renderOrder - e.renderOrder
                    : t.program !== e.program
                      ? t.program.id - e.program.id
                      : t.material.id !== e.material.id
                        ? t.material.id - e.material.id
                        : t.z !== e.z
                          ? t.z - e.z
                          : t.id - e.id
              }
              function Eo(t, e) {
                return t.groupOrder !== e.groupOrder
                  ? t.groupOrder - e.groupOrder
                  : t.renderOrder !== e.renderOrder
                    ? t.renderOrder - e.renderOrder
                    : t.z !== e.z
                      ? e.z - t.z
                      : t.id - e.id
              }
              function To() {
                var s = [],
                  c = 0,
                  l = [],
                  h = [],
                  u = { id: -1 }
                function p(t, e, n, r, i, a) {
                  var o = s[c]
                  return (
                    void 0 === o
                      ? ((o = {
                          id: t.id,
                          object: t,
                          geometry: e,
                          material: n,
                          program: n.program || u,
                          groupOrder: r,
                          renderOrder: t.renderOrder,
                          z: i,
                          group: a,
                        }),
                        (s[c] = o))
                      : ((o.id = t.id),
                        (o.object = t),
                        (o.geometry = e),
                        (o.material = n),
                        (o.program = n.program || u),
                        (o.groupOrder = r),
                        (o.renderOrder = t.renderOrder),
                        (o.z = i),
                        (o.group = a)),
                    c++,
                    o
                  )
                }
                return {
                  opaque: l,
                  transparent: h,
                  init: function () {
                    ;(c = 0), (l.length = 0), (h.length = 0)
                  },
                  push: function (t, e, n, r, i, a) {
                    var o = p(t, e, n, r, i, a)
                    ;(!0 === n.transparent ? h : l).push(o)
                  },
                  unshift: function (t, e, n, r, i, a) {
                    var o = p(t, e, n, r, i, a)
                    ;(!0 === n.transparent ? h : l).unshift(o)
                  },
                  finish: function () {
                    for (var t = c, e = s.length; t < e; t++) {
                      var n = s[t]
                      if (null === n.id) break
                      ;(n.id = null),
                        (n.object = null),
                        (n.geometry = null),
                        (n.material = null),
                        (n.program = null),
                        (n.group = null)
                    }
                  },
                  sort: function (t, e) {
                    1 < l.length && l.sort(t || So),
                      1 < h.length && h.sort(e || Eo)
                  },
                }
              }
              function Ao() {
                var i = new WeakMap()
                function a(t) {
                  var e = t.target
                  e.removeEventListener('dispose', a), i.delete(e)
                }
                return {
                  get: function (t, e) {
                    var n,
                      r = i.get(t)
                    return (
                      void 0 === r
                        ? ((n = new To()),
                          i.set(t, new WeakMap()),
                          i.get(t).set(e, n),
                          t.addEventListener('dispose', a))
                        : void 0 === (n = r.get(e)) &&
                          ((n = new To()), r.set(e, n)),
                      n
                    )
                  },
                  dispose: function () {
                    i = new WeakMap()
                  },
                }
              }
              function Lo() {
                var n = {}
                return {
                  get: function (t) {
                    if (void 0 !== n[t.id]) return n[t.id]
                    var e
                    switch (t.type) {
                      case 'DirectionalLight':
                        e = { direction: new on(), color: new Mr() }
                        break
                      case 'SpotLight':
                        e = {
                          position: new on(),
                          direction: new on(),
                          color: new Mr(),
                          distance: 0,
                          coneCos: 0,
                          penumbraCos: 0,
                          decay: 0,
                        }
                        break
                      case 'PointLight':
                        e = {
                          position: new on(),
                          color: new Mr(),
                          distance: 0,
                          decay: 0,
                        }
                        break
                      case 'HemisphereLight':
                        e = {
                          direction: new on(),
                          skyColor: new Mr(),
                          groundColor: new Mr(),
                        }
                        break
                      case 'RectAreaLight':
                        e = {
                          color: new Mr(),
                          position: new on(),
                          halfWidth: new on(),
                          halfHeight: new on(),
                        }
                    }
                    return (n[t.id] = e)
                  },
                }
              }
              var Ro = 0
              function Co(t, e) {
                return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
              }
              function Po() {
                for (
                  var n,
                    N = new Lo(),
                    U =
                      ((n = {}),
                      {
                        get: function (t) {
                          if (void 0 !== n[t.id]) return n[t.id]
                          var e
                          switch (t.type) {
                            case 'DirectionalLight':
                            case 'SpotLight':
                              e = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Ye(),
                              }
                              break
                            case 'PointLight':
                              e = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Ye(),
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3,
                              }
                          }
                          return (n[t.id] = e)
                        },
                      }),
                    z = {
                      version: 0,
                      hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                      },
                      ambient: [0, 0, 0],
                      probe: [],
                      directional: [],
                      directionalShadow: [],
                      directionalShadowMap: [],
                      directionalShadowMatrix: [],
                      spot: [],
                      spotShadow: [],
                      spotShadowMap: [],
                      spotShadowMatrix: [],
                      rectArea: [],
                      point: [],
                      pointShadow: [],
                      pointShadowMap: [],
                      pointShadowMatrix: [],
                      hemi: [],
                    },
                    t = 0;
                  t < 9;
                  t++
                )
                  z.probe.push(new on())
                var F = new on(),
                  H = new fn(),
                  G = new fn()
                return {
                  setup: function (t, e, n) {
                    for (var r = 0, i = 0, a = 0, o = 0; o < 9; o++)
                      z.probe[o].set(0, 0, 0)
                    var s = 0,
                      c = 0,
                      l = 0,
                      h = 0,
                      u = 0,
                      p = 0,
                      d = 0,
                      f = 0,
                      m = n.matrixWorldInverse
                    t.sort(Co)
                    for (var v = 0, g = t.length; v < g; v++) {
                      var y,
                        x,
                        b,
                        _,
                        w,
                        M,
                        S,
                        E,
                        T,
                        A,
                        L,
                        R = t[v],
                        C = R.color,
                        P = R.intensity,
                        O = R.distance,
                        I =
                          R.shadow && R.shadow.map ? R.shadow.map.texture : null
                      if (R.isAmbientLight)
                        (r += C.r * P), (i += C.g * P), (a += C.b * P)
                      else if (R.isLightProbe)
                        for (var D = 0; D < 9; D++)
                          z.probe[D].addScaledVector(R.sh.coefficients[D], P)
                      else {
                        R.isDirectionalLight
                          ? ((y = N.get(R)).color
                              .copy(R.color)
                              .multiplyScalar(R.intensity),
                            y.direction.setFromMatrixPosition(R.matrixWorld),
                            F.setFromMatrixPosition(R.target.matrixWorld),
                            y.direction.sub(F),
                            y.direction.transformDirection(m),
                            R.castShadow &&
                              ((x = R.shadow),
                              ((b = U.get(R)).shadowBias = x.bias),
                              (b.shadowNormalBias = x.normalBias),
                              (b.shadowRadius = x.radius),
                              (b.shadowMapSize = x.mapSize),
                              (z.directionalShadow[s] = b),
                              (z.directionalShadowMap[s] = I),
                              (z.directionalShadowMatrix[s] = R.shadow.matrix),
                              p++),
                            (z.directional[s] = y),
                            s++)
                          : R.isSpotLight
                            ? ((_ = N.get(R)).position.setFromMatrixPosition(
                                R.matrixWorld,
                              ),
                              _.position.applyMatrix4(m),
                              _.color.copy(C).multiplyScalar(P),
                              (_.distance = O),
                              _.direction.setFromMatrixPosition(R.matrixWorld),
                              F.setFromMatrixPosition(R.target.matrixWorld),
                              _.direction.sub(F),
                              _.direction.transformDirection(m),
                              (_.coneCos = Math.cos(R.angle)),
                              (_.penumbraCos = Math.cos(
                                R.angle * (1 - R.penumbra),
                              )),
                              (_.decay = R.decay),
                              R.castShadow &&
                                ((w = R.shadow),
                                ((M = U.get(R)).shadowBias = w.bias),
                                (M.shadowNormalBias = w.normalBias),
                                (M.shadowRadius = w.radius),
                                (M.shadowMapSize = w.mapSize),
                                (z.spotShadow[l] = M),
                                (z.spotShadowMap[l] = I),
                                (z.spotShadowMatrix[l] = R.shadow.matrix),
                                f++),
                              (z.spot[l] = _),
                              l++)
                            : R.isRectAreaLight
                              ? ((S = N.get(R)).color.copy(C).multiplyScalar(P),
                                S.position.setFromMatrixPosition(R.matrixWorld),
                                S.position.applyMatrix4(m),
                                G.identity(),
                                H.copy(R.matrixWorld),
                                H.premultiply(m),
                                G.extractRotation(H),
                                S.halfWidth.set(0.5 * R.width, 0, 0),
                                S.halfHeight.set(0, 0.5 * R.height, 0),
                                S.halfWidth.applyMatrix4(G),
                                S.halfHeight.applyMatrix4(G),
                                (z.rectArea[h] = S),
                                h++)
                              : R.isPointLight
                                ? ((E =
                                    N.get(R)).position.setFromMatrixPosition(
                                    R.matrixWorld,
                                  ),
                                  E.position.applyMatrix4(m),
                                  E.color
                                    .copy(R.color)
                                    .multiplyScalar(R.intensity),
                                  (E.distance = R.distance),
                                  (E.decay = R.decay),
                                  R.castShadow &&
                                    ((T = R.shadow),
                                    ((A = U.get(R)).shadowBias = T.bias),
                                    (A.shadowNormalBias = T.normalBias),
                                    (A.shadowRadius = T.radius),
                                    (A.shadowMapSize = T.mapSize),
                                    (A.shadowCameraNear = T.camera.near),
                                    (A.shadowCameraFar = T.camera.far),
                                    (z.pointShadow[c] = A),
                                    (z.pointShadowMap[c] = I),
                                    (z.pointShadowMatrix[c] = R.shadow.matrix),
                                    d++),
                                  (z.point[c] = E),
                                  c++)
                                : R.isHemisphereLight &&
                                  ((L =
                                    N.get(R)).direction.setFromMatrixPosition(
                                    R.matrixWorld,
                                  ),
                                  L.direction.transformDirection(m),
                                  L.direction.normalize(),
                                  L.skyColor.copy(R.color).multiplyScalar(P),
                                  L.groundColor
                                    .copy(R.groundColor)
                                    .multiplyScalar(P),
                                  (z.hemi[u] = L),
                                  u++)
                      }
                    }
                    ;(z.ambient[0] = r), (z.ambient[1] = i), (z.ambient[2] = a)
                    var B = z.hash
                    ;(B.directionalLength === s &&
                      B.pointLength === c &&
                      B.spotLength === l &&
                      B.rectAreaLength === h &&
                      B.hemiLength === u &&
                      B.numDirectionalShadows === p &&
                      B.numPointShadows === d &&
                      B.numSpotShadows === f) ||
                      ((z.directional.length = s),
                      (z.spot.length = l),
                      (z.rectArea.length = h),
                      (z.point.length = c),
                      (z.hemi.length = u),
                      (z.directionalShadow.length = p),
                      (z.directionalShadowMap.length = p),
                      (z.pointShadow.length = d),
                      (z.pointShadowMap.length = d),
                      (z.spotShadow.length = f),
                      (z.spotShadowMap.length = f),
                      (z.directionalShadowMatrix.length = p),
                      (z.pointShadowMatrix.length = d),
                      (z.spotShadowMatrix.length = f),
                      (B.directionalLength = s),
                      (B.pointLength = c),
                      (B.spotLength = l),
                      (B.rectAreaLength = h),
                      (B.hemiLength = u),
                      (B.numDirectionalShadows = p),
                      (B.numPointShadows = d),
                      (B.numSpotShadows = f),
                      (z.version = Ro++))
                  },
                  state: z,
                }
              }
              function Oo() {
                var e = new Po(),
                  n = [],
                  r = []
                return {
                  init: function () {
                    ;(n.length = 0), (r.length = 0)
                  },
                  state: { lightsArray: n, shadowsArray: r, lights: e },
                  setupLights: function (t) {
                    e.setup(n, r, t)
                  },
                  pushLight: function (t) {
                    n.push(t)
                  },
                  pushShadow: function (t) {
                    r.push(t)
                  },
                }
              }
              function Io() {
                var r = new WeakMap()
                function i(t) {
                  var e = t.target
                  e.removeEventListener('dispose', i), r.delete(e)
                }
                return {
                  get: function (t, e) {
                    var n
                    return (
                      !1 === r.has(t)
                        ? ((n = new Oo()),
                          r.set(t, new WeakMap()),
                          r.get(t).set(e, n),
                          t.addEventListener('dispose', i))
                        : !1 === r.get(t).has(e)
                          ? ((n = new Oo()), r.get(t).set(e, n))
                          : (n = r.get(t).get(e)),
                      n
                    )
                  },
                  dispose: function () {
                    r = new WeakMap()
                  },
                }
              }
              function Do(t) {
                Rr.call(this),
                  (this.type = 'MeshDepthMaterial'),
                  (this.depthPacking = Be),
                  (this.skinning = !1),
                  (this.morphTargets = !1),
                  (this.map = null),
                  (this.alphaMap = null),
                  (this.displacementMap = null),
                  (this.displacementScale = 1),
                  (this.displacementBias = 0),
                  (this.wireframe = !1),
                  (this.wireframeLinewidth = 1),
                  (this.fog = !1),
                  this.setValues(t)
              }
              function Bo(t) {
                Rr.call(this),
                  (this.type = 'MeshDistanceMaterial'),
                  (this.referencePosition = new on()),
                  (this.nearDistance = 1),
                  (this.farDistance = 1e3),
                  (this.skinning = !1),
                  (this.morphTargets = !1),
                  (this.map = null),
                  (this.alphaMap = null),
                  (this.displacementMap = null),
                  (this.displacementScale = 1),
                  (this.displacementBias = 0),
                  (this.fog = !1),
                  this.setValues(t)
              }
              ;(((Do.prototype = Object.create(Rr.prototype)).constructor =
                Do).prototype.isMeshDepthMaterial = !0),
                (Do.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    (this.depthPacking = t.depthPacking),
                    (this.skinning = t.skinning),
                    (this.morphTargets = t.morphTargets),
                    (this.map = t.map),
                    (this.alphaMap = t.alphaMap),
                    (this.displacementMap = t.displacementMap),
                    (this.displacementScale = t.displacementScale),
                    (this.displacementBias = t.displacementBias),
                    (this.wireframe = t.wireframe),
                    (this.wireframeLinewidth = t.wireframeLinewidth),
                    this
                  )
                }),
                (((Bo.prototype = Object.create(Rr.prototype)).constructor =
                  Bo).prototype.isMeshDistanceMaterial = !0),
                (Bo.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    this.referencePosition.copy(t.referencePosition),
                    (this.nearDistance = t.nearDistance),
                    (this.farDistance = t.farDistance),
                    (this.skinning = t.skinning),
                    (this.morphTargets = t.morphTargets),
                    (this.map = t.map),
                    (this.alphaMap = t.alphaMap),
                    (this.displacementMap = t.displacementMap),
                    (this.displacementScale = t.displacementScale),
                    (this.displacementBias = t.displacementBias),
                    this
                  )
                })
              var No =
                  'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}',
                Uo = 'void main() {\n\tgl_Position = vec4( position, 1.0 );\n}'
              function zo(b, _, w) {
                var M = new Fi(),
                  S = new Ye(),
                  E = new Ye(),
                  T = new $e(),
                  a = [],
                  o = [],
                  v = {},
                  g = { 0: q, 1: O, 2: X },
                  A = new Pi({
                    defines: { SAMPLE_RATE: 0.25, HALF_SAMPLE_RATE: 1 / 8 },
                    uniforms: {
                      shadow_pass: { value: null },
                      resolution: { value: new Ye() },
                      radius: { value: 4 },
                    },
                    vertexShader: Uo,
                    fragmentShader: No,
                  }),
                  L = A.clone()
                L.defines.HORIZONAL_PASS = 1
                var t = new Kr()
                t.setAttribute(
                  'position',
                  new Ir(
                    new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
                    3,
                  ),
                )
                var R = new vi(t, A),
                  C = this
                function y(t, e, n) {
                  var r = (t << 0) | (e << 1) | (n << 2),
                    i = a[r]
                  return (
                    void 0 === i &&
                      ((i = new Do({
                        depthPacking: Ne,
                        morphTargets: t,
                        skinning: e,
                      })),
                      (a[r] = i)),
                    i
                  )
                }
                function x(t, e, n) {
                  var r = (t << 0) | (e << 1) | (n << 2),
                    i = o[r]
                  return (
                    void 0 === i &&
                      ((i = new Bo({ morphTargets: t, skinning: e })),
                      (o[r] = i)),
                    i
                  )
                }
                function P(t, e, n, r, i, a, o) {
                  var s,
                    c,
                    l,
                    h,
                    u,
                    p,
                    d = null,
                    f = y,
                    m = t.customDepthMaterial
                  return (
                    !0 === r.isPointLight &&
                      ((f = x), (m = t.customDistanceMaterial)),
                    (d =
                      void 0 === m
                        ? (!(s = !1) === n.morphTargets &&
                            (s =
                              e.morphAttributes &&
                              e.morphAttributes.position &&
                              0 < e.morphAttributes.position.length),
                          !(c = !1) === t.isSkinnedMesh &&
                            (!0 === n.skinning
                              ? (c = !0)
                              : console.warn(
                                  'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',
                                  t,
                                )),
                          f(s, c, !0 === t.isInstancedMesh))
                        : m),
                    b.localClippingEnabled &&
                      !0 === n.clipShadows &&
                      0 !== n.clippingPlanes.length &&
                      ((l = d.uuid),
                      (h = n.uuid),
                      void 0 === (u = v[l]) && ((u = {}), (v[l] = u)),
                      void 0 === (p = u[h]) && ((p = d.clone()), (u[h] = p)),
                      (d = p)),
                    (d.visible = n.visible),
                    (d.wireframe = n.wireframe),
                    (d.side =
                      o === H
                        ? null !== n.shadowSide
                          ? n.shadowSide
                          : n.side
                        : null !== n.shadowSide
                          ? n.shadowSide
                          : g[n.side]),
                    (d.clipShadows = n.clipShadows),
                    (d.clippingPlanes = n.clippingPlanes),
                    (d.clipIntersection = n.clipIntersection),
                    (d.wireframeLinewidth = n.wireframeLinewidth),
                    (d.linewidth = n.linewidth),
                    !0 === r.isPointLight &&
                      !0 === d.isMeshDistanceMaterial &&
                      (d.referencePosition.setFromMatrixPosition(r.matrixWorld),
                      (d.nearDistance = i),
                      (d.farDistance = a)),
                    d
                  )
                }
                ;(this.enabled = !1),
                  (this.autoUpdate = !0),
                  (this.needsUpdate = !1),
                  (this.type = z),
                  (this.render = function (t, e, n) {
                    if (
                      !1 !== C.enabled &&
                      (!1 !== C.autoUpdate || !1 !== C.needsUpdate) &&
                      0 !== t.length
                    ) {
                      var r = b.getRenderTarget(),
                        i = b.getActiveCubeFace(),
                        a = b.getActiveMipmapLevel(),
                        o = b.state
                      o.setBlending(Y),
                        o.buffers.color.setClear(1, 1, 1, 1),
                        o.buffers.depth.setTest(!0),
                        o.setScissorTest(!1)
                      for (var s, c, l, h = 0, u = t.length; h < u; h++) {
                        var p = t[h],
                          d = p.shadow
                        if (!1 !== d.autoUpdate || !1 !== d.needsUpdate)
                          if (void 0 !== d) {
                            S.copy(d.mapSize)
                            var f,
                              m,
                              v = d.getFrameExtents()
                            S.multiply(v),
                              E.copy(d.mapSize),
                              (S.x > w || S.y > w) &&
                                (S.x > w &&
                                  ((E.x = Math.floor(w / v.x)),
                                  (S.x = E.x * v.x),
                                  (d.mapSize.x = E.x)),
                                S.y > w &&
                                  ((E.y = Math.floor(w / v.y)),
                                  (S.y = E.y * v.y),
                                  (d.mapSize.y = E.y))),
                              null !== d.map ||
                                d.isPointLightShadow ||
                                this.type !== H ||
                                ((f = {
                                  minFilter: Vt,
                                  magFilter: Vt,
                                  format: $t,
                                }),
                                (d.map = new tn(S.x, S.y, f)),
                                (d.map.texture.name = p.name + '.shadowMap'),
                                (d.mapPass = new tn(S.x, S.y, f)),
                                d.camera.updateProjectionMatrix()),
                              null === d.map &&
                                ((m = {
                                  minFilter: Ht,
                                  magFilter: Ht,
                                  format: $t,
                                }),
                                (d.map = new tn(S.x, S.y, m)),
                                (d.map.texture.name = p.name + '.shadowMap'),
                                d.camera.updateProjectionMatrix()),
                              b.setRenderTarget(d.map),
                              b.clear()
                            for (
                              var g = d.getViewportCount(), y = 0;
                              y < g;
                              y++
                            ) {
                              var x = d.getViewport(y)
                              T.set(E.x * x.x, E.y * x.y, E.x * x.z, E.y * x.w),
                                o.viewport(T),
                                d.updateMatrices(p, y),
                                (M = d.getFrustum()),
                                (function t(e, n, r, i, a) {
                                  if (!1 === e.visible) return
                                  var o = e.layers.test(n.layers)
                                  if (
                                    o &&
                                    (e.isMesh || e.isLine || e.isPoints) &&
                                    (e.castShadow ||
                                      (e.receiveShadow && a === H)) &&
                                    (!e.frustumCulled || M.intersectsObject(e))
                                  ) {
                                    e.modelViewMatrix.multiplyMatrices(
                                      r.matrixWorldInverse,
                                      e.matrixWorld,
                                    )
                                    var s,
                                      c = _.update(e),
                                      l = e.material
                                    if (Array.isArray(l))
                                      for (
                                        var h = c.groups, u = 0, p = h.length;
                                        u < p;
                                        u++
                                      ) {
                                        var d,
                                          f = h[u],
                                          m = l[f.materialIndex]
                                        m &&
                                          m.visible &&
                                          ((d = P(
                                            e,
                                            c,
                                            m,
                                            i,
                                            r.near,
                                            r.far,
                                            a,
                                          )),
                                          b.renderBufferDirect(
                                            r,
                                            null,
                                            c,
                                            d,
                                            e,
                                            f,
                                          ))
                                      }
                                    else
                                      l.visible &&
                                        ((s = P(e, c, l, i, r.near, r.far, a)),
                                        b.renderBufferDirect(
                                          r,
                                          null,
                                          c,
                                          s,
                                          e,
                                          null,
                                        ))
                                  }
                                  var v = e.children
                                  for (var g = 0, y = v.length; g < y; g++)
                                    t(v[g], n, r, i, a)
                                })(e, n, d.camera, p, this.type)
                            }
                            d.isPointLightShadow ||
                              this.type !== H ||
                              ((s = d),
                              (c = n),
                              (l = void 0),
                              (l = _.update(R)),
                              (A.uniforms.shadow_pass.value = s.map.texture),
                              (A.uniforms.resolution.value = s.mapSize),
                              (A.uniforms.radius.value = s.radius),
                              b.setRenderTarget(s.mapPass),
                              b.clear(),
                              b.renderBufferDirect(c, null, l, A, R, null),
                              (L.uniforms.shadow_pass.value =
                                s.mapPass.texture),
                              (L.uniforms.resolution.value = s.mapSize),
                              (L.uniforms.radius.value = s.radius),
                              b.setRenderTarget(s.map),
                              b.clear(),
                              b.renderBufferDirect(c, null, l, L, R, null)),
                              (d.needsUpdate = !1)
                          } else
                            console.warn(
                              'THREE.WebGLShadowMap:',
                              p,
                              'has no shadow.',
                            )
                      }
                      ;(C.needsUpdate = !1), b.setRenderTarget(r, i, a)
                    }
                  })
              }
              function Fo(h, t, e) {
                var n = e.isWebGL2
                var i = new (function () {
                    var e = !1,
                      a = new $e(),
                      n = null,
                      o = new $e(0, 0, 0, 0)
                    return {
                      setMask: function (t) {
                        n === t || e || (h.colorMask(t, t, t, t), (n = t))
                      },
                      setLocked: function (t) {
                        e = t
                      },
                      setClear: function (t, e, n, r, i) {
                        !0 === i && ((t *= r), (e *= r), (n *= r)),
                          a.set(t, e, n, r),
                          !1 === o.equals(a) &&
                            (h.clearColor(t, e, n, r), o.copy(a))
                      },
                      reset: function () {
                        ;(e = !1), (n = null), o.set(-1, 0, 0, 0)
                      },
                    }
                  })(),
                  a = new (function () {
                    var e = !1,
                      n = null,
                      r = null,
                      i = null
                    return {
                      setTest: function (t) {
                        ;(t ? I : D)(2929)
                      },
                      setMask: function (t) {
                        n === t || e || (h.depthMask(t), (n = t))
                      },
                      setFunc: function (t) {
                        if (r !== t) {
                          if (t)
                            switch (t) {
                              case vt:
                                h.depthFunc(512)
                                break
                              case gt:
                                h.depthFunc(519)
                                break
                              case yt:
                                h.depthFunc(513)
                                break
                              case xt:
                                h.depthFunc(515)
                                break
                              case bt:
                                h.depthFunc(514)
                                break
                              case _t:
                                h.depthFunc(518)
                                break
                              case wt:
                                h.depthFunc(516)
                                break
                              case Mt:
                                h.depthFunc(517)
                                break
                              default:
                                h.depthFunc(515)
                            }
                          else h.depthFunc(515)
                          r = t
                        }
                      },
                      setLocked: function (t) {
                        e = t
                      },
                      setClear: function (t) {
                        i !== t && (h.clearDepth(t), (i = t))
                      },
                      reset: function () {
                        ;(e = !1), (i = r = n = null)
                      },
                    }
                  })(),
                  o = new (function () {
                    var e = !1,
                      n = null,
                      r = null,
                      i = null,
                      a = null,
                      o = null,
                      s = null,
                      c = null,
                      l = null
                    return {
                      setTest: function (t) {
                        e || (t ? I : D)(2960)
                      },
                      setMask: function (t) {
                        n === t || e || (h.stencilMask(t), (n = t))
                      },
                      setFunc: function (t, e, n) {
                        ;(r === t && i === e && a === n) ||
                          (h.stencilFunc(t, e, n), (r = t), (i = e), (a = n))
                      },
                      setOp: function (t, e, n) {
                        ;(o === t && s === e && c === n) ||
                          (h.stencilOp(t, e, n), (o = t), (s = e), (c = n))
                      },
                      setLocked: function (t) {
                        e = t
                      },
                      setClear: function (t) {
                        l !== t && (h.clearStencil(t), (l = t))
                      },
                      reset: function () {
                        ;(e = !1), (l = c = s = o = a = i = r = n = null)
                      },
                    }
                  })(),
                  r = {},
                  s = null,
                  c = null,
                  l = null,
                  u = null,
                  p = null,
                  d = null,
                  f = null,
                  m = null,
                  v = null,
                  g = !1,
                  y = null,
                  x = null,
                  b = null,
                  _ = null,
                  w = null,
                  M = h.getParameter(35661),
                  S = !1,
                  E = 0,
                  T = h.getParameter(7938)
                ;-1 !== T.indexOf('WebGL')
                  ? ((E = parseFloat(/^WebGL\ ([0-9])/.exec(T)[1])),
                    (S = 1 <= E))
                  : -1 !== T.indexOf('OpenGL ES') &&
                    ((E = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(T)[1])),
                    (S = 2 <= E))
                var A = null,
                  L = {},
                  R = new $e(),
                  C = new $e()
                function P(t, e, n) {
                  var r = new Uint8Array(4),
                    i = h.createTexture()
                  h.bindTexture(t, i),
                    h.texParameteri(t, 10241, 9728),
                    h.texParameteri(t, 10240, 9728)
                  for (var a = 0; a < n; a++)
                    h.texImage2D(e + a, 0, 6408, 1, 1, 0, 6408, 5121, r)
                  return i
                }
                var O = {}
                function I(t) {
                  !0 !== r[t] && (h.enable(t), (r[t] = !0))
                }
                function D(t) {
                  !1 !== r[t] && (h.disable(t), (r[t] = !1))
                }
                ;(O[3553] = P(3553, 3553, 1)),
                  (O[34067] = P(34067, 34069, 6)),
                  i.setClear(0, 0, 0, 1),
                  a.setClear(1),
                  o.setClear(0),
                  I(2929),
                  a.setFunc(xt),
                  F(!1),
                  H(j),
                  I(2884),
                  z(Y)
                var B,
                  N = {}
                ;(N[tt] = 32774),
                  (N[et] = 32778),
                  (N[nt] = 32779),
                  n
                    ? ((N[rt] = 32775), (N[it] = 32776))
                    : null !== (B = t.get('EXT_blend_minmax')) &&
                      ((N[rt] = B.MIN_EXT), (N[it] = B.MAX_EXT))
                var U = {}
                function z(t, e, n, r, i, a, o, s) {
                  if (t !== Y) {
                    if ((c || (I(3042), (c = !0)), t === $))
                      (i = i || e),
                        (a = a || n),
                        (o = o || r),
                        (e === u && i === f) ||
                          (h.blendEquationSeparate(N[e], N[i]),
                          (u = e),
                          (f = i)),
                        (n === p && r === d && a === m && o === v) ||
                          (h.blendFuncSeparate(U[n], U[r], U[a], U[o]),
                          (p = n),
                          (d = r),
                          (m = a),
                          (v = o)),
                        (l = t),
                        (g = null)
                    else if (t !== l || s !== g) {
                      if (
                        ((u === tt && f === tt) ||
                          (h.blendEquation(32774), (f = u = tt)),
                        s)
                      )
                        switch (t) {
                          case Z:
                            h.blendFuncSeparate(1, 771, 1, 771)
                            break
                          case J:
                            h.blendFunc(1, 1)
                            break
                          case Q:
                            h.blendFuncSeparate(0, 0, 769, 771)
                            break
                          case K:
                            h.blendFuncSeparate(0, 768, 0, 770)
                            break
                          default:
                            console.error(
                              'THREE.WebGLState: Invalid blending: ',
                              t,
                            )
                        }
                      else
                        switch (t) {
                          case Z:
                            h.blendFuncSeparate(770, 771, 1, 771)
                            break
                          case J:
                            h.blendFunc(770, 1)
                            break
                          case Q:
                            h.blendFunc(0, 769)
                            break
                          case K:
                            h.blendFunc(0, 768)
                            break
                          default:
                            console.error(
                              'THREE.WebGLState: Invalid blending: ',
                              t,
                            )
                        }
                      ;(v = m = d = p = null), (l = t), (g = s)
                    }
                  } else c && (D(3042), (c = !1))
                }
                function F(t) {
                  y !== t &&
                    (t ? h.frontFace(2304) : h.frontFace(2305), (y = t))
                }
                function H(t) {
                  t !== V
                    ? (I(2884),
                      t !== x &&
                        (t === j
                          ? h.cullFace(1029)
                          : t === W
                            ? h.cullFace(1028)
                            : h.cullFace(1032)))
                    : D(2884),
                    (x = t)
                }
                function G(t, e, n) {
                  t
                    ? (I(32823),
                      (_ === e && w === n) ||
                        (h.polygonOffset(e, n), (_ = e), (w = n)))
                    : D(32823)
                }
                function k(t) {
                  void 0 === t && (t = 33984 + M - 1),
                    A !== t && (h.activeTexture(t), (A = t))
                }
                return (
                  (U[at] = 0),
                  (U[ot] = 1),
                  (U[st] = 768),
                  (U[lt] = 770),
                  (U[mt] = 776),
                  (U[dt] = 774),
                  (U[ut] = 772),
                  (U[ct] = 769),
                  (U[ht] = 771),
                  (U[ft] = 775),
                  (U[pt] = 773),
                  {
                    buffers: { color: i, depth: a, stencil: o },
                    enable: I,
                    disable: D,
                    useProgram: function (t) {
                      return s !== t && (h.useProgram(t), (s = t), !0)
                    },
                    setBlending: z,
                    setMaterial: function (t, e) {
                      ;(t.side === X ? D : I)(2884)
                      var n = t.side === q
                      e && (n = !n),
                        F(n),
                        t.blending === Z && !1 === t.transparent
                          ? z(Y)
                          : z(
                              t.blending,
                              t.blendEquation,
                              t.blendSrc,
                              t.blendDst,
                              t.blendEquationAlpha,
                              t.blendSrcAlpha,
                              t.blendDstAlpha,
                              t.premultipliedAlpha,
                            ),
                        a.setFunc(t.depthFunc),
                        a.setTest(t.depthTest),
                        a.setMask(t.depthWrite),
                        i.setMask(t.colorWrite)
                      var r = t.stencilWrite
                      o.setTest(r),
                        r &&
                          (o.setMask(t.stencilWriteMask),
                          o.setFunc(
                            t.stencilFunc,
                            t.stencilRef,
                            t.stencilFuncMask,
                          ),
                          o.setOp(
                            t.stencilFail,
                            t.stencilZFail,
                            t.stencilZPass,
                          )),
                        G(
                          t.polygonOffset,
                          t.polygonOffsetFactor,
                          t.polygonOffsetUnits,
                        )
                    },
                    setFlipSided: F,
                    setCullFace: H,
                    setLineWidth: function (t) {
                      t !== b && (S && h.lineWidth(t), (b = t))
                    },
                    setPolygonOffset: G,
                    setScissorTest: function (t) {
                      ;(t ? I : D)(3089)
                    },
                    activeTexture: k,
                    bindTexture: function (t, e) {
                      null === A && k()
                      var n = L[A]
                      void 0 === n &&
                        ((n = { type: void 0, texture: void 0 }), (L[A] = n)),
                        (n.type === t && n.texture === e) ||
                          (h.bindTexture(t, e || O[t]),
                          (n.type = t),
                          (n.texture = e))
                    },
                    unbindTexture: function () {
                      var t = L[A]
                      void 0 !== t &&
                        void 0 !== t.type &&
                        (h.bindTexture(t.type, null),
                        (t.type = void 0),
                        (t.texture = void 0))
                    },
                    compressedTexImage2D: function () {
                      try {
                        h.compressedTexImage2D.apply(h, arguments)
                      } catch (t) {
                        console.error('THREE.WebGLState:', t)
                      }
                    },
                    texImage2D: function () {
                      try {
                        h.texImage2D.apply(h, arguments)
                      } catch (t) {
                        console.error('THREE.WebGLState:', t)
                      }
                    },
                    texImage3D: function () {
                      try {
                        h.texImage3D.apply(h, arguments)
                      } catch (t) {
                        console.error('THREE.WebGLState:', t)
                      }
                    },
                    scissor: function (t) {
                      !1 === R.equals(t) &&
                        (h.scissor(t.x, t.y, t.z, t.w), R.copy(t))
                    },
                    viewport: function (t) {
                      !1 === C.equals(t) &&
                        (h.viewport(t.x, t.y, t.z, t.w), C.copy(t))
                    },
                    reset: function () {
                      ;(r = {}),
                        (L = {}),
                        (x = y = l = s = A = null),
                        i.reset(),
                        a.reset(),
                        o.reset()
                    },
                  }
                )
              }
              function Ho(_, i, w, M, a, S, p) {
                var l,
                  E = a.isWebGL2,
                  e = a.maxTextures,
                  T = a.maxCubemapSize,
                  x = a.maxTextureSize,
                  n = a.maxSamples,
                  o = new WeakMap(),
                  r = !1
                try {
                  r =
                    'undefined' != typeof OffscreenCanvas &&
                    null !== new OffscreenCanvas(1, 1).getContext('2d')
                } catch (t) {}
                function h(t, e) {
                  return r
                    ? new OffscreenCanvas(t, e)
                    : document.createElementNS(
                        'http://www.w3.org/1999/xhtml',
                        'canvas',
                      )
                }
                function A(t, e, n, r) {
                  var i = 1
                  if (
                    ((t.width > r || t.height > r) &&
                      (i = r / Math.max(t.width, t.height)),
                    i < 1 || !0 === e)
                  ) {
                    if (
                      ('undefined' != typeof HTMLImageElement &&
                        t instanceof HTMLImageElement) ||
                      ('undefined' != typeof HTMLCanvasElement &&
                        t instanceof HTMLCanvasElement) ||
                      ('undefined' != typeof ImageBitmap &&
                        t instanceof ImageBitmap)
                    ) {
                      var a = e ? Xe.floorPowerOfTwo : Math.floor,
                        o = a(i * t.width),
                        s = a(i * t.height)
                      void 0 === l && (l = h(o, s))
                      var c = n ? h(o, s) : l
                      return (
                        (c.width = o),
                        (c.height = s),
                        c.getContext('2d').drawImage(t, 0, 0, o, s),
                        console.warn(
                          'THREE.WebGLRenderer: Texture has been resized from (' +
                            t.width +
                            'x' +
                            t.height +
                            ') to (' +
                            o +
                            'x' +
                            s +
                            ').',
                        ),
                        c
                      )
                    }
                    return (
                      'data' in t &&
                        console.warn(
                          'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                            t.width +
                            'x' +
                            t.height +
                            ').',
                        ),
                      t
                    )
                  }
                  return t
                }
                function L(t) {
                  return Xe.isPowerOfTwo(t.width) && Xe.isPowerOfTwo(t.height)
                }
                function R(t, e) {
                  return (
                    t.generateMipmaps &&
                    e &&
                    t.minFilter !== Ht &&
                    t.minFilter !== Vt
                  )
                }
                function C(t, e, n, r) {
                  _.generateMipmap(t),
                    (M.get(e).__maxMipLevel =
                      Math.log(Math.max(n, r)) * Math.LOG2E)
                }
                function P(t, e, n) {
                  if (!1 === E) return e
                  if (null !== t) {
                    if (void 0 !== _[t]) return _[t]
                    console.warn(
                      "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                        t +
                        "'",
                    )
                  }
                  var r = e
                  return (
                    6403 === e &&
                      (5126 === n && (r = 33326),
                      5131 === n && (r = 33325),
                      5121 === n && (r = 33321)),
                    6407 === e &&
                      (5126 === n && (r = 34837),
                      5131 === n && (r = 34843),
                      5121 === n && (r = 32849)),
                    6408 === e &&
                      (5126 === n && (r = 34836),
                      5131 === n && (r = 34842),
                      5121 === n && (r = 32856)),
                    (33325 !== r &&
                      33326 !== r &&
                      34842 !== r &&
                      34836 !== r) ||
                      i.get('EXT_color_buffer_float'),
                    r
                  )
                }
                function s(t) {
                  return t === Ht || t === Gt || t === kt ? 9728 : 9729
                }
                function c(t) {
                  var e = t.target
                  e.removeEventListener('dispose', c),
                    (function (t) {
                      var e = M.get(t)
                      if (void 0 === e.__webglInit) return
                      _.deleteTexture(e.__webglTexture), M.remove(t)
                    })(e),
                    e.isVideoTexture && o.delete(e),
                    p.memory.textures--
                }
                function d(t) {
                  var e = t.target
                  e.removeEventListener('dispose', d),
                    (function (t) {
                      var e = M.get(t),
                        n = M.get(t.texture)
                      if (!t) return
                      void 0 !== n.__webglTexture &&
                        _.deleteTexture(n.__webglTexture)
                      t.depthTexture && t.depthTexture.dispose()
                      if (t.isWebGLCubeRenderTarget)
                        for (var r = 0; r < 6; r++)
                          _.deleteFramebuffer(e.__webglFramebuffer[r]),
                            e.__webglDepthbuffer &&
                              _.deleteRenderbuffer(e.__webglDepthbuffer[r])
                      else
                        _.deleteFramebuffer(e.__webglFramebuffer),
                          e.__webglDepthbuffer &&
                            _.deleteRenderbuffer(e.__webglDepthbuffer),
                          e.__webglMultisampledFramebuffer &&
                            _.deleteFramebuffer(
                              e.__webglMultisampledFramebuffer,
                            ),
                          e.__webglColorRenderbuffer &&
                            _.deleteRenderbuffer(e.__webglColorRenderbuffer),
                          e.__webglDepthRenderbuffer &&
                            _.deleteRenderbuffer(e.__webglDepthRenderbuffer)
                      M.remove(t.texture), M.remove(t)
                    })(e),
                    p.memory.textures--
                }
                var u = 0
                function f(t, e) {
                  var n,
                    r,
                    i = M.get(t)
                  if (
                    (t.isVideoTexture &&
                      ((n = t),
                      (r = p.render.frame),
                      o.get(n) !== r && (o.set(n, r), n.update())),
                    0 < t.version && i.__version !== t.version)
                  ) {
                    var a = t.image
                    if (void 0 === a)
                      console.warn(
                        'THREE.WebGLRenderer: Texture marked for update but image is undefined',
                      )
                    else {
                      if (!1 !== a.complete) return void b(i, t, e)
                      console.warn(
                        'THREE.WebGLRenderer: Texture marked for update but image is incomplete',
                      )
                    }
                  }
                  w.activeTexture(33984 + e),
                    w.bindTexture(3553, i.__webglTexture)
                }
                function m(t, e) {
                  if (6 === t.image.length) {
                    var n = M.get(t)
                    if (0 < t.version && n.__version !== t.version) {
                      I(n, t),
                        w.activeTexture(33984 + e),
                        w.bindTexture(34067, n.__webglTexture),
                        _.pixelStorei(37440, t.flipY)
                      for (
                        var r =
                            t &&
                            (t.isCompressedTexture ||
                              t.image[0].isCompressedTexture),
                          i = t.image[0] && t.image[0].isDataTexture,
                          a = [],
                          o = 0;
                        o < 6;
                        o++
                      )
                        a[o] =
                          r || i
                            ? i
                              ? t.image[o].image
                              : t.image[o]
                            : A(t.image[o], !1, !0, T)
                      var s,
                        c = a[0],
                        l = L(c) || E,
                        h = S.convert(t.format),
                        u = S.convert(t.type),
                        p = P(t.internalFormat, h, u)
                      if ((O(34067, t, l), r)) {
                        for (var d = 0; d < 6; d++) {
                          s = a[d].mipmaps
                          for (var f = 0; f < s.length; f++) {
                            var m = s[f]
                            t.format !== $t && t.format !== Kt
                              ? null !== h
                                ? w.compressedTexImage2D(
                                    34069 + d,
                                    f,
                                    p,
                                    m.width,
                                    m.height,
                                    0,
                                    m.data,
                                  )
                                : console.warn(
                                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                                  )
                              : w.texImage2D(
                                  34069 + d,
                                  f,
                                  p,
                                  m.width,
                                  m.height,
                                  0,
                                  h,
                                  u,
                                  m.data,
                                )
                          }
                        }
                        n.__maxMipLevel = s.length - 1
                      } else {
                        s = t.mipmaps
                        for (var v = 0; v < 6; v++)
                          if (i) {
                            w.texImage2D(
                              34069 + v,
                              0,
                              p,
                              a[v].width,
                              a[v].height,
                              0,
                              h,
                              u,
                              a[v].data,
                            )
                            for (var g = 0; g < s.length; g++) {
                              var y = s[g].image[v].image
                              w.texImage2D(
                                34069 + v,
                                g + 1,
                                p,
                                y.width,
                                y.height,
                                0,
                                h,
                                u,
                                y.data,
                              )
                            }
                          } else {
                            w.texImage2D(34069 + v, 0, p, h, u, a[v])
                            for (var x = 0; x < s.length; x++) {
                              var b = s[x]
                              w.texImage2D(
                                34069 + v,
                                x + 1,
                                p,
                                h,
                                u,
                                b.image[v],
                              )
                            }
                          }
                        n.__maxMipLevel = s.length
                      }
                      R(t, l) && C(34067, t, c.width, c.height),
                        (n.__version = t.version),
                        t.onUpdate && t.onUpdate(t)
                    } else
                      w.activeTexture(33984 + e),
                        w.bindTexture(34067, n.__webglTexture)
                  }
                }
                function v(t, e) {
                  w.activeTexture(33984 + e),
                    w.bindTexture(34067, M.get(t).__webglTexture)
                }
                var g = {}
                ;(g[Ut] = 10497), (g[zt] = 33071), (g[Ft] = 33648)
                var y = {}
                function O(t, e, n) {
                  n
                    ? (_.texParameteri(t, 10242, g[e.wrapS]),
                      _.texParameteri(t, 10243, g[e.wrapT]),
                      (32879 !== t && 35866 !== t) ||
                        _.texParameteri(t, 32882, g[e.wrapR]),
                      _.texParameteri(t, 10240, y[e.magFilter]),
                      _.texParameteri(t, 10241, y[e.minFilter]))
                    : (_.texParameteri(t, 10242, 33071),
                      _.texParameteri(t, 10243, 33071),
                      (32879 !== t && 35866 !== t) ||
                        _.texParameteri(t, 32882, 33071),
                      (e.wrapS === zt && e.wrapT === zt) ||
                        console.warn(
                          'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',
                        ),
                      _.texParameteri(t, 10240, s(e.magFilter)),
                      _.texParameteri(t, 10241, s(e.minFilter)),
                      e.minFilter !== Ht &&
                        e.minFilter !== Vt &&
                        console.warn(
                          'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',
                        ))
                  var r = i.get('EXT_texture_filter_anisotropic')
                  if (r) {
                    if (
                      e.type === Zt &&
                      null === i.get('OES_texture_float_linear')
                    )
                      return
                    if (
                      e.type === Jt &&
                      null === (E || i.get('OES_texture_half_float_linear'))
                    )
                      return
                    ;(1 < e.anisotropy || M.get(e).__currentAnisotropy) &&
                      (_.texParameterf(
                        t,
                        r.TEXTURE_MAX_ANISOTROPY_EXT,
                        Math.min(e.anisotropy, a.getMaxAnisotropy()),
                      ),
                      (M.get(e).__currentAnisotropy = e.anisotropy))
                  }
                }
                function I(t, e) {
                  void 0 === t.__webglInit &&
                    ((t.__webglInit = !0),
                    e.addEventListener('dispose', c),
                    (t.__webglTexture = _.createTexture()),
                    p.memory.textures++)
                }
                function b(t, e, n) {
                  var r = 3553
                  e.isDataTexture2DArray && (r = 35866),
                    e.isDataTexture3D && (r = 32879),
                    I(t, e),
                    w.activeTexture(33984 + n),
                    w.bindTexture(r, t.__webglTexture),
                    _.pixelStorei(37440, e.flipY),
                    _.pixelStorei(37441, e.premultiplyAlpha),
                    _.pixelStorei(3317, e.unpackAlignment)
                  var i,
                    a,
                    o =
                      ((i = e),
                      !E &&
                        (i.wrapS !== zt ||
                          i.wrapT !== zt ||
                          (i.minFilter !== Ht && i.minFilter !== Vt)) &&
                        !1 === L(e.image)),
                    s = A(e.image, o, !1, x),
                    c = L(s) || E,
                    l = S.convert(e.format),
                    h = S.convert(e.type),
                    u = P(e.internalFormat, l, h)
                  O(r, e, c)
                  var p = e.mipmaps
                  if (e.isDepthTexture)
                    (u = 6402),
                      E
                        ? (u =
                            e.type === Zt
                              ? 36012
                              : e.type === Yt
                                ? 33190
                                : e.type === Qt
                                  ? 35056
                                  : 33189)
                        : e.type === Zt &&
                          console.error(
                            'WebGLRenderer: Floating point depth texture requires WebGL2.',
                          ),
                      e.format === te &&
                        6402 === u &&
                        e.type !== Xt &&
                        e.type !== Yt &&
                        (console.warn(
                          'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.',
                        ),
                        (e.type = Xt),
                        (h = S.convert(e.type))),
                      e.format === ee &&
                        6402 === u &&
                        ((u = 34041),
                        e.type !== Qt &&
                          (console.warn(
                            'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.',
                          ),
                          (e.type = Qt),
                          (h = S.convert(e.type)))),
                      w.texImage2D(3553, 0, u, s.width, s.height, 0, l, h, null)
                  else if (e.isDataTexture)
                    if (0 < p.length && c) {
                      for (var d = 0, f = p.length; d < f; d++)
                        (a = p[d]),
                          w.texImage2D(
                            3553,
                            d,
                            u,
                            a.width,
                            a.height,
                            0,
                            l,
                            h,
                            a.data,
                          )
                      ;(e.generateMipmaps = !1),
                        (t.__maxMipLevel = p.length - 1)
                    } else
                      w.texImage2D(
                        3553,
                        0,
                        u,
                        s.width,
                        s.height,
                        0,
                        l,
                        h,
                        s.data,
                      ),
                        (t.__maxMipLevel = 0)
                  else if (e.isCompressedTexture) {
                    for (var m = 0, v = p.length; m < v; m++)
                      (a = p[m]),
                        e.format !== $t && e.format !== Kt
                          ? null !== l
                            ? w.compressedTexImage2D(
                                3553,
                                m,
                                u,
                                a.width,
                                a.height,
                                0,
                                a.data,
                              )
                            : console.warn(
                                'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                              )
                          : w.texImage2D(
                              3553,
                              m,
                              u,
                              a.width,
                              a.height,
                              0,
                              l,
                              h,
                              a.data,
                            )
                    t.__maxMipLevel = p.length - 1
                  } else if (e.isDataTexture2DArray)
                    w.texImage3D(
                      35866,
                      0,
                      u,
                      s.width,
                      s.height,
                      s.depth,
                      0,
                      l,
                      h,
                      s.data,
                    ),
                      (t.__maxMipLevel = 0)
                  else if (e.isDataTexture3D)
                    w.texImage3D(
                      32879,
                      0,
                      u,
                      s.width,
                      s.height,
                      s.depth,
                      0,
                      l,
                      h,
                      s.data,
                    ),
                      (t.__maxMipLevel = 0)
                  else if (0 < p.length && c) {
                    for (var g = 0, y = p.length; g < y; g++)
                      (a = p[g]), w.texImage2D(3553, g, u, l, h, a)
                    ;(e.generateMipmaps = !1), (t.__maxMipLevel = p.length - 1)
                  } else
                    w.texImage2D(3553, 0, u, l, h, s), (t.__maxMipLevel = 0)
                  R(e, c) && C(r, e, s.width, s.height),
                    (t.__version = e.version),
                    e.onUpdate && e.onUpdate(e)
                }
                function D(t, e, n, r) {
                  var i = S.convert(e.texture.format),
                    a = S.convert(e.texture.type),
                    o = P(e.texture.internalFormat, i, a)
                  w.texImage2D(r, 0, o, e.width, e.height, 0, i, a, null),
                    _.bindFramebuffer(36160, t),
                    _.framebufferTexture2D(
                      36160,
                      n,
                      r,
                      M.get(e.texture).__webglTexture,
                      0,
                    ),
                    _.bindFramebuffer(36160, null)
                }
                function B(t, e, n) {
                  var r, i, a, o, s, c, l, h
                  _.bindRenderbuffer(36161, t),
                    e.depthBuffer && !e.stencilBuffer
                      ? ((r = 33189),
                        n
                          ? ((i = e.depthTexture) &&
                              i.isDepthTexture &&
                              (i.type === Zt
                                ? (r = 36012)
                                : i.type === Yt && (r = 33190)),
                            (a = U(e)),
                            _.renderbufferStorageMultisample(
                              36161,
                              a,
                              r,
                              e.width,
                              e.height,
                            ))
                          : _.renderbufferStorage(36161, r, e.width, e.height),
                        _.framebufferRenderbuffer(36160, 36096, 36161, t))
                      : e.depthBuffer && e.stencilBuffer
                        ? (n
                            ? ((o = U(e)),
                              _.renderbufferStorageMultisample(
                                36161,
                                o,
                                35056,
                                e.width,
                                e.height,
                              ))
                            : _.renderbufferStorage(
                                36161,
                                34041,
                                e.width,
                                e.height,
                              ),
                          _.framebufferRenderbuffer(36160, 33306, 36161, t))
                        : ((s = S.convert(e.texture.format)),
                          (c = S.convert(e.texture.type)),
                          (l = P(e.texture.internalFormat, s, c)),
                          n
                            ? ((h = U(e)),
                              _.renderbufferStorageMultisample(
                                36161,
                                h,
                                l,
                                e.width,
                                e.height,
                              ))
                            : _.renderbufferStorage(
                                36161,
                                l,
                                e.width,
                                e.height,
                              )),
                    _.bindRenderbuffer(36161, null)
                }
                function N(t) {
                  var e = M.get(t),
                    n = !0 === t.isWebGLCubeRenderTarget
                  if (t.depthTexture) {
                    if (n)
                      throw new Error(
                        'target.depthTexture not supported in Cube render targets',
                      )
                    !(function (t, e) {
                      if (e && e.isWebGLCubeRenderTarget)
                        throw new Error(
                          'Depth Texture with cube render targets is not supported',
                        )
                      if (
                        (_.bindFramebuffer(36160, t),
                        !e.depthTexture || !e.depthTexture.isDepthTexture)
                      )
                        throw new Error(
                          'renderTarget.depthTexture must be an instance of THREE.DepthTexture',
                        )
                      ;(M.get(e.depthTexture).__webglTexture &&
                        e.depthTexture.image.width === e.width &&
                        e.depthTexture.image.height === e.height) ||
                        ((e.depthTexture.image.width = e.width),
                        (e.depthTexture.image.height = e.height),
                        (e.depthTexture.needsUpdate = !0)),
                        f(e.depthTexture, 0)
                      var n = M.get(e.depthTexture).__webglTexture
                      if (e.depthTexture.format === te)
                        _.framebufferTexture2D(36160, 36096, 3553, n, 0)
                      else {
                        if (e.depthTexture.format !== ee)
                          throw new Error('Unknown depthTexture format')
                        _.framebufferTexture2D(36160, 33306, 3553, n, 0)
                      }
                    })(e.__webglFramebuffer, t)
                  } else if (n) {
                    e.__webglDepthbuffer = []
                    for (var r = 0; r < 6; r++)
                      _.bindFramebuffer(36160, e.__webglFramebuffer[r]),
                        (e.__webglDepthbuffer[r] = _.createRenderbuffer()),
                        B(e.__webglDepthbuffer[r], t, !1)
                  } else
                    _.bindFramebuffer(36160, e.__webglFramebuffer),
                      (e.__webglDepthbuffer = _.createRenderbuffer()),
                      B(e.__webglDepthbuffer, t, !1)
                  _.bindFramebuffer(36160, null)
                }
                function U(t) {
                  return E && t.isWebGLMultisampleRenderTarget
                    ? Math.min(n, t.samples)
                    : 0
                }
                ;(y[Ht] = 9728),
                  (y[Gt] = 9984),
                  (y[kt] = 9986),
                  (y[Vt] = 9729),
                  (y[jt] = 9985)
                var z = !(y[Wt] = 9987),
                  F = !1
                ;(this.allocateTextureUnit = function () {
                  var t = u
                  return (
                    e <= t &&
                      console.warn(
                        'THREE.WebGLTextures: Trying to use ' +
                          t +
                          ' texture units while this GPU supports only ' +
                          e,
                      ),
                    (u += 1),
                    t
                  )
                }),
                  (this.resetTextureUnits = function () {
                    u = 0
                  }),
                  (this.setTexture2D = f),
                  (this.setTexture2DArray = function (t, e) {
                    var n = M.get(t)
                    0 < t.version && n.__version !== t.version
                      ? b(n, t, e)
                      : (w.activeTexture(33984 + e),
                        w.bindTexture(35866, n.__webglTexture))
                  }),
                  (this.setTexture3D = function (t, e) {
                    var n = M.get(t)
                    0 < t.version && n.__version !== t.version
                      ? b(n, t, e)
                      : (w.activeTexture(33984 + e),
                        w.bindTexture(32879, n.__webglTexture))
                  }),
                  (this.setTextureCube = m),
                  (this.setTextureCubeDynamic = v),
                  (this.setupRenderTarget = function (t) {
                    var e = M.get(t),
                      n = M.get(t.texture)
                    t.addEventListener('dispose', d),
                      (n.__webglTexture = _.createTexture()),
                      p.memory.textures++
                    var r,
                      i,
                      a,
                      o,
                      s = !0 === t.isWebGLCubeRenderTarget,
                      c = !0 === t.isWebGLMultisampleRenderTarget,
                      l = L(t) || E
                    if (
                      (!E ||
                        t.texture.format !== Kt ||
                        (t.texture.type !== Zt && t.texture.type !== Jt) ||
                        ((t.texture.format = $t),
                        console.warn(
                          'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.',
                        )),
                      s)
                    ) {
                      e.__webglFramebuffer = []
                      for (var h = 0; h < 6; h++)
                        e.__webglFramebuffer[h] = _.createFramebuffer()
                    } else {
                      ;(e.__webglFramebuffer = _.createFramebuffer()),
                        c &&
                          (E
                            ? ((e.__webglMultisampledFramebuffer =
                                _.createFramebuffer()),
                              (e.__webglColorRenderbuffer =
                                _.createRenderbuffer()),
                              _.bindRenderbuffer(
                                36161,
                                e.__webglColorRenderbuffer,
                              ),
                              (r = S.convert(t.texture.format)),
                              (i = S.convert(t.texture.type)),
                              (a = P(t.texture.internalFormat, r, i)),
                              (o = U(t)),
                              _.renderbufferStorageMultisample(
                                36161,
                                o,
                                a,
                                t.width,
                                t.height,
                              ),
                              _.bindFramebuffer(
                                36160,
                                e.__webglMultisampledFramebuffer,
                              ),
                              _.framebufferRenderbuffer(
                                36160,
                                36064,
                                36161,
                                e.__webglColorRenderbuffer,
                              ),
                              _.bindRenderbuffer(36161, null),
                              t.depthBuffer &&
                                ((e.__webglDepthRenderbuffer =
                                  _.createRenderbuffer()),
                                B(e.__webglDepthRenderbuffer, t, !0)),
                              _.bindFramebuffer(36160, null))
                            : console.warn(
                                'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
                              ))
                    }
                    if (s) {
                      w.bindTexture(34067, n.__webglTexture),
                        O(34067, t.texture, l)
                      for (var u = 0; u < 6; u++)
                        D(e.__webglFramebuffer[u], t, 36064, 34069 + u)
                      R(t.texture, l) && C(34067, t.texture, t.width, t.height),
                        w.bindTexture(34067, null)
                    } else
                      w.bindTexture(3553, n.__webglTexture),
                        O(3553, t.texture, l),
                        D(e.__webglFramebuffer, t, 36064, 3553),
                        R(t.texture, l) &&
                          C(3553, t.texture, t.width, t.height),
                        w.bindTexture(3553, null)
                    t.depthBuffer && N(t)
                  }),
                  (this.updateRenderTargetMipmap = function (t) {
                    var e,
                      n,
                      r = t.texture
                    R(r, L(t) || E) &&
                      ((e = t.isWebGLCubeRenderTarget ? 34067 : 3553),
                      (n = M.get(r).__webglTexture),
                      w.bindTexture(e, n),
                      C(e, r, t.width, t.height),
                      w.bindTexture(e, null))
                  }),
                  (this.updateMultisampleRenderTarget = function (t) {
                    var e, n, r, i
                    t.isWebGLMultisampleRenderTarget &&
                      (E
                        ? ((e = M.get(t)),
                          _.bindFramebuffer(
                            36008,
                            e.__webglMultisampledFramebuffer,
                          ),
                          _.bindFramebuffer(36009, e.__webglFramebuffer),
                          (n = t.width),
                          (r = t.height),
                          (i = 16384),
                          t.depthBuffer && (i |= 256),
                          t.stencilBuffer && (i |= 1024),
                          _.blitFramebuffer(0, 0, n, r, 0, 0, n, r, i, 9728),
                          _.bindFramebuffer(
                            36160,
                            e.__webglMultisampledFramebuffer,
                          ))
                        : console.warn(
                            'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
                          ))
                  }),
                  (this.safeSetTexture2D = function (t, e) {
                    t &&
                      t.isWebGLRenderTarget &&
                      (!1 === z &&
                        (console.warn(
                          "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.",
                        ),
                        (z = !0)),
                      (t = t.texture)),
                      f(t, e)
                  }),
                  (this.safeSetTextureCube = function (t, e) {
                    t &&
                      t.isWebGLCubeRenderTarget &&
                      (!1 === F &&
                        (console.warn(
                          "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.",
                        ),
                        (F = !0)),
                      (t = t.texture)),
                      ((t && t.isCubeTexture) ||
                        (Array.isArray(t.image) && 6 === t.image.length)
                        ? m
                        : v)(t, e)
                  })
              }
              function Go(t, n, e) {
                var r = e.isWebGL2
                return {
                  convert: function (t) {
                    var e
                    if (t === qt) return 5121
                    if (t === s) return 32819
                    if (t === c) return 32820
                    if (t === l) return 33635
                    if (t === i) return 5120
                    if (t === a) return 5122
                    if (t === Xt) return 5123
                    if (t === o) return 5124
                    if (t === Yt) return 5125
                    if (t === Zt) return 5126
                    if (t === Jt)
                      return r
                        ? 5131
                        : null !== (e = n.get('OES_texture_half_float'))
                          ? e.HALF_FLOAT_OES
                          : null
                    if (t === h) return 6406
                    if (t === Kt) return 6407
                    if (t === $t) return 6408
                    if (t === u) return 6409
                    if (t === p) return 6410
                    if (t === te) return 6402
                    if (t === ee) return 34041
                    if (t === f) return 6403
                    if (t === m) return 36244
                    if (t === v) return 33319
                    if (t === g) return 33320
                    if (t === y) return 36248
                    if (t === x) return 36249
                    if (t === b || t === _ || t === w || t === M) {
                      if (null === (e = n.get('WEBGL_compressed_texture_s3tc')))
                        return null
                      if (t === b) return e.COMPRESSED_RGB_S3TC_DXT1_EXT
                      if (t === _) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT
                      if (t === w) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT
                      if (t === M) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (t === S || t === E || t === T || t === A) {
                      if (
                        null === (e = n.get('WEBGL_compressed_texture_pvrtc'))
                      )
                        return null
                      if (t === S) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
                      if (t === E) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
                      if (t === T) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
                      if (t === A) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (t === L)
                      return null !==
                        (e = n.get('WEBGL_compressed_texture_etc1'))
                        ? e.COMPRESSED_RGB_ETC1_WEBGL
                        : null
                    if (
                      (t === R || t === C) &&
                      null !== (e = n.get('WEBGL_compressed_texture_etc'))
                    ) {
                      if (t === R) return e.COMPRESSED_RGB8_ETC2
                      if (t === C) return e.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    return t === P ||
                      t === I ||
                      t === D ||
                      t === B ||
                      t === N ||
                      t === U ||
                      t === ne ||
                      t === re ||
                      t === ie ||
                      t === ae ||
                      t === oe ||
                      t === se ||
                      t === ce ||
                      t === le ||
                      t === ue ||
                      t === pe ||
                      t === de ||
                      t === fe ||
                      t === me ||
                      t === ve ||
                      t === ge ||
                      t === ye ||
                      t === xe ||
                      t === be ||
                      t === _e ||
                      t === we ||
                      t === Me ||
                      t === Se
                      ? null !== (e = n.get('WEBGL_compressed_texture_astc'))
                        ? t
                        : null
                      : t === he
                        ? null !== (e = n.get('EXT_texture_compression_bptc'))
                          ? t
                          : null
                        : t === Qt
                          ? r
                            ? 34042
                            : null !== (e = n.get('WEBGL_depth_texture'))
                              ? e.UNSIGNED_INT_24_8_WEBGL
                              : null
                          : void 0
                  },
                }
              }
              function ko(t) {
                Ii.call(this), (this.cameras = t || [])
              }
              function Vo() {
                On.call(this), (this.type = 'Group')
              }
              function jo() {
                ;(this._targetRay = null), (this._grip = null)
              }
              function Wo(d, i) {
                var e = this,
                  f = null,
                  a = 1,
                  m = null,
                  o = 'local-floor',
                  v = null,
                  g = [],
                  l = new Map(),
                  s = new Ii()
                s.layers.enable(1), (s.viewport = new $e())
                var c = new Ii()
                c.layers.enable(2), (c.viewport = new $e())
                var y = [s, c],
                  x = new ko()
                x.layers.enable(1), x.layers.enable(2)
                var h = null,
                  u = null
                function p(t) {
                  var e = l.get(t.inputSource)
                  e && e.dispatchEvent({ type: t.type })
                }
                function b() {
                  l.forEach(function (t, e) {
                    t.disconnect(e)
                  }),
                    l.clear(),
                    d.setFramebuffer(null),
                    d.setRenderTarget(d.getRenderTarget()),
                    n.stop(),
                    (e.isPresenting = !1),
                    e.dispatchEvent({ type: 'sessionend' })
                }
                function _(t) {
                  ;(m = t),
                    n.setContext(f),
                    n.start(),
                    (e.isPresenting = !0),
                    e.dispatchEvent({ type: 'sessionstart' })
                }
                function w(t) {
                  for (var e = f.inputSources, n = 0; n < g.length; n++)
                    l.set(e[n], g[n])
                  for (var r = 0; r < t.removed.length; r++) {
                    var i = t.removed[r],
                      a = l.get(i)
                    a &&
                      (a.dispatchEvent({ type: 'disconnected', data: i }),
                      l.delete(i))
                  }
                  for (var o = 0; o < t.added.length; o++) {
                    var s = t.added[o],
                      c = l.get(s)
                    c && c.dispatchEvent({ type: 'connected', data: s })
                  }
                }
                ;(this.enabled = !1),
                  (this.isPresenting = !1),
                  (this.getController = function (t) {
                    var e = g[t]
                    return (
                      void 0 === e && ((e = new jo()), (g[t] = e)),
                      e.getTargetRaySpace()
                    )
                  }),
                  (this.getControllerGrip = function (t) {
                    var e = g[t]
                    return (
                      void 0 === e && ((e = new jo()), (g[t] = e)),
                      e.getGripSpace()
                    )
                  }),
                  (this.setFramebufferScaleFactor = function (t) {
                    ;(a = t),
                      !0 === e.isPresenting &&
                        console.warn(
                          'THREE.WebXRManager: Cannot change framebuffer scale while presenting.',
                        )
                  }),
                  (this.setReferenceSpaceType = function (t) {
                    ;(o = t),
                      !0 === e.isPresenting &&
                        console.warn(
                          'THREE.WebXRManager: Cannot change reference space type while presenting.',
                        )
                  }),
                  (this.getReferenceSpace = function () {
                    return m
                  }),
                  (this.getSession = function () {
                    return f
                  }),
                  (this.setSession = function (t) {
                    var e, n, r
                    null !== (f = t) &&
                      (f.addEventListener('select', p),
                      f.addEventListener('selectstart', p),
                      f.addEventListener('selectend', p),
                      f.addEventListener('squeeze', p),
                      f.addEventListener('squeezestart', p),
                      f.addEventListener('squeezeend', p),
                      f.addEventListener('end', b),
                      !0 !== (e = i.getContextAttributes()).xrCompatible &&
                        i.makeXRCompatible(),
                      (n = {
                        antialias: e.antialias,
                        alpha: e.alpha,
                        depth: e.depth,
                        stencil: e.stencil,
                        framebufferScaleFactor: a,
                      }),
                      (r = new XRWebGLLayer(f, i, n)),
                      f.updateRenderState({ baseLayer: r }),
                      f.requestReferenceSpace(o).then(_),
                      f.addEventListener('inputsourceschange', w))
                  })
                var M = new on(),
                  S = new on()
                function E(t, e) {
                  null === e
                    ? t.matrixWorld.copy(t.matrix)
                    : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                    t.matrixWorldInverse.getInverse(t.matrixWorld)
                }
                this.getCamera = function (t) {
                  ;(x.near = c.near = s.near = t.near),
                    (x.far = c.far = s.far = t.far),
                    (h === x.near && u === x.far) ||
                      (f.updateRenderState({
                        depthNear: x.near,
                        depthFar: x.far,
                      }),
                      (h = x.near),
                      (u = x.far))
                  var e = t.parent,
                    n = x.cameras
                  E(x, e)
                  for (var r = 0; r < n.length; r++) E(n[r], e)
                  t.matrixWorld.copy(x.matrixWorld)
                  for (var i = t.children, a = 0, o = i.length; a < o; a++)
                    i[a].updateMatrixWorld(!0)
                  return (
                    2 === n.length
                      ? (function (t, e, n) {
                          M.setFromMatrixPosition(e.matrixWorld),
                            S.setFromMatrixPosition(n.matrixWorld)
                          var r = M.distanceTo(S),
                            i = e.projectionMatrix.elements,
                            a = n.projectionMatrix.elements,
                            o = i[14] / (i[10] - 1),
                            s = i[14] / (i[10] + 1),
                            c = (i[9] + 1) / i[5],
                            l = (i[9] - 1) / i[5],
                            h = (i[8] - 1) / i[0],
                            u = (a[8] + 1) / a[0],
                            p = o * h,
                            d = o * u,
                            f = r / (u - h),
                            m = f * -h
                          e.matrixWorld.decompose(
                            t.position,
                            t.quaternion,
                            t.scale,
                          ),
                            t.translateX(m),
                            t.translateZ(f),
                            t.matrixWorld.compose(
                              t.position,
                              t.quaternion,
                              t.scale,
                            ),
                            t.matrixWorldInverse.getInverse(t.matrixWorld)
                          var v = o + f,
                            g = s + f,
                            y = p - m,
                            x = r - m + d,
                            b = ((c * s) / g) * v,
                            _ = ((l * s) / g) * v
                          t.projectionMatrix.makePerspective(y, x, b, _, v, g)
                        })(x, s, c)
                      : x.projectionMatrix.copy(s.projectionMatrix),
                    x
                  )
                }
                var T = null
                var n = new Gi()
                n.setAnimationLoop(function (t, e) {
                  if (null !== (v = e.getViewerPose(m))) {
                    var n = v.views,
                      r = f.renderState.baseLayer
                    d.setFramebuffer(r.framebuffer)
                    var i = !1
                    n.length !== x.cameras.length &&
                      (i = !(x.cameras.length = 0))
                    for (var a = 0; a < n.length; a++) {
                      var o = n[a],
                        s = r.getViewport(o),
                        c = y[a]
                      c.matrix.fromArray(o.transform.matrix),
                        c.projectionMatrix.fromArray(o.projectionMatrix),
                        c.viewport.set(s.x, s.y, s.width, s.height),
                        0 === a && x.matrix.copy(c.matrix),
                        !0 === i && x.cameras.push(c)
                    }
                  }
                  for (var l = f.inputSources, h = 0; h < g.length; h++) {
                    var u = g[h],
                      p = l[h]
                    u.update(p, e, m)
                  }
                  T && T(t, e)
                }),
                  (this.setAnimationLoop = function (t) {
                    T = t
                  }),
                  (this.dispose = function () {})
              }
              function qo(o) {
                function d(t, e, n) {
                  ;(t.opacity.value = e.opacity),
                    e.color && t.diffuse.value.copy(e.color),
                    e.emissive &&
                      t.emissive.value
                        .copy(e.emissive)
                        .multiplyScalar(e.emissiveIntensity),
                    e.map && (t.map.value = e.map),
                    e.alphaMap && (t.alphaMap.value = e.alphaMap),
                    e.specularMap && (t.specularMap.value = e.specularMap)
                  var r,
                    i,
                    a = e.envMap || n
                  a &&
                    ((t.envMap.value = a),
                    (t.flipEnvMap.value = a.isCubeTexture ? -1 : 1),
                    (t.reflectivity.value = e.reflectivity),
                    (t.refractionRatio.value = e.refractionRatio),
                    (t.maxMipLevel.value = o.get(a).__maxMipLevel)),
                    e.lightMap &&
                      ((t.lightMap.value = e.lightMap),
                      (t.lightMapIntensity.value = e.lightMapIntensity)),
                    e.aoMap &&
                      ((t.aoMap.value = e.aoMap),
                      (t.aoMapIntensity.value = e.aoMapIntensity)),
                    e.map
                      ? (r = e.map)
                      : e.specularMap
                        ? (r = e.specularMap)
                        : e.displacementMap
                          ? (r = e.displacementMap)
                          : e.normalMap
                            ? (r = e.normalMap)
                            : e.bumpMap
                              ? (r = e.bumpMap)
                              : e.roughnessMap
                                ? (r = e.roughnessMap)
                                : e.metalnessMap
                                  ? (r = e.metalnessMap)
                                  : e.alphaMap
                                    ? (r = e.alphaMap)
                                    : e.emissiveMap && (r = e.emissiveMap),
                    void 0 !== r &&
                      (r.isWebGLRenderTarget && (r = r.texture),
                      !0 === r.matrixAutoUpdate && r.updateMatrix(),
                      t.uvTransform.value.copy(r.matrix)),
                    e.aoMap ? (i = e.aoMap) : e.lightMap && (i = e.lightMap),
                    void 0 !== i &&
                      (i.isWebGLRenderTarget && (i = i.texture),
                      !0 === i.matrixAutoUpdate && i.updateMatrix(),
                      t.uv2Transform.value.copy(i.matrix))
                }
                function f(t, e, n) {
                  ;(t.roughness.value = e.roughness),
                    (t.metalness.value = e.metalness),
                    e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
                    e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      e.side === q && (t.bumpScale.value *= -1)),
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      e.side === q && t.normalScale.value.negate()),
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias)),
                    (e.envMap || n) &&
                      (t.envMapIntensity.value = e.envMapIntensity)
                }
                return {
                  refreshFogUniforms: function (t, e) {
                    t.fogColor.value.copy(e.color),
                      e.isFog
                        ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                        : e.isFogExp2 && (t.fogDensity.value = e.density)
                  },
                  refreshMaterialUniforms: function (t, e, n, r, i) {
                    var a, o, s, c, l, h, u, p
                    e.isMeshBasicMaterial
                      ? d(t, e)
                      : e.isMeshLambertMaterial
                        ? (d(t, e),
                          (u = t),
                          (p = e).emissiveMap &&
                            (u.emissiveMap.value = p.emissiveMap))
                        : e.isMeshToonMaterial
                          ? (d(t, e),
                            (function (t, e) {
                              e.gradientMap &&
                                (t.gradientMap.value = e.gradientMap)
                              e.emissiveMap &&
                                (t.emissiveMap.value = e.emissiveMap)
                              e.bumpMap &&
                                ((t.bumpMap.value = e.bumpMap),
                                (t.bumpScale.value = e.bumpScale),
                                e.side === q && (t.bumpScale.value *= -1))
                              e.normalMap &&
                                ((t.normalMap.value = e.normalMap),
                                t.normalScale.value.copy(e.normalScale),
                                e.side === q && t.normalScale.value.negate())
                              e.displacementMap &&
                                ((t.displacementMap.value = e.displacementMap),
                                (t.displacementScale.value =
                                  e.displacementScale),
                                (t.displacementBias.value = e.displacementBias))
                            })(t, e))
                          : e.isMeshPhongMaterial
                            ? (d(t, e),
                              (function (t, e) {
                                t.specular.value.copy(e.specular),
                                  (t.shininess.value = Math.max(
                                    e.shininess,
                                    1e-4,
                                  )),
                                  e.emissiveMap &&
                                    (t.emissiveMap.value = e.emissiveMap)
                                e.bumpMap &&
                                  ((t.bumpMap.value = e.bumpMap),
                                  (t.bumpScale.value = e.bumpScale),
                                  e.side === q && (t.bumpScale.value *= -1))
                                e.normalMap &&
                                  ((t.normalMap.value = e.normalMap),
                                  t.normalScale.value.copy(e.normalScale),
                                  e.side === q && t.normalScale.value.negate())
                                e.displacementMap &&
                                  ((t.displacementMap.value =
                                    e.displacementMap),
                                  (t.displacementScale.value =
                                    e.displacementScale),
                                  (t.displacementBias.value =
                                    e.displacementBias))
                              })(t, e))
                            : e.isMeshStandardMaterial
                              ? (d(t, e, n),
                                (e.isMeshPhysicalMaterial
                                  ? function (t, e, n) {
                                      f(t, e, n),
                                        (t.reflectivity.value = e.reflectivity),
                                        (t.clearcoat.value = e.clearcoat),
                                        (t.clearcoatRoughness.value =
                                          e.clearcoatRoughness),
                                        e.sheen && t.sheen.value.copy(e.sheen)
                                      e.clearcoatMap &&
                                        (t.clearcoatMap.value = e.clearcoatMap)
                                      e.clearcoatRoughnessMap &&
                                        (t.clearcoatRoughnessMap.value =
                                          e.clearcoatRoughnessMap)
                                      e.clearcoatNormalMap &&
                                        (t.clearcoatNormalScale.value.copy(
                                          e.clearcoatNormalScale,
                                        ),
                                        (t.clearcoatNormalMap.value =
                                          e.clearcoatNormalMap),
                                        e.side === q &&
                                          t.clearcoatNormalScale.value.negate())
                                      t.transparency.value = e.transparency
                                    }
                                  : f)(t, e, n))
                              : e.isMeshMatcapMaterial
                                ? (d(t, e),
                                  (function (t, e) {
                                    e.matcap && (t.matcap.value = e.matcap)
                                    e.bumpMap &&
                                      ((t.bumpMap.value = e.bumpMap),
                                      (t.bumpScale.value = e.bumpScale),
                                      e.side === q && (t.bumpScale.value *= -1))
                                    e.normalMap &&
                                      ((t.normalMap.value = e.normalMap),
                                      t.normalScale.value.copy(e.normalScale),
                                      e.side === q &&
                                        t.normalScale.value.negate())
                                    e.displacementMap &&
                                      ((t.displacementMap.value =
                                        e.displacementMap),
                                      (t.displacementScale.value =
                                        e.displacementScale),
                                      (t.displacementBias.value =
                                        e.displacementBias))
                                  })(t, e))
                                : e.isMeshDepthMaterial
                                  ? (d(t, e),
                                    (l = t),
                                    (h = e).displacementMap &&
                                      ((l.displacementMap.value =
                                        h.displacementMap),
                                      (l.displacementScale.value =
                                        h.displacementScale),
                                      (l.displacementBias.value =
                                        h.displacementBias)))
                                  : e.isMeshDistanceMaterial
                                    ? (d(t, e),
                                      (function (t, e) {
                                        e.displacementMap &&
                                          ((t.displacementMap.value =
                                            e.displacementMap),
                                          (t.displacementScale.value =
                                            e.displacementScale),
                                          (t.displacementBias.value =
                                            e.displacementBias))
                                        t.referencePosition.value.copy(
                                          e.referencePosition,
                                        ),
                                          (t.nearDistance.value =
                                            e.nearDistance),
                                          (t.farDistance.value = e.farDistance)
                                      })(t, e))
                                    : e.isMeshNormalMaterial
                                      ? (d(t, e),
                                        (function (t, e) {
                                          e.bumpMap &&
                                            ((t.bumpMap.value = e.bumpMap),
                                            (t.bumpScale.value = e.bumpScale),
                                            e.side === q &&
                                              (t.bumpScale.value *= -1))
                                          e.normalMap &&
                                            ((t.normalMap.value = e.normalMap),
                                            t.normalScale.value.copy(
                                              e.normalScale,
                                            ),
                                            e.side === q &&
                                              t.normalScale.value.negate())
                                          e.displacementMap &&
                                            ((t.displacementMap.value =
                                              e.displacementMap),
                                            (t.displacementScale.value =
                                              e.displacementScale),
                                            (t.displacementBias.value =
                                              e.displacementBias))
                                        })(t, e))
                                      : e.isLineBasicMaterial
                                        ? ((c = e),
                                          (s = t).diffuse.value.copy(c.color),
                                          (s.opacity.value = c.opacity),
                                          e.isLineDashedMaterial &&
                                            ((o = e),
                                            ((a = t).dashSize.value =
                                              o.dashSize),
                                            (a.totalSize.value =
                                              o.dashSize + o.gapSize),
                                            (a.scale.value = o.scale)))
                                        : e.isPointsMaterial
                                          ? (function (t, e, n, r) {
                                              t.diffuse.value.copy(e.color),
                                                (t.opacity.value = e.opacity),
                                                (t.size.value = e.size * n),
                                                (t.scale.value = 0.5 * r),
                                                e.map && (t.map.value = e.map)
                                              e.alphaMap &&
                                                (t.alphaMap.value = e.alphaMap)
                                              var i
                                              e.map
                                                ? (i = e.map)
                                                : e.alphaMap && (i = e.alphaMap)
                                              void 0 !== i &&
                                                (!0 === i.matrixAutoUpdate &&
                                                  i.updateMatrix(),
                                                t.uvTransform.value.copy(
                                                  i.matrix,
                                                ))
                                            })(t, e, r, i)
                                          : e.isSpriteMaterial
                                            ? (function (t, e) {
                                                t.diffuse.value.copy(e.color),
                                                  (t.opacity.value = e.opacity),
                                                  (t.rotation.value =
                                                    e.rotation),
                                                  e.map && (t.map.value = e.map)
                                                e.alphaMap &&
                                                  (t.alphaMap.value =
                                                    e.alphaMap)
                                                var n
                                                e.map
                                                  ? (n = e.map)
                                                  : e.alphaMap &&
                                                    (n = e.alphaMap)
                                                void 0 !== n &&
                                                  (!0 === n.matrixAutoUpdate &&
                                                    n.updateMatrix(),
                                                  t.uvTransform.value.copy(
                                                    n.matrix,
                                                  ))
                                              })(t, e)
                                            : e.isShadowMaterial
                                              ? (t.color.value.copy(e.color),
                                                (t.opacity.value = e.opacity))
                                              : e.isShaderMaterial &&
                                                (e.uniformsNeedUpdate = !1)
                  },
                }
              }
              function Xo(t) {
                var a =
                    void 0 !== (t = t || {}).canvas
                      ? t.canvas
                      : document.createElementNS(
                          'http://www.w3.org/1999/xhtml',
                          'canvas',
                        ),
                  e = void 0 !== t.context ? t.context : null,
                  n = void 0 !== t.alpha && t.alpha,
                  r = void 0 === t.depth || t.depth,
                  i = void 0 === t.stencil || t.stencil,
                  o = void 0 !== t.antialias && t.antialias,
                  s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                  c =
                    void 0 !== t.preserveDrawingBuffer &&
                    t.preserveDrawingBuffer,
                  l =
                    void 0 !== t.powerPreference
                      ? t.powerPreference
                      : 'default',
                  h =
                    void 0 !== t.failIfMajorPerformanceCaveat &&
                    t.failIfMajorPerformanceCaveat,
                  y = null,
                  S = null
                ;(this.domElement = a),
                  (this.debug = { checkShaderErrors: !0 }),
                  (this.autoClear = !0),
                  (this.autoClearColor = !0),
                  (this.autoClearDepth = !0),
                  (this.autoClearStencil = !0),
                  (this.sortObjects = !0),
                  (this.clippingPlanes = []),
                  (this.localClippingEnabled = !1),
                  (this.gammaFactor = 2),
                  (this.outputEncoding = Re),
                  (this.physicallyCorrectLights = !1),
                  (this.toneMapping = Et),
                  (this.toneMappingExposure = 1),
                  (this.maxMorphTargets = 8),
                  (this.maxMorphNormals = 4)
                var E = this,
                  u = !1,
                  p = null,
                  d = 0,
                  f = 0,
                  T = null,
                  m = null,
                  A = -1,
                  L = null,
                  v = null,
                  g = new $e(),
                  x = new $e(),
                  b = null,
                  _ = a.width,
                  R = a.height,
                  C = 1,
                  w = null,
                  M = null,
                  P = new $e(0, 0, _, R),
                  O = new $e(0, 0, _, R),
                  I = !1,
                  D = new Fi(),
                  B = new Qi(),
                  N = !1,
                  U = !1,
                  z = new fn(),
                  F = new on(),
                  H = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0,
                  }
                function G() {
                  return null === T ? C : 1
                }
                var k,
                  V,
                  j,
                  W,
                  q,
                  X,
                  Y,
                  Z,
                  J,
                  Q,
                  K,
                  $,
                  tt,
                  et,
                  nt,
                  rt,
                  it,
                  at,
                  ot,
                  st = e
                function ct(t, e) {
                  for (var n = 0; n < t.length; n++) {
                    var r = t[n],
                      i = a.getContext(r, e)
                    if (null !== i) return i
                  }
                  return null
                }
                try {
                  var lt = {
                    alpha: n,
                    depth: r,
                    stencil: i,
                    antialias: o,
                    premultipliedAlpha: s,
                    preserveDrawingBuffer: c,
                    powerPreference: l,
                    failIfMajorPerformanceCaveat: h,
                  }
                  if (
                    (a.addEventListener('webglcontextlost', ft, !1),
                    a.addEventListener('webglcontextrestored', mt, !1),
                    null === st)
                  ) {
                    var ht = ['webgl2', 'webgl', 'experimental-webgl']
                    if (
                      (!0 === E.isWebGL1Renderer && ht.shift(),
                      null === (st = ct(ht, lt)))
                    )
                      throw ct(ht)
                        ? new Error(
                            'Error creating WebGL context with your selected attributes.',
                          )
                        : new Error('Error creating WebGL context.')
                  }
                  void 0 === st.getShaderPrecisionFormat &&
                    (st.getShaderPrecisionFormat = function () {
                      return { rangeMin: 1, rangeMax: 1, precision: 1 }
                    })
                } catch (t) {
                  throw (console.error('THREE.WebGLRenderer: ' + t.message), t)
                }
                function ut() {
                  ;(k = new Ki(st)),
                    !1 === (V = new Ji(st, k, t)).isWebGL2 &&
                      (k.get('WEBGL_depth_texture'),
                      k.get('OES_texture_float'),
                      k.get('OES_texture_half_float'),
                      k.get('OES_texture_half_float_linear'),
                      k.get('OES_standard_derivatives'),
                      k.get('OES_element_index_uint'),
                      k.get('OES_vertex_array_object'),
                      k.get('ANGLE_instanced_arrays')),
                    k.get('OES_texture_float_linear'),
                    (at = new Go(0, k, V)),
                    (j = new Fo(st, k, V)).scissor(
                      x.copy(O).multiplyScalar(C).floor(),
                    ),
                    j.viewport(g.copy(P).multiplyScalar(C).floor()),
                    (W = new ea()),
                    (q = new Mo()),
                    (X = new Ho(st, k, j, q, V, at, W)),
                    (Y = new ki(st, V)),
                    (ot = new Yi(st, k, Y, V)),
                    (Z = new $i(0, Y, W, ot)),
                    (J = new aa(0, Z, Y, W)),
                    (nt = new ia(st)),
                    (Q = new wo(E, k, V, ot)),
                    (K = new qo(q)),
                    ($ = new Ao()),
                    (tt = new Io()),
                    (et = new Xi(E, j, J, s)),
                    (rt = new Zi(st, k, W, V)),
                    (it = new ta(st, k, W, V)),
                    (W.programs = Q.programs),
                    (E.capabilities = V),
                    (E.extensions = k),
                    (E.properties = q),
                    (E.renderLists = $),
                    (E.state = j),
                    (E.info = W)
                }
                ut()
                var pt = new Wo(E, st)
                this.xr = pt
                var dt = new zo(E, J, V.maxTextureSize)
                function ft(t) {
                  t.preventDefault(),
                    console.log('THREE.WebGLRenderer: Context Lost.'),
                    (u = !0)
                }
                function mt() {
                  console.log('THREE.WebGLRenderer: Context Restored.'),
                    (u = !1),
                    ut()
                }
                function vt(t) {
                  var e,
                    n = t.target
                  n.removeEventListener('dispose', vt), gt((e = n)), q.remove(e)
                }
                function gt(t) {
                  var e = q.get(t).program
                  ;(t.program = void 0) !== e && Q.releaseProgram(e)
                }
                ;(this.shadowMap = dt),
                  (this.getContext = function () {
                    return st
                  }),
                  (this.getContextAttributes = function () {
                    return st.getContextAttributes()
                  }),
                  (this.forceContextLoss = function () {
                    var t = k.get('WEBGL_lose_context')
                    t && t.loseContext()
                  }),
                  (this.forceContextRestore = function () {
                    var t = k.get('WEBGL_lose_context')
                    t && t.restoreContext()
                  }),
                  (this.getPixelRatio = function () {
                    return C
                  }),
                  (this.setPixelRatio = function (t) {
                    void 0 !== t && ((C = t), this.setSize(_, R, !1))
                  }),
                  (this.getSize = function (t) {
                    return (
                      void 0 === t &&
                        (console.warn(
                          'WebGLRenderer: .getsize() now requires a Vector2 as an argument',
                        ),
                        (t = new Ye())),
                      t.set(_, R)
                    )
                  }),
                  (this.setSize = function (t, e, n) {
                    pt.isPresenting
                      ? console.warn(
                          "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
                        )
                      : ((_ = t),
                        (R = e),
                        (a.width = Math.floor(t * C)),
                        (a.height = Math.floor(e * C)),
                        !1 !== n &&
                          ((a.style.width = t + 'px'),
                          (a.style.height = e + 'px')),
                        this.setViewport(0, 0, t, e))
                  }),
                  (this.getDrawingBufferSize = function (t) {
                    return (
                      void 0 === t &&
                        (console.warn(
                          'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument',
                        ),
                        (t = new Ye())),
                      t.set(_ * C, R * C).floor()
                    )
                  }),
                  (this.setDrawingBufferSize = function (t, e, n) {
                    ;(_ = t),
                      (R = e),
                      (C = n),
                      (a.width = Math.floor(t * n)),
                      (a.height = Math.floor(e * n)),
                      this.setViewport(0, 0, t, e)
                  }),
                  (this.getCurrentViewport = function (t) {
                    return (
                      void 0 === t &&
                        (console.warn(
                          'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument',
                        ),
                        (t = new $e())),
                      t.copy(g)
                    )
                  }),
                  (this.getViewport = function (t) {
                    return t.copy(P)
                  }),
                  (this.setViewport = function (t, e, n, r) {
                    t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, r),
                      j.viewport(g.copy(P).multiplyScalar(C).floor())
                  }),
                  (this.getScissor = function (t) {
                    return t.copy(O)
                  }),
                  (this.setScissor = function (t, e, n, r) {
                    t.isVector4 ? O.set(t.x, t.y, t.z, t.w) : O.set(t, e, n, r),
                      j.scissor(x.copy(O).multiplyScalar(C).floor())
                  }),
                  (this.getScissorTest = function () {
                    return I
                  }),
                  (this.setScissorTest = function (t) {
                    j.setScissorTest((I = t))
                  }),
                  (this.setOpaqueSort = function (t) {
                    w = t
                  }),
                  (this.setTransparentSort = function (t) {
                    M = t
                  }),
                  (this.getClearColor = function () {
                    return et.getClearColor()
                  }),
                  (this.setClearColor = function () {
                    et.setClearColor.apply(et, arguments)
                  }),
                  (this.getClearAlpha = function () {
                    return et.getClearAlpha()
                  }),
                  (this.setClearAlpha = function () {
                    et.setClearAlpha.apply(et, arguments)
                  }),
                  (this.clear = function (t, e, n) {
                    var r = 0
                    ;(void 0 !== t && !t) || (r |= 16384),
                      (void 0 !== e && !e) || (r |= 256),
                      (void 0 !== n && !n) || (r |= 1024),
                      st.clear(r)
                  }),
                  (this.clearColor = function () {
                    this.clear(!0, !1, !1)
                  }),
                  (this.clearDepth = function () {
                    this.clear(!1, !0, !1)
                  }),
                  (this.clearStencil = function () {
                    this.clear(!1, !1, !0)
                  }),
                  (this.dispose = function () {
                    a.removeEventListener('webglcontextlost', ft, !1),
                      a.removeEventListener('webglcontextrestored', mt, !1),
                      $.dispose(),
                      tt.dispose(),
                      q.dispose(),
                      J.dispose(),
                      ot.dispose(),
                      pt.dispose(),
                      xt.stop()
                  }),
                  (this.renderBufferImmediate = function (t, e) {
                    ot.initAttributes()
                    var n = q.get(t)
                    t.hasPositions &&
                      !n.position &&
                      (n.position = st.createBuffer()),
                      t.hasNormals &&
                        !n.normal &&
                        (n.normal = st.createBuffer()),
                      t.hasUvs && !n.uv && (n.uv = st.createBuffer()),
                      t.hasColors && !n.color && (n.color = st.createBuffer())
                    var r = e.getAttributes()
                    t.hasPositions &&
                      (st.bindBuffer(34962, n.position),
                      st.bufferData(34962, t.positionArray, 35048),
                      ot.enableAttribute(r.position),
                      st.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)),
                      t.hasNormals &&
                        (st.bindBuffer(34962, n.normal),
                        st.bufferData(34962, t.normalArray, 35048),
                        ot.enableAttribute(r.normal),
                        st.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)),
                      t.hasUvs &&
                        (st.bindBuffer(34962, n.uv),
                        st.bufferData(34962, t.uvArray, 35048),
                        ot.enableAttribute(r.uv),
                        st.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)),
                      t.hasColors &&
                        (st.bindBuffer(34962, n.color),
                        st.bufferData(34962, t.colorArray, 35048),
                        ot.enableAttribute(r.color),
                        st.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)),
                      ot.disableUnusedAttributes(),
                      st.drawArrays(4, 0, t.count),
                      (t.count = 0)
                  }),
                  (this.renderBufferDirect = function (t, e, n, r, i, a) {
                    null === e && (e = H)
                    var o = i.isMesh && i.matrixWorld.determinant() < 0,
                      s = Mt(t, e, r, i)
                    j.setMaterial(r, o)
                    var c = n.index,
                      l = n.attributes.position
                    if (null === c) {
                      if (void 0 === l || 0 === l.count) return
                    } else if (0 === c.count) return
                    var h,
                      u = 1
                    !0 === r.wireframe &&
                      ((c = Z.getWireframeAttribute(n)), (u = 2)),
                      (r.morphTargets || r.morphNormals) &&
                        nt.update(i, n, r, s),
                      ot.setup(i, r, s, n, c)
                    var p = rt
                    null !== c && ((h = Y.get(c)), (p = it).setIndex(h))
                    var d,
                      f,
                      m = null !== c ? c.count : l.count,
                      v = n.drawRange.start * u,
                      g = n.drawRange.count * u,
                      y = null !== a ? a.start * u : 0,
                      x = null !== a ? a.count * u : 1 / 0,
                      b = Math.max(v, y),
                      _ = Math.min(m, v + g, y + x) - 1,
                      w = Math.max(0, _ - b + 1)
                    0 !== w &&
                      (i.isMesh
                        ? !0 === r.wireframe
                          ? (j.setLineWidth(r.wireframeLinewidth * G()),
                            p.setMode(1))
                          : p.setMode(4)
                        : i.isLine
                          ? (void 0 === (d = r.linewidth) && (d = 1),
                            j.setLineWidth(d * G()),
                            i.isLineSegments
                              ? p.setMode(1)
                              : i.isLineLoop
                                ? p.setMode(2)
                                : p.setMode(3))
                          : i.isPoints
                            ? p.setMode(0)
                            : i.isSprite && p.setMode(4),
                      i.isInstancedMesh
                        ? p.renderInstances(n, b, w, i.count)
                        : n.isInstancedBufferGeometry
                          ? ((f = Math.min(
                              n.instanceCount,
                              n._maxInstanceCount,
                            )),
                            p.renderInstances(n, b, w, f))
                          : p.render(b, w))
                  }),
                  (this.compile = function (i, t) {
                    ;(S = tt.get(i, t)).init(),
                      i.traverse(function (t) {
                        t.isLight &&
                          (S.pushLight(t), t.castShadow && S.pushShadow(t))
                      }),
                      S.setupLights(t)
                    var a = new WeakMap()
                    i.traverse(function (t) {
                      var e = t.material
                      if (e)
                        if (Array.isArray(e))
                          for (var n = 0; n < e.length; n++) {
                            var r = e[n]
                            !1 === a.has(r) && (wt(r, i, t), a.set(r))
                          }
                        else !1 === a.has(e) && (wt(e, i, t), a.set(e))
                    })
                  })
                var yt = null
                var xt = new Gi()
                function bt(t, e, n) {
                  for (
                    var r = !0 === e.isScene ? e.overrideMaterial : null,
                      i = 0,
                      a = t.length;
                    i < a;
                    i++
                  ) {
                    var o = t[i],
                      s = o.object,
                      c = o.geometry,
                      l = null === r ? o.material : r,
                      h = o.group
                    if (n.isArrayCamera)
                      for (
                        var u = (v = n).cameras, p = 0, d = u.length;
                        p < d;
                        p++
                      ) {
                        var f = u[p]
                        s.layers.test(f.layers) &&
                          (j.viewport(g.copy(f.viewport)),
                          S.setupLights(f),
                          _t(s, e, f, c, l, h))
                      }
                    else (v = null), _t(s, e, n, c, l, h)
                  }
                }
                function _t(t, e, n, r, i, a) {
                  var o, s
                  t.onBeforeRender(E, e, n, r, i, a),
                    (S = tt.get(e, v || n)),
                    t.modelViewMatrix.multiplyMatrices(
                      n.matrixWorldInverse,
                      t.matrixWorld,
                    ),
                    t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
                    t.isImmediateRenderObject
                      ? ((o = Mt(n, e, i, t)),
                        j.setMaterial(i),
                        ot.reset(),
                        (s = o),
                        t.render(function (t) {
                          E.renderBufferImmediate(t, s)
                        }))
                      : E.renderBufferDirect(n, e, r, i, t, a),
                    t.onAfterRender(E, e, n, r, i, a),
                    (S = tt.get(e, v || n))
                }
                function wt(t, e, n) {
                  !0 !== e.isScene && (e = H)
                  var r = q.get(t),
                    i = S.state.lights,
                    a = S.state.shadowsArray,
                    o = i.state.version,
                    s = Q.getParameters(
                      t,
                      i.state,
                      a,
                      e,
                      B.numPlanes,
                      B.numIntersection,
                      n,
                    ),
                    c = Q.getProgramCacheKey(s),
                    l = r.program,
                    h = !0
                  if (void 0 === l) t.addEventListener('dispose', vt)
                  else if (l.cacheKey !== c) gt(t)
                  else if (r.lightsStateVersion !== o)
                    (r.lightsStateVersion = o), (h = !1)
                  else {
                    if (void 0 !== s.shaderID) return
                    h = !1
                  }
                  h &&
                    ((l = Q.acquireProgram(s, c)),
                    (r.program = l),
                    (r.uniforms = s.uniforms),
                    (r.outputEncoding = s.outputEncoding),
                    (t.program = l))
                  var u = l.getAttributes()
                  if (t.morphTargets)
                    for (
                      var p = (t.numSupportedMorphTargets = 0);
                      p < E.maxMorphTargets;
                      p++
                    )
                      0 <= u['morphTarget' + p] && t.numSupportedMorphTargets++
                  if (t.morphNormals)
                    for (
                      var d = (t.numSupportedMorphNormals = 0);
                      d < E.maxMorphNormals;
                      d++
                    )
                      0 <= u['morphNormal' + d] && t.numSupportedMorphNormals++
                  var f,
                    m = r.uniforms
                  ;((t.isShaderMaterial || t.isRawShaderMaterial) &&
                    !0 !== t.clipping) ||
                    ((r.numClippingPlanes = B.numPlanes),
                    (r.numIntersection = B.numIntersection),
                    (m.clippingPlanes = B.uniform)),
                    (r.environment = t.isMeshStandardMaterial
                      ? e.environment
                      : null),
                    (r.fog = e.fog),
                    (r.needsLights =
                      (f = t).isMeshLambertMaterial ||
                      f.isMeshToonMaterial ||
                      f.isMeshPhongMaterial ||
                      f.isMeshStandardMaterial ||
                      f.isShadowMaterial ||
                      (f.isShaderMaterial && !0 === f.lights)),
                    (r.lightsStateVersion = o),
                    r.needsLights &&
                      ((m.ambientLightColor.value = i.state.ambient),
                      (m.lightProbe.value = i.state.probe),
                      (m.directionalLights.value = i.state.directional),
                      (m.directionalLightShadows.value =
                        i.state.directionalShadow),
                      (m.spotLights.value = i.state.spot),
                      (m.spotLightShadows.value = i.state.spotShadow),
                      (m.rectAreaLights.value = i.state.rectArea),
                      (m.pointLights.value = i.state.point),
                      (m.pointLightShadows.value = i.state.pointShadow),
                      (m.hemisphereLights.value = i.state.hemi),
                      (m.directionalShadowMap.value =
                        i.state.directionalShadowMap),
                      (m.directionalShadowMatrix.value =
                        i.state.directionalShadowMatrix),
                      (m.spotShadowMap.value = i.state.spotShadowMap),
                      (m.spotShadowMatrix.value = i.state.spotShadowMatrix),
                      (m.pointShadowMap.value = i.state.pointShadowMap),
                      (m.pointShadowMatrix.value = i.state.pointShadowMatrix))
                  var v = r.program.getUniforms(),
                    g = no.seqWithValue(v.seq, m)
                  r.uniformsList = g
                }
                function Mt(t, e, n, r) {
                  !0 !== e.isScene && (e = H), X.resetTextureUnits()
                  var i,
                    a = e.fog,
                    o = n.isMeshStandardMaterial ? e.environment : null,
                    s = null === T ? E.outputEncoding : T.texture.encoding,
                    c = q.get(n),
                    l = S.state.lights
                  !0 === N &&
                    ((!0 !== U && t === L) ||
                      ((i = t === L && n.id === A),
                      B.setState(
                        n.clippingPlanes,
                        n.clipIntersection,
                        n.clipShadows,
                        t,
                        c,
                        i,
                      ))),
                    n.version === c.__version
                      ? (void 0 === c.program ||
                          (n.fog && c.fog !== a) ||
                          c.environment !== o ||
                          (c.needsLights &&
                            c.lightsStateVersion !== l.state.version) ||
                          (void 0 !== c.numClippingPlanes &&
                            (c.numClippingPlanes !== B.numPlanes ||
                              c.numIntersection !== B.numIntersection)) ||
                          c.outputEncoding !== s) &&
                        wt(n, e, r)
                      : (wt(n, e, r), (c.__version = n.version))
                  var h,
                    u,
                    p,
                    d,
                    f,
                    m,
                    v,
                    g,
                    y = !1,
                    x = !1,
                    b = !1,
                    _ = c.program,
                    w = _.getUniforms(),
                    M = c.uniforms
                  return (
                    j.useProgram(_.program) && (b = x = y = !0),
                    n.id !== A && ((A = n.id), (x = !0)),
                    (!y && L === t) ||
                      (w.setValue(st, 'projectionMatrix', t.projectionMatrix),
                      V.logarithmicDepthBuffer &&
                        w.setValue(
                          st,
                          'logDepthBufFC',
                          2 / (Math.log(t.far + 1) / Math.LN2),
                        ),
                      L !== t && ((L = t), (b = x = !0)),
                      !(
                        n.isShaderMaterial ||
                        n.isMeshPhongMaterial ||
                        n.isMeshToonMaterial ||
                        n.isMeshStandardMaterial ||
                        n.envMap
                      ) ||
                        (void 0 !== (h = w.map.cameraPosition) &&
                          h.setValue(
                            st,
                            F.setFromMatrixPosition(t.matrixWorld),
                          )),
                      (n.isMeshPhongMaterial ||
                        n.isMeshToonMaterial ||
                        n.isMeshLambertMaterial ||
                        n.isMeshBasicMaterial ||
                        n.isMeshStandardMaterial ||
                        n.isShaderMaterial) &&
                        w.setValue(
                          st,
                          'isOrthographic',
                          !0 === t.isOrthographicCamera,
                        ),
                      (n.isMeshPhongMaterial ||
                        n.isMeshToonMaterial ||
                        n.isMeshLambertMaterial ||
                        n.isMeshBasicMaterial ||
                        n.isMeshStandardMaterial ||
                        n.isShaderMaterial ||
                        n.isShadowMaterial ||
                        n.skinning) &&
                        w.setValue(st, 'viewMatrix', t.matrixWorldInverse)),
                    n.skinning &&
                      (w.setOptional(st, r, 'bindMatrix'),
                      w.setOptional(st, r, 'bindMatrixInverse'),
                      (u = r.skeleton) &&
                        ((p = u.bones),
                        V.floatVertexTextures
                          ? (void 0 === u.boneTexture &&
                              ((d = Math.sqrt(4 * p.length)),
                              (d = Xe.ceilPowerOfTwo(d)),
                              (d = Math.max(d, 4)),
                              (f = new Float32Array(d * d * 4)).set(
                                u.boneMatrices,
                              ),
                              (m = new Ni(f, d, d, $t, Zt)),
                              (u.boneMatrices = f),
                              (u.boneTexture = m),
                              (u.boneTextureSize = d)),
                            w.setValue(st, 'boneTexture', u.boneTexture, X),
                            w.setValue(
                              st,
                              'boneTextureSize',
                              u.boneTextureSize,
                            ))
                          : w.setOptional(st, u, 'boneMatrices'))),
                    (!x && c.receiveShadow === r.receiveShadow) ||
                      ((c.receiveShadow = r.receiveShadow),
                      w.setValue(st, 'receiveShadow', r.receiveShadow)),
                    x &&
                      (w.setValue(
                        st,
                        'toneMappingExposure',
                        E.toneMappingExposure,
                      ),
                      c.needsLights &&
                        ((g = b),
                        ((v = M).ambientLightColor.needsUpdate = g),
                        (v.lightProbe.needsUpdate = g),
                        (v.directionalLights.needsUpdate = g),
                        (v.directionalLightShadows.needsUpdate = g),
                        (v.pointLights.needsUpdate = g),
                        (v.pointLightShadows.needsUpdate = g),
                        (v.spotLights.needsUpdate = g),
                        (v.spotLightShadows.needsUpdate = g),
                        (v.rectAreaLights.needsUpdate = g),
                        (v.hemisphereLights.needsUpdate = g)),
                      a && n.fog && K.refreshFogUniforms(M, a),
                      K.refreshMaterialUniforms(M, n, o, C, R),
                      void 0 !== M.ltc_1 && (M.ltc_1.value = Hi.LTC_1),
                      void 0 !== M.ltc_2 && (M.ltc_2.value = Hi.LTC_2),
                      no.upload(st, c.uniformsList, M, X)),
                    n.isShaderMaterial &&
                      !0 === n.uniformsNeedUpdate &&
                      (no.upload(st, c.uniformsList, M, X),
                      (n.uniformsNeedUpdate = !1)),
                    n.isSpriteMaterial && w.setValue(st, 'center', r.center),
                    w.setValue(st, 'modelViewMatrix', r.modelViewMatrix),
                    w.setValue(st, 'normalMatrix', r.normalMatrix),
                    w.setValue(st, 'modelMatrix', r.matrixWorld),
                    _
                  )
                }
                xt.setAnimationLoop(function (t) {
                  pt.isPresenting || (yt && yt(t))
                }),
                  'undefined' != typeof window && xt.setContext(window),
                  (this.setAnimationLoop = function (t) {
                    ;(yt = t),
                      pt.setAnimationLoop(t),
                      null === t ? xt.stop() : xt.start()
                  }),
                  (this.render = function (t, e) {
                    var n, r, i, a, o
                    void 0 !== arguments[2] &&
                      (console.warn(
                        'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.',
                      ),
                      (n = arguments[2])),
                      void 0 !== arguments[3] &&
                        (console.warn(
                          'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.',
                        ),
                        (r = arguments[3])),
                      void 0 === e || !0 === e.isCamera
                        ? !0 !== u &&
                          (ot.resetDefaultState(),
                          (A = -1),
                          !(L = null) === t.autoUpdate && t.updateMatrixWorld(),
                          null === e.parent && e.updateMatrixWorld(),
                          !0 === pt.enabled &&
                            !0 === pt.isPresenting &&
                            (e = pt.getCamera(e)),
                          !0 === t.isScene && t.onBeforeRender(E, t, e, n || T),
                          (S = tt.get(t, e)).init(),
                          z.multiplyMatrices(
                            e.projectionMatrix,
                            e.matrixWorldInverse,
                          ),
                          D.setFromProjectionMatrix(z),
                          (U = this.localClippingEnabled),
                          (N = B.init(this.clippingPlanes, U, e)),
                          (y = $.get(t, e)).init(),
                          (function t(e, n, r, i) {
                            if (!1 === e.visible) return
                            var a = e.layers.test(n.layers)
                            if (a)
                              if (e.isGroup) r = e.renderOrder
                              else if (e.isLOD)
                                !0 === e.autoUpdate && e.update(n)
                              else if (e.isLight)
                                S.pushLight(e), e.castShadow && S.pushShadow(e)
                              else if (e.isSprite) {
                                var o, s
                                ;(e.frustumCulled && !D.intersectsSprite(e)) ||
                                  (i &&
                                    F.setFromMatrixPosition(
                                      e.matrixWorld,
                                    ).applyMatrix4(z),
                                  (o = J.update(e)),
                                  (s = e.material).visible &&
                                    y.push(e, o, s, r, F.z, null))
                              } else if (e.isImmediateRenderObject)
                                i &&
                                  F.setFromMatrixPosition(
                                    e.matrixWorld,
                                  ).applyMatrix4(z),
                                  y.push(e, null, e.material, r, F.z, null)
                              else if (
                                (e.isMesh || e.isLine || e.isPoints) &&
                                (e.isSkinnedMesh &&
                                  e.skeleton.frame !== W.render.frame &&
                                  (e.skeleton.update(),
                                  (e.skeleton.frame = W.render.frame)),
                                !e.frustumCulled || D.intersectsObject(e))
                              ) {
                                i &&
                                  F.setFromMatrixPosition(
                                    e.matrixWorld,
                                  ).applyMatrix4(z)
                                var c = J.update(e),
                                  l = e.material
                                if (Array.isArray(l))
                                  for (
                                    var h = c.groups, u = 0, p = h.length;
                                    u < p;
                                    u++
                                  ) {
                                    var d = h[u],
                                      f = l[d.materialIndex]
                                    f && f.visible && y.push(e, c, f, r, F.z, d)
                                  }
                                else l.visible && y.push(e, c, l, r, F.z, null)
                              }
                            var m = e.children
                            for (var v = 0, g = m.length; v < g; v++)
                              t(m[v], n, r, i)
                          })(t, e, 0, E.sortObjects),
                          y.finish(),
                          !0 === E.sortObjects && y.sort(w, M),
                          !0 === N && B.beginShadows(),
                          (i = S.state.shadowsArray),
                          dt.render(i, t, e),
                          S.setupLights(e),
                          !0 === N && B.endShadows(),
                          !0 === this.info.autoReset && this.info.reset(),
                          void 0 !== n && this.setRenderTarget(n),
                          et.render(y, t, e, r),
                          (a = y.opaque),
                          (o = y.transparent),
                          0 < a.length && bt(a, t, e),
                          0 < o.length && bt(o, t, e),
                          !0 === t.isScene && t.onAfterRender(E, t, e),
                          null !== T &&
                            (X.updateRenderTargetMipmap(T),
                            X.updateMultisampleRenderTarget(T)),
                          j.buffers.depth.setTest(!0),
                          j.buffers.depth.setMask(!0),
                          j.buffers.color.setMask(!0),
                          j.setPolygonOffset(!1),
                          (S = y = null))
                        : console.error(
                            'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.',
                          )
                  }),
                  (this.setFramebuffer = function (t) {
                    p !== t && null === T && st.bindFramebuffer(36160, t),
                      (p = t)
                  }),
                  (this.getActiveCubeFace = function () {
                    return d
                  }),
                  (this.getActiveMipmapLevel = function () {
                    return f
                  }),
                  (this.getRenderTarget = function () {
                    return T
                  }),
                  (this.setRenderTarget = function (t, e, n) {
                    ;(d = e),
                      (f = n),
                      (T = t) &&
                        void 0 === q.get(t).__webglFramebuffer &&
                        X.setupRenderTarget(t)
                    var r,
                      i,
                      a = p,
                      o = !1
                    ;(b = t
                      ? ((r = q.get(t).__webglFramebuffer),
                        t.isWebGLCubeRenderTarget
                          ? ((a = r[e || 0]), (o = !0))
                          : (a = t.isWebGLMultisampleRenderTarget
                              ? q.get(t).__webglMultisampledFramebuffer
                              : r),
                        g.copy(t.viewport),
                        x.copy(t.scissor),
                        t.scissorTest)
                      : (g.copy(P).multiplyScalar(C).floor(),
                        x.copy(O).multiplyScalar(C).floor(),
                        I)),
                      m !== a && (st.bindFramebuffer(36160, a), (m = a)),
                      j.viewport(g),
                      j.scissor(x),
                      j.setScissorTest(b),
                      o &&
                        ((i = q.get(t.texture)),
                        st.framebufferTexture2D(
                          36160,
                          36064,
                          34069 + (e || 0),
                          i.__webglTexture,
                          n || 0,
                        ))
                  }),
                  (this.readRenderTargetPixels = function (
                    t,
                    e,
                    n,
                    r,
                    i,
                    a,
                    o,
                  ) {
                    if (t && t.isWebGLRenderTarget) {
                      var s = q.get(t).__webglFramebuffer
                      if (
                        (t.isWebGLCubeRenderTarget &&
                          void 0 !== o &&
                          (s = s[o]),
                        s)
                      ) {
                        var c = !1
                        s !== m && (st.bindFramebuffer(36160, s), (c = !0))
                        try {
                          var l = t.texture,
                            h = l.format,
                            u = l.type
                          if (
                            h !== $t &&
                            at.convert(h) !== st.getParameter(35739)
                          )
                            return void console.error(
                              'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
                            )
                          if (
                            !(
                              u === qt ||
                              at.convert(u) === st.getParameter(35738) ||
                              (u === Zt &&
                                (V.isWebGL2 ||
                                  k.get('OES_texture_float') ||
                                  k.get('WEBGL_color_buffer_float'))) ||
                              (u === Jt &&
                                (V.isWebGL2
                                  ? k.get('EXT_color_buffer_float')
                                  : k.get('EXT_color_buffer_half_float')))
                            )
                          )
                            return void console.error(
                              'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
                            )
                          36053 === st.checkFramebufferStatus(36160)
                            ? 0 <= e &&
                              e <= t.width - r &&
                              0 <= n &&
                              n <= t.height - i &&
                              st.readPixels(
                                e,
                                n,
                                r,
                                i,
                                at.convert(h),
                                at.convert(u),
                                a,
                              )
                            : console.error(
                                'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.',
                              )
                        } finally {
                          c && st.bindFramebuffer(36160, m)
                        }
                      }
                    } else
                      console.error(
                        'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
                      )
                  }),
                  (this.copyFramebufferToTexture = function (t, e, n) {
                    void 0 === n && (n = 0)
                    var r = Math.pow(2, -n),
                      i = Math.floor(e.image.width * r),
                      a = Math.floor(e.image.height * r),
                      o = at.convert(e.format)
                    X.setTexture2D(e, 0),
                      st.copyTexImage2D(3553, n, o, t.x, t.y, i, a, 0),
                      j.unbindTexture()
                  }),
                  (this.copyTextureToTexture = function (t, e, n, r) {
                    void 0 === r && (r = 0)
                    var i = e.image.width,
                      a = e.image.height,
                      o = at.convert(n.format),
                      s = at.convert(n.type)
                    X.setTexture2D(n, 0),
                      st.pixelStorei(37440, n.flipY),
                      st.pixelStorei(37441, n.premultiplyAlpha),
                      st.pixelStorei(3317, n.unpackAlignment),
                      e.isDataTexture
                        ? st.texSubImage2D(
                            3553,
                            r,
                            t.x,
                            t.y,
                            i,
                            a,
                            o,
                            s,
                            e.image.data,
                          )
                        : e.isCompressedTexture
                          ? st.compressedTexSubImage2D(
                              3553,
                              r,
                              t.x,
                              t.y,
                              e.mipmaps[0].width,
                              e.mipmaps[0].height,
                              o,
                              e.mipmaps[0].data,
                            )
                          : st.texSubImage2D(3553, r, t.x, t.y, o, s, e.image),
                      0 === r && n.generateMipmaps && st.generateMipmap(3553),
                      j.unbindTexture()
                  }),
                  (this.initTexture = function (t) {
                    X.setTexture2D(t, 0), j.unbindTexture()
                  }),
                  'undefined' != typeof __THREE_DEVTOOLS__ &&
                    __THREE_DEVTOOLS__.dispatchEvent(
                      new CustomEvent('observe', { detail: this }),
                    )
              }
              function Yo(t) {
                Xo.call(this, t)
              }
              function Zo(t, e) {
                ;(this.name = ''),
                  (this.color = new Mr(t)),
                  (this.density = void 0 !== e ? e : 25e-5)
              }
              function Jo(t, e, n) {
                ;(this.name = ''),
                  (this.color = new Mr(t)),
                  (this.near = void 0 !== e ? e : 1),
                  (this.far = void 0 !== n ? n : 1e3)
              }
              function Qo(t, e) {
                ;(this.array = t),
                  (this.stride = e),
                  (this.count = void 0 !== t ? t.length / e : 0),
                  (this.usage = Ge),
                  (this.updateRange = { offset: 0, count: -1 }),
                  (this.version = 0),
                  (this.uuid = Xe.generateUUID())
              }
              ;(ko.prototype = Object.assign(Object.create(Ii.prototype), {
                constructor: ko,
                isArrayCamera: !0,
              })),
                (Vo.prototype = Object.assign(Object.create(On.prototype), {
                  constructor: Vo,
                  isGroup: !0,
                })),
                Object.assign(jo.prototype, {
                  constructor: jo,
                  getTargetRaySpace: function () {
                    return (
                      null === this._targetRay &&
                        ((this._targetRay = new Vo()),
                        (this._targetRay.matrixAutoUpdate = !1),
                        (this._targetRay.visible = !1)),
                      this._targetRay
                    )
                  },
                  getGripSpace: function () {
                    return (
                      null === this._grip &&
                        ((this._grip = new Vo()),
                        (this._grip.matrixAutoUpdate = !1),
                        (this._grip.visible = !1)),
                      this._grip
                    )
                  },
                  dispatchEvent: function (t) {
                    return (
                      null !== this._targetRay &&
                        this._targetRay.dispatchEvent(t),
                      null !== this._grip && this._grip.dispatchEvent(t),
                      this
                    )
                  },
                  disconnect: function (t) {
                    return (
                      this.dispatchEvent({ type: 'disconnected', data: t }),
                      null !== this._targetRay &&
                        (this._targetRay.visible = !1),
                      null !== this._grip && (this._grip.visible = !1),
                      this
                    )
                  },
                  update: function (t, e, n) {
                    var r = null,
                      i = null,
                      a = this._targetRay,
                      o = this._grip
                    return (
                      t &&
                        (null !== a &&
                          null !== (r = e.getPose(t.targetRaySpace, n)) &&
                          (a.matrix.fromArray(r.transform.matrix),
                          a.matrix.decompose(a.position, a.rotation, a.scale)),
                        null !== o &&
                          t.gripSpace &&
                          null !== (i = e.getPose(t.gripSpace, n)) &&
                          (o.matrix.fromArray(i.transform.matrix),
                          o.matrix.decompose(o.position, o.rotation, o.scale))),
                      null !== a && (a.visible = null !== r),
                      null !== o && (o.visible = null !== i),
                      this
                    )
                  },
                }),
                Object.assign(Wo.prototype, Ve.prototype),
                (Yo.prototype = Object.assign(Object.create(Xo.prototype), {
                  constructor: Yo,
                  isWebGL1Renderer: !0,
                })),
                Object.assign(Zo.prototype, {
                  isFogExp2: !0,
                  clone: function () {
                    return new Zo(this.color, this.density)
                  },
                  toJSON: function () {
                    return {
                      type: 'FogExp2',
                      color: this.color.getHex(),
                      density: this.density,
                    }
                  },
                }),
                Object.assign(Jo.prototype, {
                  isFog: !0,
                  clone: function () {
                    return new Jo(this.color, this.near, this.far)
                  },
                  toJSON: function () {
                    return {
                      type: 'Fog',
                      color: this.color.getHex(),
                      near: this.near,
                      far: this.far,
                    }
                  },
                }),
                Object.defineProperty(Qo.prototype, 'needsUpdate', {
                  set: function (t) {
                    !0 === t && this.version++
                  },
                }),
                Object.assign(Qo.prototype, {
                  isInterleavedBuffer: !0,
                  onUploadCallback: function () {},
                  setUsage: function (t) {
                    return (this.usage = t), this
                  },
                  copy: function (t) {
                    return (
                      (this.array = new t.array.constructor(t.array)),
                      (this.count = t.count),
                      (this.stride = t.stride),
                      (this.usage = t.usage),
                      this
                    )
                  },
                  copyAt: function (t, e, n) {
                    ;(t *= this.stride), (n *= e.stride)
                    for (var r = 0, i = this.stride; r < i; r++)
                      this.array[t + r] = e.array[n + r]
                    return this
                  },
                  set: function (t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                  },
                  clone: function (t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                      void 0 === this.array.buffer._uuid &&
                        (this.array.buffer._uuid = Xe.generateUUID()),
                      void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                        (t.arrayBuffers[this.array.buffer._uuid] =
                          this.array.slice(0).buffer)
                    var e = new Qo(
                      new this.array.constructor(
                        t.arrayBuffers[this.array.buffer._uuid],
                      ),
                      this.stride,
                    )
                    return e.setUsage(this.usage), e
                  },
                  onUpload: function (t) {
                    return (this.onUploadCallback = t), this
                  },
                  toJSON: function (t) {
                    return (
                      void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
                      void 0 === this.array.buffer._uuid &&
                        (this.array.buffer._uuid = Xe.generateUUID()),
                      void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                        (t.arrayBuffers[this.array.buffer._uuid] =
                          Array.prototype.slice.call(
                            new Uint32Array(this.array.buffer),
                          )),
                      {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride,
                      }
                    )
                  },
                })
              var Ko,
                $o = new on()
              function ts(t, e, n, r) {
                ;(this.name = ''),
                  (this.data = t),
                  (this.itemSize = e),
                  (this.offset = n),
                  (this.normalized = !0 === r)
              }
              function es(t) {
                Rr.call(this),
                  (this.type = 'SpriteMaterial'),
                  (this.color = new Mr(16777215)),
                  (this.map = null),
                  (this.alphaMap = null),
                  (this.rotation = 0),
                  (this.sizeAttenuation = !0),
                  (this.transparent = !0),
                  this.setValues(t)
              }
              Object.defineProperties(ts.prototype, {
                count: {
                  get: function () {
                    return this.data.count
                  },
                },
                array: {
                  get: function () {
                    return this.data.array
                  },
                },
              }),
                Object.assign(ts.prototype, {
                  isInterleavedBufferAttribute: !0,
                  applyMatrix4: function (t) {
                    for (var e = 0, n = this.data.count; e < n; e++)
                      ($o.x = this.getX(e)),
                        ($o.y = this.getY(e)),
                        ($o.z = this.getZ(e)),
                        $o.applyMatrix4(t),
                        this.setXYZ(e, $o.x, $o.y, $o.z)
                    return this
                  },
                  setX: function (t, e) {
                    return (
                      (this.data.array[t * this.data.stride + this.offset] = e),
                      this
                    )
                  },
                  setY: function (t, e) {
                    return (
                      (this.data.array[t * this.data.stride + this.offset + 1] =
                        e),
                      this
                    )
                  },
                  setZ: function (t, e) {
                    return (
                      (this.data.array[t * this.data.stride + this.offset + 2] =
                        e),
                      this
                    )
                  },
                  setW: function (t, e) {
                    return (
                      (this.data.array[t * this.data.stride + this.offset + 3] =
                        e),
                      this
                    )
                  },
                  getX: function (t) {
                    return this.data.array[t * this.data.stride + this.offset]
                  },
                  getY: function (t) {
                    return this.data.array[
                      t * this.data.stride + this.offset + 1
                    ]
                  },
                  getZ: function (t) {
                    return this.data.array[
                      t * this.data.stride + this.offset + 2
                    ]
                  },
                  getW: function (t) {
                    return this.data.array[
                      t * this.data.stride + this.offset + 3
                    ]
                  },
                  setXY: function (t, e, n) {
                    return (
                      (t = t * this.data.stride + this.offset),
                      (this.data.array[t + 0] = e),
                      (this.data.array[t + 1] = n),
                      this
                    )
                  },
                  setXYZ: function (t, e, n, r) {
                    return (
                      (t = t * this.data.stride + this.offset),
                      (this.data.array[t + 0] = e),
                      (this.data.array[t + 1] = n),
                      (this.data.array[t + 2] = r),
                      this
                    )
                  },
                  setXYZW: function (t, e, n, r, i) {
                    return (
                      (t = t * this.data.stride + this.offset),
                      (this.data.array[t + 0] = e),
                      (this.data.array[t + 1] = n),
                      (this.data.array[t + 2] = r),
                      (this.data.array[t + 3] = i),
                      this
                    )
                  },
                  clone: function (t) {
                    if (void 0 !== t)
                      return (
                        void 0 === t.interleavedBuffers &&
                          (t.interleavedBuffers = {}),
                        void 0 === t.interleavedBuffers[this.data.uuid] &&
                          (t.interleavedBuffers[this.data.uuid] =
                            this.data.clone(t)),
                        new ts(
                          t.interleavedBuffers[this.data.uuid],
                          this.itemSize,
                          this.offset,
                          this.normalized,
                        )
                      )
                    console.log(
                      'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.',
                    )
                    for (var e = [], n = 0; n < this.count; n++)
                      for (
                        var r = n * this.data.stride + this.offset, i = 0;
                        i < this.itemSize;
                        i++
                      )
                        e.push(this.data.array[r + i])
                    return new Ir(
                      new this.array.constructor(e),
                      this.itemSize,
                      this.normalized,
                    )
                  },
                  toJSON: function (t) {
                    if (void 0 !== t)
                      return (
                        void 0 === t.interleavedBuffers &&
                          (t.interleavedBuffers = {}),
                        void 0 === t.interleavedBuffers[this.data.uuid] &&
                          (t.interleavedBuffers[this.data.uuid] =
                            this.data.toJSON(t)),
                        {
                          isInterleavedBufferAttribute: !0,
                          itemSize: this.itemSize,
                          data: this.data.uuid,
                          offset: this.offset,
                          normalized: this.normalized,
                        }
                      )
                    console.log(
                      'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.',
                    )
                    for (var e = [], n = 0; n < this.count; n++)
                      for (
                        var r = n * this.data.stride + this.offset, i = 0;
                        i < this.itemSize;
                        i++
                      )
                        e.push(this.data.array[r + i])
                    return {
                      itemSize: this.itemSize,
                      type: this.array.constructor.name,
                      array: e,
                      normalized: this.normalized,
                    }
                  },
                }),
                (((es.prototype = Object.create(Rr.prototype)).constructor =
                  es).prototype.isSpriteMaterial = !0),
                (es.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    (this.map = t.map),
                    (this.alphaMap = t.alphaMap),
                    (this.rotation = t.rotation),
                    (this.sizeAttenuation = t.sizeAttenuation),
                    this
                  )
                })
              var ns = new on(),
                rs = new on(),
                is = new on(),
                as = new Ye(),
                os = new Ye(),
                ss = new fn(),
                cs = new on(),
                ls = new on(),
                hs = new on(),
                us = new Ye(),
                ps = new Ye(),
                ds = new Ye()
              function fs(t) {
                var e
                On.call(this),
                  (this.type = 'Sprite'),
                  void 0 === Ko &&
                    ((Ko = new Kr()),
                    (e = new Qo(
                      new Float32Array([
                        -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1,
                        1, -0.5, 0.5, 0, 0, 1,
                      ]),
                      5,
                    )),
                    Ko.setIndex([0, 1, 2, 0, 2, 3]),
                    Ko.setAttribute('position', new ts(e, 3, 0, !1)),
                    Ko.setAttribute('uv', new ts(e, 2, 3, !1))),
                  (this.geometry = Ko),
                  (this.material = void 0 !== t ? t : new es()),
                  (this.center = new Ye(0.5, 0.5))
              }
              function ms(t, e, n, r, i, a) {
                as.subVectors(t, n).addScalar(0.5).multiply(r),
                  void 0 !== i
                    ? ((os.x = a * as.x - i * as.y),
                      (os.y = i * as.x + a * as.y))
                    : os.copy(as),
                  t.copy(e),
                  (t.x += os.x),
                  (t.y += os.y),
                  t.applyMatrix4(ss)
              }
              fs.prototype = Object.assign(Object.create(On.prototype), {
                constructor: fs,
                isSprite: !0,
                raycast: function (t, e) {
                  null === t.camera &&
                    console.error(
                      'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
                    ),
                    rs.setFromMatrixScale(this.matrixWorld),
                    ss.copy(t.camera.matrixWorld),
                    this.modelViewMatrix.multiplyMatrices(
                      t.camera.matrixWorldInverse,
                      this.matrixWorld,
                    ),
                    is.setFromMatrixPosition(this.modelViewMatrix),
                    t.camera.isPerspectiveCamera &&
                      !1 === this.material.sizeAttenuation &&
                      rs.multiplyScalar(-is.z)
                  var n,
                    r,
                    i = this.material.rotation
                  0 !== i && ((r = Math.cos(i)), (n = Math.sin(i)))
                  var a = this.center
                  ms(cs.set(-0.5, -0.5, 0), is, a, rs, n, r),
                    ms(ls.set(0.5, -0.5, 0), is, a, rs, n, r),
                    ms(hs.set(0.5, 0.5, 0), is, a, rs, n, r),
                    us.set(0, 0),
                    ps.set(1, 0),
                    ds.set(1, 1)
                  var o,
                    s = t.ray.intersectTriangle(cs, ls, hs, !1, ns)
                  ;(null === s &&
                    (ms(ls.set(-0.5, 0.5, 0), is, a, rs, n, r),
                    ps.set(0, 1),
                    null === t.ray.intersectTriangle(cs, hs, ls, !1, ns))) ||
                    (o = t.ray.origin.distanceTo(ns)) < t.near ||
                    o > t.far ||
                    e.push({
                      distance: o,
                      point: ns.clone(),
                      uv: xr.getUV(ns, cs, ls, hs, us, ps, ds, new Ye()),
                      face: null,
                      object: this,
                    })
                },
                copy: function (t) {
                  return (
                    On.prototype.copy.call(this, t),
                    void 0 !== t.center && this.center.copy(t.center),
                    (this.material = t.material),
                    this
                  )
                },
              })
              var vs,
                gs,
                ys,
                xs,
                bs,
                _s = new on(),
                ws = new on()
              function Ms() {
                On.call(this),
                  (this._currentLevel = 0),
                  (this.type = 'LOD'),
                  Object.defineProperties(this, {
                    levels: { enumerable: !0, value: [] },
                  }),
                  (this.autoUpdate = !0)
              }
              function Ss(t, e) {
                t &&
                  t.isGeometry &&
                  console.error(
                    'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
                  ),
                  vi.call(this, t, e),
                  (this.type = 'SkinnedMesh'),
                  (this.bindMode = 'attached'),
                  (this.bindMatrix = new fn()),
                  (this.bindMatrixInverse = new fn())
              }
              ;(Ms.prototype = Object.assign(Object.create(On.prototype), {
                constructor: Ms,
                isLOD: !0,
                copy: function (t) {
                  On.prototype.copy.call(this, t, !1)
                  for (var e = t.levels, n = 0, r = e.length; n < r; n++) {
                    var i = e[n]
                    this.addLevel(i.object.clone(), i.distance)
                  }
                  return (this.autoUpdate = t.autoUpdate), this
                },
                addLevel: function (t, e) {
                  void 0 === e && (e = 0), (e = Math.abs(e))
                  for (
                    var n = this.levels, r = 0;
                    r < n.length && !(e < n[r].distance);
                    r++
                  );
                  return (
                    n.splice(r, 0, { distance: e, object: t }),
                    this.add(t),
                    this
                  )
                },
                getCurrentLevel: function () {
                  return this._currentLevel
                },
                getObjectForDistance: function (t) {
                  var e = this.levels
                  if (0 < e.length) {
                    for (
                      var n = 1, r = e.length;
                      n < r && !(t < e[n].distance);
                      n++
                    );
                    return e[n - 1].object
                  }
                  return null
                },
                raycast: function (t, e) {
                  var n
                  0 < this.levels.length &&
                    (_s.setFromMatrixPosition(this.matrixWorld),
                    (n = t.ray.origin.distanceTo(_s)),
                    this.getObjectForDistance(n).raycast(t, e))
                },
                update: function (t) {
                  var e = this.levels
                  if (1 < e.length) {
                    _s.setFromMatrixPosition(t.matrixWorld),
                      ws.setFromMatrixPosition(this.matrixWorld)
                    var n,
                      r,
                      i = _s.distanceTo(ws) / t.zoom
                    for (
                      e[0].object.visible = !0, n = 1, r = e.length;
                      n < r && i >= e[n].distance;
                      n++
                    )
                      (e[n - 1].object.visible = !1), (e[n].object.visible = !0)
                    for (this._currentLevel = n - 1; n < r; n++)
                      e[n].object.visible = !1
                  }
                },
                toJSON: function (t) {
                  var e = On.prototype.toJSON.call(this, t)
                  !1 === this.autoUpdate && (e.object.autoUpdate = !1),
                    (e.object.levels = [])
                  for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                    var a = n[r]
                    e.object.levels.push({
                      object: a.object.uuid,
                      distance: a.distance,
                    })
                  }
                  return e
                },
              })),
                (Ss.prototype = Object.assign(Object.create(vi.prototype), {
                  constructor: Ss,
                  isSkinnedMesh: !0,
                  copy: function (t) {
                    return (
                      vi.prototype.copy.call(this, t),
                      (this.bindMode = t.bindMode),
                      this.bindMatrix.copy(t.bindMatrix),
                      this.bindMatrixInverse.copy(t.bindMatrixInverse),
                      (this.skeleton = t.skeleton),
                      this
                    )
                  },
                  bind: function (t, e) {
                    ;(this.skeleton = t),
                      void 0 === e &&
                        (this.updateMatrixWorld(!0),
                        this.skeleton.calculateInverses(),
                        (e = this.matrixWorld)),
                      this.bindMatrix.copy(e),
                      this.bindMatrixInverse.getInverse(e)
                  },
                  pose: function () {
                    this.skeleton.pose()
                  },
                  normalizeSkinWeights: function () {
                    for (
                      var t = new $e(),
                        e = this.geometry.attributes.skinWeight,
                        n = 0,
                        r = e.count;
                      n < r;
                      n++
                    ) {
                      ;(t.x = e.getX(n)),
                        (t.y = e.getY(n)),
                        (t.z = e.getZ(n)),
                        (t.w = e.getW(n))
                      var i = 1 / t.manhattanLength()
                      i != 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                        e.setXYZW(n, t.x, t.y, t.z, t.w)
                    }
                  },
                  updateMatrixWorld: function (t) {
                    vi.prototype.updateMatrixWorld.call(this, t),
                      'attached' === this.bindMode
                        ? this.bindMatrixInverse.getInverse(this.matrixWorld)
                        : 'detached' === this.bindMode
                          ? this.bindMatrixInverse.getInverse(this.bindMatrix)
                          : console.warn(
                              'THREE.SkinnedMesh: Unrecognized bindMode: ' +
                                this.bindMode,
                            )
                  },
                  boneTransform:
                    ((vs = new on()),
                    (gs = new $e()),
                    (ys = new $e()),
                    (xs = new on()),
                    (bs = new fn()),
                    function (t, e) {
                      var n = this.skeleton,
                        r = this.geometry
                      gs.fromBufferAttribute(r.attributes.skinIndex, t),
                        ys.fromBufferAttribute(r.attributes.skinWeight, t),
                        vs
                          .fromBufferAttribute(r.attributes.position, t)
                          .applyMatrix4(this.bindMatrix),
                        e.set(0, 0, 0)
                      for (var i = 0; i < 4; i++) {
                        var a,
                          o = ys.getComponent(i)
                        0 !== o &&
                          ((a = gs.getComponent(i)),
                          bs.multiplyMatrices(
                            n.bones[a].matrixWorld,
                            n.boneInverses[a],
                          ),
                          e.addScaledVector(xs.copy(vs).applyMatrix4(bs), o))
                      }
                      return e.applyMatrix4(this.bindMatrixInverse)
                    }),
                }))
              var Es = new fn(),
                Ts = new fn()
              function As(t, e) {
                if (
                  ((t = t || []),
                  (this.bones = t.slice(0)),
                  (this.boneMatrices = new Float32Array(
                    16 * this.bones.length,
                  )),
                  (this.frame = -1),
                  void 0 === e)
                )
                  this.calculateInverses()
                else if (this.bones.length === e.length)
                  this.boneInverses = e.slice(0)
                else {
                  console.warn(
                    'THREE.Skeleton boneInverses is the wrong length.',
                  ),
                    (this.boneInverses = [])
                  for (var n = 0, r = this.bones.length; n < r; n++)
                    this.boneInverses.push(new fn())
                }
              }
              function Ls() {
                On.call(this), (this.type = 'Bone')
              }
              Object.assign(As.prototype, {
                calculateInverses: function () {
                  this.boneInverses = []
                  for (var t = 0, e = this.bones.length; t < e; t++) {
                    var n = new fn()
                    this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
                      this.boneInverses.push(n)
                  }
                },
                pose: function () {
                  for (var t = 0, e = this.bones.length; t < e; t++) {
                    var n = this.bones[t]
                    n && n.matrixWorld.getInverse(this.boneInverses[t])
                  }
                  for (var r = 0, i = this.bones.length; r < i; r++) {
                    var a = this.bones[r]
                    a &&
                      (a.parent && a.parent.isBone
                        ? (a.matrix.getInverse(a.parent.matrixWorld),
                          a.matrix.multiply(a.matrixWorld))
                        : a.matrix.copy(a.matrixWorld),
                      a.matrix.decompose(a.position, a.quaternion, a.scale))
                  }
                },
                update: function () {
                  for (
                    var t = this.bones,
                      e = this.boneInverses,
                      n = this.boneMatrices,
                      r = this.boneTexture,
                      i = 0,
                      a = t.length;
                    i < a;
                    i++
                  ) {
                    var o = t[i] ? t[i].matrixWorld : Ts
                    Es.multiplyMatrices(o, e[i]), Es.toArray(n, 16 * i)
                  }
                  void 0 !== r && (r.needsUpdate = !0)
                },
                clone: function () {
                  return new As(this.bones, this.boneInverses)
                },
                getBoneByName: function (t) {
                  for (var e = 0, n = this.bones.length; e < n; e++) {
                    var r = this.bones[e]
                    if (r.name === t) return r
                  }
                },
                dispose: function () {
                  this.boneTexture &&
                    (this.boneTexture.dispose(), (this.boneTexture = void 0))
                },
              }),
                (Ls.prototype = Object.assign(Object.create(On.prototype), {
                  constructor: Ls,
                  isBone: !0,
                }))
              var Rs = new fn(),
                Cs = new fn(),
                Ps = [],
                Os = new vi()
              function Is(t, e, n) {
                vi.call(this, t, e),
                  (this.instanceMatrix = new Ir(new Float32Array(16 * n), 16)),
                  (this.count = n),
                  (this.frustumCulled = !1)
              }
              function Ds(t) {
                Rr.call(this),
                  (this.type = 'LineBasicMaterial'),
                  (this.color = new Mr(16777215)),
                  (this.linewidth = 1),
                  (this.linecap = 'round'),
                  (this.linejoin = 'round'),
                  (this.morphTargets = !1),
                  this.setValues(t)
              }
              ;(Is.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Is,
                isInstancedMesh: !0,
                copy: function (t) {
                  return (
                    vi.prototype.copy.call(this, t),
                    this.instanceMatrix.copy(t.instanceMatrix),
                    (this.count = t.count),
                    this
                  )
                },
                getMatrixAt: function (t, e) {
                  e.fromArray(this.instanceMatrix.array, 16 * t)
                },
                raycast: function (t, e) {
                  var n = this.matrixWorld,
                    r = this.count
                  if (
                    ((Os.geometry = this.geometry),
                    (Os.material = this.material),
                    void 0 !== Os.material)
                  )
                    for (var i = 0; i < r; i++) {
                      this.getMatrixAt(i, Rs),
                        Cs.multiplyMatrices(n, Rs),
                        (Os.matrixWorld = Cs),
                        Os.raycast(t, Ps)
                      for (var a = 0, o = Ps.length; a < o; a++) {
                        var s = Ps[a]
                        ;(s.instanceId = i), (s.object = this), e.push(s)
                      }
                      Ps.length = 0
                    }
                },
                setMatrixAt: function (t, e) {
                  e.toArray(this.instanceMatrix.array, 16 * t)
                },
                updateMorphTargets: function () {},
              })),
                (((Ds.prototype = Object.create(Rr.prototype)).constructor =
                  Ds).prototype.isLineBasicMaterial = !0),
                (Ds.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    (this.linewidth = t.linewidth),
                    (this.linecap = t.linecap),
                    (this.linejoin = t.linejoin),
                    (this.morphTargets = t.morphTargets),
                    this
                  )
                })
              var Bs = new on(),
                Ns = new on(),
                Us = new fn(),
                zs = new ir(),
                Fs = new Jn()
              function Hs(t, e, n) {
                1 === n &&
                  console.error(
                    'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.',
                  ),
                  On.call(this),
                  (this.type = 'Line'),
                  (this.geometry = void 0 !== t ? t : new Kr()),
                  (this.material = void 0 !== e ? e : new Ds()),
                  this.updateMorphTargets()
              }
              Hs.prototype = Object.assign(Object.create(On.prototype), {
                constructor: Hs,
                isLine: !0,
                copy: function (t) {
                  return (
                    On.prototype.copy.call(this, t),
                    (this.material = t.material),
                    (this.geometry = t.geometry),
                    this
                  )
                },
                computeLineDistances: function () {
                  var t = this.geometry
                  if (t.isBufferGeometry)
                    if (null === t.index) {
                      for (
                        var e = t.attributes.position,
                          n = [0],
                          r = 1,
                          i = e.count;
                        r < i;
                        r++
                      )
                        Bs.fromBufferAttribute(e, r - 1),
                          Ns.fromBufferAttribute(e, r),
                          (n[r] = n[r - 1]),
                          (n[r] += Bs.distanceTo(Ns))
                      t.setAttribute('lineDistance', new Gr(n, 1))
                    } else
                      console.warn(
                        'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
                      )
                  else if (t.isGeometry) {
                    var a = t.vertices,
                      o = t.lineDistances
                    o[0] = 0
                    for (var s = 1, c = a.length; s < c; s++)
                      (o[s] = o[s - 1]), (o[s] += a[s - 1].distanceTo(a[s]))
                  }
                  return this
                },
                raycast: function (t, e) {
                  var n = this.geometry,
                    r = this.matrixWorld,
                    i = t.params.Line.threshold
                  if (
                    (null === n.boundingSphere && n.computeBoundingSphere(),
                    Fs.copy(n.boundingSphere),
                    Fs.applyMatrix4(r),
                    (Fs.radius += i),
                    !1 !== t.ray.intersectsSphere(Fs))
                  ) {
                    Us.getInverse(r), zs.copy(t.ray).applyMatrix4(Us)
                    var a =
                        i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                      o = a * a,
                      s = new on(),
                      c = new on(),
                      l = new on(),
                      h = new on(),
                      u = this && this.isLineSegments ? 2 : 1
                    if (n.isBufferGeometry) {
                      var p = n.index,
                        d = n.attributes.position.array
                      if (null !== p)
                        for (
                          var f = p.array, m = 0, v = f.length - 1;
                          m < v;
                          m += u
                        ) {
                          var g,
                            y = f[m],
                            x = f[m + 1]
                          s.fromArray(d, 3 * y),
                            c.fromArray(d, 3 * x),
                            o < zs.distanceSqToSegment(s, c, h, l) ||
                              (h.applyMatrix4(this.matrixWorld),
                              (g = t.ray.origin.distanceTo(h)) < t.near ||
                                g > t.far ||
                                e.push({
                                  distance: g,
                                  point: l
                                    .clone()
                                    .applyMatrix4(this.matrixWorld),
                                  index: m,
                                  face: null,
                                  faceIndex: null,
                                  object: this,
                                }))
                        }
                      else
                        for (
                          var b, _ = 0, w = d.length / 3 - 1;
                          _ < w;
                          _ += u
                        ) {
                          s.fromArray(d, 3 * _),
                            c.fromArray(d, 3 * _ + 3),
                            o < zs.distanceSqToSegment(s, c, h, l) ||
                              (h.applyMatrix4(this.matrixWorld),
                              (b = t.ray.origin.distanceTo(h)) < t.near ||
                                b > t.far ||
                                e.push({
                                  distance: b,
                                  point: l
                                    .clone()
                                    .applyMatrix4(this.matrixWorld),
                                  index: _,
                                  face: null,
                                  faceIndex: null,
                                  object: this,
                                }))
                        }
                    } else if (n.isGeometry)
                      for (
                        var M, S = n.vertices, E = S.length, T = 0;
                        T < E - 1;
                        T += u
                      ) {
                        o < zs.distanceSqToSegment(S[T], S[T + 1], h, l) ||
                          (h.applyMatrix4(this.matrixWorld),
                          (M = t.ray.origin.distanceTo(h)) < t.near ||
                            M > t.far ||
                            e.push({
                              distance: M,
                              point: l.clone().applyMatrix4(this.matrixWorld),
                              index: T,
                              face: null,
                              faceIndex: null,
                              object: this,
                            }))
                      }
                  }
                },
                updateMorphTargets: function () {
                  var t = this.geometry
                  if (t.isBufferGeometry) {
                    var e = t.morphAttributes,
                      n = Object.keys(e)
                    if (0 < n.length) {
                      var r = e[n[0]]
                      if (void 0 !== r) {
                        ;(this.morphTargetInfluences = []),
                          (this.morphTargetDictionary = {})
                        for (var i = 0, a = r.length; i < a; i++) {
                          var o = r[i].name || String(i)
                          this.morphTargetInfluences.push(0),
                            (this.morphTargetDictionary[o] = i)
                        }
                      }
                    }
                  } else {
                    var s = t.morphTargets
                    void 0 !== s &&
                      0 < s.length &&
                      console.error(
                        'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',
                      )
                  }
                },
              })
              var Gs = new on(),
                ks = new on()
              function Vs(t, e) {
                Hs.call(this, t, e), (this.type = 'LineSegments')
              }
              function js(t, e) {
                Hs.call(this, t, e), (this.type = 'LineLoop')
              }
              function Ws(t) {
                Rr.call(this),
                  (this.type = 'PointsMaterial'),
                  (this.color = new Mr(16777215)),
                  (this.map = null),
                  (this.alphaMap = null),
                  (this.size = 1),
                  (this.sizeAttenuation = !0),
                  (this.morphTargets = !1),
                  this.setValues(t)
              }
              ;(Vs.prototype = Object.assign(Object.create(Hs.prototype), {
                constructor: Vs,
                isLineSegments: !0,
                computeLineDistances: function () {
                  var t = this.geometry
                  if (t.isBufferGeometry)
                    if (null === t.index) {
                      for (
                        var e = t.attributes.position,
                          n = [],
                          r = 0,
                          i = e.count;
                        r < i;
                        r += 2
                      )
                        Gs.fromBufferAttribute(e, r),
                          ks.fromBufferAttribute(e, r + 1),
                          (n[r] = 0 === r ? 0 : n[r - 1]),
                          (n[r + 1] = n[r] + Gs.distanceTo(ks))
                      t.setAttribute('lineDistance', new Gr(n, 1))
                    } else
                      console.warn(
                        'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
                      )
                  else if (t.isGeometry)
                    for (
                      var a = t.vertices,
                        o = t.lineDistances,
                        s = 0,
                        c = a.length;
                      s < c;
                      s += 2
                    )
                      Gs.copy(a[s]),
                        ks.copy(a[s + 1]),
                        (o[s] = 0 === s ? 0 : o[s - 1]),
                        (o[s + 1] = o[s] + Gs.distanceTo(ks))
                  return this
                },
              })),
                (js.prototype = Object.assign(Object.create(Hs.prototype), {
                  constructor: js,
                  isLineLoop: !0,
                })),
                (((Ws.prototype = Object.create(Rr.prototype)).constructor =
                  Ws).prototype.isPointsMaterial = !0),
                (Ws.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    (this.map = t.map),
                    (this.alphaMap = t.alphaMap),
                    (this.size = t.size),
                    (this.sizeAttenuation = t.sizeAttenuation),
                    (this.morphTargets = t.morphTargets),
                    this
                  )
                })
              var qs = new fn(),
                Xs = new ir(),
                Ys = new Jn(),
                Zs = new on()
              function Js(t, e) {
                On.call(this),
                  (this.type = 'Points'),
                  (this.geometry = void 0 !== t ? t : new Kr()),
                  (this.material = void 0 !== e ? e : new Ws()),
                  this.updateMorphTargets()
              }
              function Qs(t, e, n, r, i, a, o) {
                var s = Xs.distanceSqToPoint(t)
                if (s < n) {
                  var c = new on()
                  Xs.closestPointToPoint(t, c), c.applyMatrix4(r)
                  var l = i.ray.origin.distanceTo(c)
                  if (l < i.near || l > i.far) return
                  a.push({
                    distance: l,
                    distanceToRay: Math.sqrt(s),
                    point: c,
                    index: e,
                    face: null,
                    object: o,
                  })
                }
              }
              function Ks(t, e, n, r, i, a, o, s, c) {
                Ke.call(this, t, e, n, r, i, a, o, s, c),
                  (this.format = void 0 !== o ? o : Kt),
                  (this.minFilter = void 0 !== a ? a : Vt),
                  (this.magFilter = void 0 !== i ? i : Vt),
                  (this.generateMipmaps = !1)
              }
              function $s(t, e, n, r, i, a, o, s, c, l, h, u) {
                Ke.call(this, null, a, o, s, c, l, r, i, h, u),
                  (this.image = { width: e, height: n }),
                  (this.mipmaps = t),
                  (this.flipY = !1),
                  (this.generateMipmaps = !1)
              }
              function tc(t, e, n, r, i, a, o, s, c) {
                Ke.call(this, t, e, n, r, i, a, o, s, c),
                  (this.needsUpdate = !0)
              }
              function ec(t, e, n, r, i, a, o, s, c, l) {
                if ((l = void 0 !== l ? l : te) !== te && l !== ee)
                  throw new Error(
                    'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
                  )
                void 0 === n && l === te && (n = Xt),
                  void 0 === n && l === ee && (n = Qt),
                  Ke.call(this, null, r, i, a, o, s, l, n, c),
                  (this.image = { width: t, height: e }),
                  (this.magFilter = void 0 !== o ? o : Ht),
                  (this.minFilter = void 0 !== s ? s : Ht),
                  (this.flipY = !1),
                  (this.generateMipmaps = !1)
              }
              function nc(t) {
                Kr.call(this), (this.type = 'WireframeGeometry')
                var e = [],
                  n = [0, 0],
                  r = {},
                  i = ['a', 'b', 'c']
                if (t && t.isGeometry) {
                  for (var a = t.faces, o = 0, s = a.length; o < s; o++)
                    for (var c = a[o], l = 0; l < 3; l++) {
                      var h = c[i[l]],
                        u = c[i[(l + 1) % 3]]
                      ;(n[0] = Math.min(h, u)), (n[1] = Math.max(h, u))
                      var p = n[0] + ',' + n[1]
                      void 0 === r[p] && (r[p] = { index1: n[0], index2: n[1] })
                    }
                  for (var d in r) {
                    var f = r[d],
                      m = t.vertices[f.index1]
                    e.push(m.x, m.y, m.z),
                      (m = t.vertices[f.index2]),
                      e.push(m.x, m.y, m.z)
                  }
                } else if (t && t.isBufferGeometry) {
                  var v = new on()
                  if (null !== t.index) {
                    var g = t.attributes.position,
                      y = t.index,
                      x = t.groups
                    0 === x.length &&
                      (x = [{ start: 0, count: y.count, materialIndex: 0 }])
                    for (var b = 0, _ = x.length; b < _; ++b)
                      for (
                        var w = x[b], M = w.start, S = M, E = M + w.count;
                        S < E;
                        S += 3
                      )
                        for (var T = 0; T < 3; T++) {
                          var A = y.getX(S + T),
                            L = y.getX(S + ((T + 1) % 3))
                          ;(n[0] = Math.min(A, L)), (n[1] = Math.max(A, L))
                          var R = n[0] + ',' + n[1]
                          void 0 === r[R] &&
                            (r[R] = { index1: n[0], index2: n[1] })
                        }
                    for (var C in r) {
                      var P = r[C]
                      v.fromBufferAttribute(g, P.index1),
                        e.push(v.x, v.y, v.z),
                        v.fromBufferAttribute(g, P.index2),
                        e.push(v.x, v.y, v.z)
                    }
                  } else
                    for (
                      var O = t.attributes.position, I = 0, D = O.count / 3;
                      I < D;
                      I++
                    )
                      for (var B = 0; B < 3; B++) {
                        var N = 3 * I + B
                        v.fromBufferAttribute(O, N), e.push(v.x, v.y, v.z)
                        var U = 3 * I + ((B + 1) % 3)
                        v.fromBufferAttribute(O, U), e.push(v.x, v.y, v.z)
                      }
                }
                this.setAttribute('position', new Gr(e, 3))
              }
              function rc(t, e, n) {
                Mi.call(this),
                  (this.type = 'ParametricGeometry'),
                  (this.parameters = { func: t, slices: e, stacks: n }),
                  this.fromBufferGeometry(new ic(t, e, n)),
                  this.mergeVertices()
              }
              function ic(t, e, n) {
                Kr.call(this),
                  (this.type = 'ParametricBufferGeometry'),
                  (this.parameters = { func: t, slices: e, stacks: n })
                var r = [],
                  i = [],
                  a = [],
                  o = [],
                  s = new on(),
                  c = new on(),
                  l = new on(),
                  h = new on(),
                  u = new on()
                t.length < 3 &&
                  console.error(
                    'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.',
                  )
                for (var p = e + 1, d = 0; d <= n; d++)
                  for (var f = d / n, m = 0; m <= e; m++) {
                    var v = m / e
                    t(v, f, c),
                      i.push(c.x, c.y, c.z),
                      0 <= v - 1e-5
                        ? (t(v - 1e-5, f, l), h.subVectors(c, l))
                        : (t(1e-5 + v, f, l), h.subVectors(l, c)),
                      0 <= f - 1e-5
                        ? (t(v, f - 1e-5, l), u.subVectors(c, l))
                        : (t(v, 1e-5 + f, l), u.subVectors(l, c)),
                      s.crossVectors(h, u).normalize(),
                      a.push(s.x, s.y, s.z),
                      o.push(v, f)
                  }
                for (var g = 0; g < n; g++)
                  for (var y = 0; y < e; y++) {
                    var x = g * p + y,
                      b = g * p + y + 1,
                      _ = (g + 1) * p + y + 1,
                      w = (g + 1) * p + y
                    r.push(x, b, w), r.push(b, _, w)
                  }
                this.setIndex(r),
                  this.setAttribute('position', new Gr(i, 3)),
                  this.setAttribute('normal', new Gr(a, 3)),
                  this.setAttribute('uv', new Gr(o, 2))
              }
              function ac(t, e, n, r) {
                Mi.call(this),
                  (this.type = 'PolyhedronGeometry'),
                  (this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: r,
                  }),
                  this.fromBufferGeometry(new oc(t, e, n, r)),
                  this.mergeVertices()
              }
              function oc(r, a, t, e) {
                Kr.call(this),
                  (this.type = 'PolyhedronBufferGeometry'),
                  (this.parameters = {
                    vertices: r,
                    indices: a,
                    radius: t,
                    detail: e,
                  }),
                  (t = t || 1)
                var h = [],
                  u = []
                function f(t) {
                  h.push(t.x, t.y, t.z)
                }
                function o(t, e) {
                  var n = 3 * t
                  ;(e.x = r[0 + n]), (e.y = r[1 + n]), (e.z = r[2 + n])
                }
                function p(t, e, n, r) {
                  r < 0 && 1 === t.x && (u[e] = t.x - 1),
                    0 === n.x && 0 === n.z && (u[e] = r / 2 / Math.PI + 0.5)
                }
                function d(t) {
                  return Math.atan2(t.z, -t.x)
                }
                !(function (t) {
                  for (
                    var e = new on(), n = new on(), r = new on(), i = 0;
                    i < a.length;
                    i += 3
                  )
                    o(a[i + 0], e),
                      o(a[i + 1], n),
                      o(a[i + 2], r),
                      (function (t, e, n, r) {
                        for (
                          var i = Math.pow(2, r), a = [], o = 0;
                          o <= i;
                          o++
                        ) {
                          a[o] = []
                          for (
                            var s = t.clone().lerp(n, o / i),
                              c = e.clone().lerp(n, o / i),
                              l = i - o,
                              h = 0;
                            h <= l;
                            h++
                          )
                            a[o][h] =
                              0 === h && o === i ? s : s.clone().lerp(c, h / l)
                        }
                        for (var u = 0; u < i; u++)
                          for (var p = 0; p < 2 * (i - u) - 1; p++) {
                            var d = Math.floor(p / 2)
                            p % 2 == 0
                              ? (f(a[u][d + 1]), f(a[u + 1][d]), f(a[u][d]))
                              : (f(a[u][d + 1]),
                                f(a[u + 1][d + 1]),
                                f(a[u + 1][d]))
                          }
                      })(e, n, r, t)
                })((e = e || 0)),
                  (function (t) {
                    for (var e = new on(), n = 0; n < h.length; n += 3)
                      (e.x = h[n + 0]),
                        (e.y = h[n + 1]),
                        (e.z = h[n + 2]),
                        e.normalize().multiplyScalar(t),
                        (h[n + 0] = e.x),
                        (h[n + 1] = e.y),
                        (h[n + 2] = e.z)
                  })(t),
                  (function () {
                    for (var t = new on(), e = 0; e < h.length; e += 3) {
                      ;(t.x = h[e + 0]), (t.y = h[e + 1]), (t.z = h[e + 2])
                      var n = d(t) / 2 / Math.PI + 0.5,
                        r =
                          (function (t) {
                            return Math.atan2(
                              -t.y,
                              Math.sqrt(t.x * t.x + t.z * t.z),
                            )
                          })(t) /
                            Math.PI +
                          0.5
                      u.push(n, 1 - r)
                    }
                    ;(function () {
                      for (
                        var t = new on(),
                          e = new on(),
                          n = new on(),
                          r = new on(),
                          i = new Ye(),
                          a = new Ye(),
                          o = new Ye(),
                          s = 0,
                          c = 0;
                        s < h.length;
                        s += 9, c += 6
                      ) {
                        t.set(h[s + 0], h[s + 1], h[s + 2]),
                          e.set(h[s + 3], h[s + 4], h[s + 5]),
                          n.set(h[s + 6], h[s + 7], h[s + 8]),
                          i.set(u[c + 0], u[c + 1]),
                          a.set(u[c + 2], u[c + 3]),
                          o.set(u[c + 4], u[c + 5]),
                          r.copy(t).add(e).add(n).divideScalar(3)
                        var l = d(r)
                        p(i, c + 0, t, l), p(a, c + 2, e, l), p(o, c + 4, n, l)
                      }
                    })(),
                      (function () {
                        for (var t = 0; t < u.length; t += 6) {
                          var e = u[t + 0],
                            n = u[t + 2],
                            r = u[t + 4],
                            i = Math.max(e, n, r),
                            a = Math.min(e, n, r)
                          0.9 < i &&
                            a < 0.1 &&
                            (e < 0.2 && (u[t + 0] += 1),
                            n < 0.2 && (u[t + 2] += 1),
                            r < 0.2 && (u[t + 4] += 1))
                        }
                      })()
                  })(),
                  this.setAttribute('position', new Gr(h, 3)),
                  this.setAttribute('normal', new Gr(h.slice(), 3)),
                  this.setAttribute('uv', new Gr(u, 2)),
                  0 === e
                    ? this.computeVertexNormals()
                    : this.normalizeNormals()
              }
              function sc(t, e) {
                Mi.call(this),
                  (this.type = 'TetrahedronGeometry'),
                  (this.parameters = { radius: t, detail: e }),
                  this.fromBufferGeometry(new cc(t, e)),
                  this.mergeVertices()
              }
              function cc(t, e) {
                oc.call(
                  this,
                  [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                  [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
                  t,
                  e,
                ),
                  (this.type = 'TetrahedronBufferGeometry'),
                  (this.parameters = { radius: t, detail: e })
              }
              function lc(t, e) {
                Mi.call(this),
                  (this.type = 'OctahedronGeometry'),
                  (this.parameters = { radius: t, detail: e }),
                  this.fromBufferGeometry(new hc(t, e)),
                  this.mergeVertices()
              }
              function hc(t, e) {
                oc.call(
                  this,
                  [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                  [
                    0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3,
                    4, 1, 4, 2,
                  ],
                  t,
                  e,
                ),
                  (this.type = 'OctahedronBufferGeometry'),
                  (this.parameters = { radius: t, detail: e })
              }
              function uc(t, e) {
                Mi.call(this),
                  (this.type = 'IcosahedronGeometry'),
                  (this.parameters = { radius: t, detail: e }),
                  this.fromBufferGeometry(new pc(t, e)),
                  this.mergeVertices()
              }
              function pc(t, e) {
                var n = (1 + Math.sqrt(5)) / 2
                oc.call(
                  this,
                  [
                    -1,
                    n,
                    0,
                    1,
                    n,
                    0,
                    -1,
                    -n,
                    0,
                    1,
                    -n,
                    0,
                    0,
                    -1,
                    n,
                    0,
                    1,
                    n,
                    0,
                    -1,
                    -n,
                    0,
                    1,
                    -n,
                    n,
                    0,
                    -1,
                    n,
                    0,
                    1,
                    -n,
                    0,
                    -1,
                    -n,
                    0,
                    1,
                  ],
                  [
                    0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5,
                    11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2,
                    6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7,
                    9, 8, 1,
                  ],
                  t,
                  e,
                ),
                  (this.type = 'IcosahedronBufferGeometry'),
                  (this.parameters = { radius: t, detail: e })
              }
              function dc(t, e) {
                Mi.call(this),
                  (this.type = 'DodecahedronGeometry'),
                  (this.parameters = { radius: t, detail: e }),
                  this.fromBufferGeometry(new fc(t, e)),
                  this.mergeVertices()
              }
              function fc(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                  r = 1 / n
                oc.call(
                  this,
                  [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    1,
                    -1,
                    1,
                    -1,
                    -1,
                    1,
                    1,
                    1,
                    -1,
                    -1,
                    1,
                    -1,
                    1,
                    1,
                    1,
                    -1,
                    1,
                    1,
                    1,
                    0,
                    -r,
                    -n,
                    0,
                    -r,
                    n,
                    0,
                    r,
                    -n,
                    0,
                    r,
                    n,
                    -r,
                    -n,
                    0,
                    -r,
                    n,
                    0,
                    r,
                    -n,
                    0,
                    r,
                    n,
                    0,
                    -n,
                    0,
                    -r,
                    n,
                    0,
                    -r,
                    -n,
                    0,
                    r,
                    n,
                    0,
                    r,
                  ],
                  [
                    3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6,
                    15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8,
                    2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6,
                    13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11,
                    18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5,
                    19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14,
                    1, 14, 5, 1, 5, 9,
                  ],
                  t,
                  e,
                ),
                  (this.type = 'DodecahedronBufferGeometry'),
                  (this.parameters = { radius: t, detail: e })
              }
              function mc(t, e, n, r, i, a) {
                Mi.call(this),
                  (this.type = 'TubeGeometry'),
                  (this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: r,
                    closed: i,
                  }),
                  void 0 !== a &&
                    console.warn('THREE.TubeGeometry: taper has been removed.')
                var o = new vc(t, e, n, r, i)
                ;(this.tangents = o.tangents),
                  (this.normals = o.normals),
                  (this.binormals = o.binormals),
                  this.fromBufferGeometry(o),
                  this.mergeVertices()
              }
              function vc(s, c, l, h, e) {
                Kr.call(this),
                  (this.type = 'TubeBufferGeometry'),
                  (this.parameters = {
                    path: s,
                    tubularSegments: c,
                    radius: l,
                    radialSegments: h,
                    closed: e,
                  }),
                  (c = c || 64),
                  (l = l || 1),
                  (h = h || 8),
                  (e = e || !1)
                var u = s.computeFrenetFrames(c, e)
                ;(this.tangents = u.tangents),
                  (this.normals = u.normals),
                  (this.binormals = u.binormals)
                var p = new on(),
                  d = new on(),
                  n = new Ye(),
                  f = new on(),
                  m = [],
                  v = [],
                  r = [],
                  o = []
                function i(t) {
                  f = s.getPointAt(t / c, f)
                  for (
                    var e = u.normals[t], n = u.binormals[t], r = 0;
                    r <= h;
                    r++
                  ) {
                    var i = (r / h) * Math.PI * 2,
                      a = Math.sin(i),
                      o = -Math.cos(i)
                    ;(d.x = o * e.x + a * n.x),
                      (d.y = o * e.y + a * n.y),
                      (d.z = o * e.z + a * n.z),
                      d.normalize(),
                      v.push(d.x, d.y, d.z),
                      (p.x = f.x + l * d.x),
                      (p.y = f.y + l * d.y),
                      (p.z = f.z + l * d.z),
                      m.push(p.x, p.y, p.z)
                  }
                }
                !(function () {
                  for (var t = 0; t < c; t++) i(t)
                  i(!1 === e ? c : 0),
                    (function () {
                      for (var t = 0; t <= c; t++)
                        for (var e = 0; e <= h; e++)
                          (n.x = t / c), (n.y = e / h), r.push(n.x, n.y)
                    })(),
                    (function () {
                      for (var t = 1; t <= c; t++)
                        for (var e = 1; e <= h; e++) {
                          var n = (h + 1) * (t - 1) + (e - 1),
                            r = (h + 1) * t + (e - 1),
                            i = (h + 1) * t + e,
                            a = (h + 1) * (t - 1) + e
                          o.push(n, r, a), o.push(r, i, a)
                        }
                    })()
                })(),
                  this.setIndex(o),
                  this.setAttribute('position', new Gr(m, 3)),
                  this.setAttribute('normal', new Gr(v, 3)),
                  this.setAttribute('uv', new Gr(r, 2))
              }
              function gc(t, e, n, r, i, a, o) {
                Mi.call(this),
                  (this.type = 'TorusKnotGeometry'),
                  (this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: a,
                  }),
                  void 0 !== o &&
                    console.warn(
                      'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.',
                    ),
                  this.fromBufferGeometry(new yc(t, e, n, r, i, a)),
                  this.mergeVertices()
              }
              function yc(t, e, n, r, i, a) {
                Kr.call(this),
                  (this.type = 'TorusKnotBufferGeometry'),
                  (this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: a,
                  }),
                  (t = t || 1),
                  (e = e || 0.4),
                  (n = Math.floor(n) || 64),
                  (r = Math.floor(r) || 8),
                  (i = i || 2),
                  (a = a || 3)
                for (
                  var o = [],
                    s = [],
                    c = [],
                    l = [],
                    h = new on(),
                    u = new on(),
                    p = new on(),
                    d = new on(),
                    f = new on(),
                    m = new on(),
                    v = new on(),
                    g = 0;
                  g <= n;
                  ++g
                ) {
                  var y = (g / n) * i * Math.PI * 2
                  R(y, i, a, t, p),
                    R(0.01 + y, i, a, t, d),
                    m.subVectors(d, p),
                    v.addVectors(d, p),
                    f.crossVectors(m, v),
                    v.crossVectors(f, m),
                    f.normalize(),
                    v.normalize()
                  for (var x = 0; x <= r; ++x) {
                    var b = (x / r) * Math.PI * 2,
                      _ = -e * Math.cos(b),
                      w = e * Math.sin(b)
                    ;(h.x = p.x + (_ * v.x + w * f.x)),
                      (h.y = p.y + (_ * v.y + w * f.y)),
                      (h.z = p.z + (_ * v.z + w * f.z)),
                      s.push(h.x, h.y, h.z),
                      u.subVectors(h, p).normalize(),
                      c.push(u.x, u.y, u.z),
                      l.push(g / n),
                      l.push(x / r)
                  }
                }
                for (var M = 1; M <= n; M++)
                  for (var S = 1; S <= r; S++) {
                    var E = (r + 1) * (M - 1) + (S - 1),
                      T = (r + 1) * M + (S - 1),
                      A = (r + 1) * M + S,
                      L = (r + 1) * (M - 1) + S
                    o.push(E, T, L), o.push(T, A, L)
                  }
                function R(t, e, n, r, i) {
                  var a = Math.cos(t),
                    o = Math.sin(t),
                    s = (n / e) * t,
                    c = Math.cos(s)
                  ;(i.x = r * (2 + c) * 0.5 * a),
                    (i.y = r * (2 + c) * o * 0.5),
                    (i.z = r * Math.sin(s) * 0.5)
                }
                this.setIndex(o),
                  this.setAttribute('position', new Gr(s, 3)),
                  this.setAttribute('normal', new Gr(c, 3)),
                  this.setAttribute('uv', new Gr(l, 2))
              }
              function xc(t, e, n, r, i) {
                Mi.call(this),
                  (this.type = 'TorusGeometry'),
                  (this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i,
                  }),
                  this.fromBufferGeometry(new bc(t, e, n, r, i)),
                  this.mergeVertices()
              }
              function bc(t, e, n, r, i) {
                Kr.call(this),
                  (this.type = 'TorusBufferGeometry'),
                  (this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i,
                  }),
                  (t = t || 1),
                  (e = e || 0.4),
                  (n = Math.floor(n) || 8),
                  (r = Math.floor(r) || 6),
                  (i = i || 2 * Math.PI)
                for (
                  var a = [],
                    o = [],
                    s = [],
                    c = [],
                    l = new on(),
                    h = new on(),
                    u = new on(),
                    p = 0;
                  p <= n;
                  p++
                )
                  for (var d = 0; d <= r; d++) {
                    var f = (d / r) * i,
                      m = (p / n) * Math.PI * 2
                    ;(h.x = (t + e * Math.cos(m)) * Math.cos(f)),
                      (h.y = (t + e * Math.cos(m)) * Math.sin(f)),
                      (h.z = e * Math.sin(m)),
                      o.push(h.x, h.y, h.z),
                      (l.x = t * Math.cos(f)),
                      (l.y = t * Math.sin(f)),
                      u.subVectors(h, l).normalize(),
                      s.push(u.x, u.y, u.z),
                      c.push(d / r),
                      c.push(p / n)
                  }
                for (var v = 1; v <= n; v++)
                  for (var g = 1; g <= r; g++) {
                    var y = (r + 1) * v + g - 1,
                      x = (r + 1) * (v - 1) + g - 1,
                      b = (r + 1) * (v - 1) + g,
                      _ = (r + 1) * v + g
                    a.push(y, x, _), a.push(x, b, _)
                  }
                this.setIndex(a),
                  this.setAttribute('position', new Gr(o, 3)),
                  this.setAttribute('normal', new Gr(s, 3)),
                  this.setAttribute('uv', new Gr(c, 2))
              }
              ;(Js.prototype = Object.assign(Object.create(On.prototype), {
                constructor: Js,
                isPoints: !0,
                copy: function (t) {
                  return (
                    On.prototype.copy.call(this, t),
                    (this.material = t.material),
                    (this.geometry = t.geometry),
                    this
                  )
                },
                raycast: function (t, e) {
                  var n = this.geometry,
                    r = this.matrixWorld,
                    i = t.params.Points.threshold
                  if (
                    (null === n.boundingSphere && n.computeBoundingSphere(),
                    Ys.copy(n.boundingSphere),
                    Ys.applyMatrix4(r),
                    (Ys.radius += i),
                    !1 !== t.ray.intersectsSphere(Ys))
                  ) {
                    qs.getInverse(r), Xs.copy(t.ray).applyMatrix4(qs)
                    var a =
                        i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                      o = a * a
                    if (n.isBufferGeometry) {
                      var s = n.index,
                        c = n.attributes.position.array
                      if (null !== s)
                        for (var l = s.array, h = 0, u = l.length; h < u; h++) {
                          var p = l[h]
                          Zs.fromArray(c, 3 * p), Qs(Zs, p, o, r, t, e, this)
                        }
                      else
                        for (var d = 0, f = c.length / 3; d < f; d++)
                          Zs.fromArray(c, 3 * d), Qs(Zs, d, o, r, t, e, this)
                    } else
                      for (var m = n.vertices, v = 0, g = m.length; v < g; v++)
                        Qs(m[v], v, o, r, t, e, this)
                  }
                },
                updateMorphTargets: function () {
                  var t = this.geometry
                  if (t.isBufferGeometry) {
                    var e = t.morphAttributes,
                      n = Object.keys(e)
                    if (0 < n.length) {
                      var r = e[n[0]]
                      if (void 0 !== r) {
                        ;(this.morphTargetInfluences = []),
                          (this.morphTargetDictionary = {})
                        for (var i = 0, a = r.length; i < a; i++) {
                          var o = r[i].name || String(i)
                          this.morphTargetInfluences.push(0),
                            (this.morphTargetDictionary[o] = i)
                        }
                      }
                    }
                  } else {
                    var s = t.morphTargets
                    void 0 !== s &&
                      0 < s.length &&
                      console.error(
                        'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',
                      )
                  }
                },
              })),
                (Ks.prototype = Object.assign(Object.create(Ke.prototype), {
                  constructor: Ks,
                  isVideoTexture: !0,
                  update: function () {
                    var t = this.image
                    t.readyState >= t.HAVE_CURRENT_DATA &&
                      (this.needsUpdate = !0)
                  },
                })),
                ((($s.prototype = Object.create(Ke.prototype)).constructor =
                  $s).prototype.isCompressedTexture = !0),
                (((tc.prototype = Object.create(Ke.prototype)).constructor =
                  tc).prototype.isCanvasTexture = !0),
                (((ec.prototype = Object.create(Ke.prototype)).constructor =
                  ec).prototype.isDepthTexture = !0),
                ((nc.prototype = Object.create(Kr.prototype)).constructor = nc),
                ((rc.prototype = Object.create(Mi.prototype)).constructor = rc),
                ((ic.prototype = Object.create(Kr.prototype)).constructor = ic),
                ((ac.prototype = Object.create(Mi.prototype)).constructor = ac),
                ((oc.prototype = Object.create(Kr.prototype)).constructor = oc),
                ((sc.prototype = Object.create(Mi.prototype)).constructor = sc),
                ((cc.prototype = Object.create(oc.prototype)).constructor = cc),
                ((lc.prototype = Object.create(Mi.prototype)).constructor = lc),
                ((hc.prototype = Object.create(oc.prototype)).constructor = hc),
                ((uc.prototype = Object.create(Mi.prototype)).constructor = uc),
                ((pc.prototype = Object.create(oc.prototype)).constructor = pc),
                ((dc.prototype = Object.create(Mi.prototype)).constructor = dc),
                ((fc.prototype = Object.create(oc.prototype)).constructor = fc),
                ((mc.prototype = Object.create(Mi.prototype)).constructor = mc),
                (((vc.prototype = Object.create(Kr.prototype)).constructor =
                  vc).prototype.toJSON = function () {
                  var t = Kr.prototype.toJSON.call(this)
                  return (t.path = this.parameters.path.toJSON()), t
                }),
                ((gc.prototype = Object.create(Mi.prototype)).constructor = gc),
                ((yc.prototype = Object.create(Kr.prototype)).constructor = yc),
                ((xc.prototype = Object.create(Mi.prototype)).constructor = xc),
                ((bc.prototype = Object.create(Kr.prototype)).constructor = bc)
              var _c = function (t, e, n) {
                n = n || 2
                var r,
                  i,
                  a,
                  o,
                  s,
                  c,
                  l,
                  h = e && e.length,
                  u = h ? e[0] * n : t.length,
                  p = wc(t, 0, u, n, !0),
                  d = []
                if (!p || p.next === p.prev) return d
                if (
                  (h &&
                    (p = (function (t, e, n, r) {
                      var i,
                        a,
                        o,
                        s,
                        c,
                        l = []
                      for (i = 0, a = e.length; i < a; i++)
                        (o = e[i] * r),
                          (s = i < a - 1 ? e[i + 1] * r : t.length),
                          (c = wc(t, o, s, r, !1)) === c.next &&
                            (c.steiner = !0),
                          l.push(
                            (function (t) {
                              var e = t,
                                n = t
                              for (
                                ;
                                (e.x < n.x || (e.x === n.x && e.y < n.y)) &&
                                  (n = e),
                                  (e = e.next),
                                  e !== t;

                              );
                              return n
                            })(c),
                          )
                      for (l.sort(Ec), i = 0; i < l.length; i++)
                        !(function (t, e) {
                          {
                            var n
                            ;(e = (function (t, e) {
                              var n,
                                r = e,
                                i = t.x,
                                a = t.y,
                                o = -1 / 0
                              do {
                                if (
                                  a <= r.y &&
                                  a >= r.next.y &&
                                  r.next.y !== r.y
                                ) {
                                  var s =
                                    r.x +
                                    ((a - r.y) * (r.next.x - r.x)) /
                                      (r.next.y - r.y)
                                  if (s <= i && o < s) {
                                    if ((o = s) === i) {
                                      if (a === r.y) return r
                                      if (a === r.next.y) return r.next
                                    }
                                    n = r.x < r.next.x ? r : r.next
                                  }
                                }
                                r = r.next
                              } while (r !== e)
                              if (!n) return null
                              if (i === o) return n
                              var c,
                                l = n,
                                h = n.x,
                                u = n.y,
                                p = 1 / 0
                              r = n
                              for (
                                ;
                                i >= r.x &&
                                  r.x >= h &&
                                  i !== r.x &&
                                  Ac(
                                    a < u ? i : o,
                                    a,
                                    h,
                                    u,
                                    a < u ? o : i,
                                    a,
                                    r.x,
                                    r.y,
                                  ) &&
                                  ((c = Math.abs(a - r.y) / (i - r.x)),
                                  Ic(r, t) &&
                                    (c < p ||
                                      (c === p &&
                                        (r.x > n.x ||
                                          (r.x === n.x &&
                                            (function (t, e) {
                                              return (
                                                Lc(t.prev, t, e.prev) < 0 &&
                                                Lc(e.next, t, t.next) < 0
                                              )
                                            })(n, r))))) &&
                                    ((n = r), (p = c))),
                                  (r = r.next),
                                  r !== l;

                              );
                              return n
                            })(t, e)) &&
                              ((n = Dc(e, t)), Mc(e, e.next), Mc(n, n.next))
                          }
                        })(l[i], n),
                          (n = Mc(n, n.next))
                      return n
                    })(t, e, p, n)),
                  t.length > 80 * n)
                ) {
                  ;(r = a = t[0]), (i = o = t[1])
                  for (var f = n; f < u; f += n)
                    (s = t[f]) < r && (r = s),
                      (c = t[f + 1]) < i && (i = c),
                      a < s && (a = s),
                      o < c && (o = c)
                  l = 0 !== (l = Math.max(a - r, o - i)) ? 1 / l : 0
                }
                return Sc(p, d, n, r, i, l), d
              }
              function wc(t, e, n, r, i) {
                var a, o
                if (
                  i ===
                  0 <
                    (function (t, e, n, r) {
                      for (var i = 0, a = e, o = n - r; a < n; a += r)
                        (i += (t[o] - t[a]) * (t[a + 1] + t[o + 1])), (o = a)
                      return i
                    })(t, e, n, r)
                )
                  for (a = e; a < n; a += r) o = Bc(a, t[a], t[a + 1], o)
                else
                  for (a = n - r; e <= a; a -= r) o = Bc(a, t[a], t[a + 1], o)
                return o && Rc(o, o.next) && (Nc(o), (o = o.next)), o
              }
              function Mc(t, e) {
                if (!t) return t
                e = e || t
                var n,
                  r = t
                do {
                  if (
                    ((n = !1),
                    r.steiner ||
                      (!Rc(r, r.next) && 0 !== Lc(r.prev, r, r.next)))
                  )
                    r = r.next
                  else {
                    if ((Nc(r), (r = e = r.prev) === r.next)) break
                    n = !0
                  }
                } while (n || r !== e)
                return e
              }
              function Sc(t, e, n, r, i, a, o) {
                if (t) {
                  !o &&
                    a &&
                    (function (t, e, n, r) {
                      var i = t
                      for (
                        ;
                        null === i.z && (i.z = Tc(i.x, i.y, e, n, r)),
                          (i.prevZ = i.prev),
                          (i.nextZ = i.next),
                          (i = i.next),
                          i !== t;

                      );
                      ;(i.prevZ.nextZ = null),
                        (i.prevZ = null),
                        (function (t) {
                          var e,
                            n,
                            r,
                            i,
                            a,
                            o,
                            s,
                            c,
                            l = 1
                          do {
                            for (n = t, a = t = null, o = 0; n; ) {
                              for (
                                o++, r = n, e = s = 0;
                                e < l && (s++, (r = r.nextZ));
                                e++
                              );
                              for (c = l; 0 < s || (0 < c && r); )
                                0 !== s && (0 === c || !r || n.z <= r.z)
                                  ? ((n = (i = n).nextZ), s--)
                                  : ((r = (i = r).nextZ), c--),
                                  a ? (a.nextZ = i) : (t = i),
                                  (i.prevZ = a),
                                  (a = i)
                              n = r
                            }
                            ;(a.nextZ = null), (l *= 2)
                          } while (1 < o)
                        })(i)
                    })(t, r, i, a)
                  for (var s, c, l = t; t.prev !== t.next; )
                    if (
                      ((s = t.prev),
                      (c = t.next),
                      a
                        ? (function (t, e, n, r) {
                            var i = t.prev,
                              a = t,
                              o = t.next
                            if (0 <= Lc(i, a, o)) return !1
                            var s =
                                i.x < a.x
                                  ? i.x < o.x
                                    ? i.x
                                    : o.x
                                  : a.x < o.x
                                    ? a.x
                                    : o.x,
                              c =
                                i.y < a.y
                                  ? i.y < o.y
                                    ? i.y
                                    : o.y
                                  : a.y < o.y
                                    ? a.y
                                    : o.y,
                              l =
                                i.x > a.x
                                  ? i.x > o.x
                                    ? i.x
                                    : o.x
                                  : a.x > o.x
                                    ? a.x
                                    : o.x,
                              h =
                                i.y > a.y
                                  ? i.y > o.y
                                    ? i.y
                                    : o.y
                                  : a.y > o.y
                                    ? a.y
                                    : o.y,
                              u = Tc(s, c, e, n, r),
                              p = Tc(l, h, e, n, r),
                              d = t.prevZ,
                              f = t.nextZ
                            for (; d && d.z >= u && f && f.z <= p; ) {
                              if (
                                d !== t.prev &&
                                d !== t.next &&
                                Ac(i.x, i.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
                                0 <= Lc(d.prev, d, d.next)
                              )
                                return !1
                              if (
                                ((d = d.prevZ),
                                f !== t.prev &&
                                  f !== t.next &&
                                  Ac(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
                                  0 <= Lc(f.prev, f, f.next))
                              )
                                return !1
                              f = f.nextZ
                            }
                            for (; d && d.z >= u; ) {
                              if (
                                d !== t.prev &&
                                d !== t.next &&
                                Ac(i.x, i.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
                                0 <= Lc(d.prev, d, d.next)
                              )
                                return !1
                              d = d.prevZ
                            }
                            for (; f && f.z <= p; ) {
                              if (
                                f !== t.prev &&
                                f !== t.next &&
                                Ac(i.x, i.y, a.x, a.y, o.x, o.y, f.x, f.y) &&
                                0 <= Lc(f.prev, f, f.next)
                              )
                                return !1
                              f = f.nextZ
                            }
                            return !0
                          })(t, r, i, a)
                        : (function (t) {
                            var e = t.prev,
                              n = t,
                              r = t.next
                            if (0 <= Lc(e, n, r)) return !1
                            var i = t.next.next
                            for (; i !== t.prev; ) {
                              if (
                                Ac(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) &&
                                0 <= Lc(i.prev, i, i.next)
                              )
                                return !1
                              i = i.next
                            }
                            return !0
                          })(t))
                    )
                      e.push(s.i / n),
                        e.push(t.i / n),
                        e.push(c.i / n),
                        Nc(t),
                        (t = c.next),
                        (l = c.next)
                    else if ((t = c) === l) {
                      o
                        ? 1 === o
                          ? Sc(
                              (t = (function (t, e, n) {
                                var r = t
                                do {
                                  var i = r.prev,
                                    a = r.next.next
                                  !Rc(i, a) &&
                                    Cc(i, r, r.next, a) &&
                                    Ic(i, a) &&
                                    Ic(a, i) &&
                                    (e.push(i.i / n),
                                    e.push(r.i / n),
                                    e.push(a.i / n),
                                    Nc(r),
                                    Nc(r.next),
                                    (r = t = a)),
                                    (r = r.next)
                                } while (r !== t)
                                return Mc(r)
                              })(Mc(t), e, n)),
                              e,
                              n,
                              r,
                              i,
                              a,
                              2,
                            )
                          : 2 === o &&
                            (function (t, e, n, r, i, a) {
                              var o = t
                              do {
                                for (var s = o.next.next; s !== o.prev; ) {
                                  if (
                                    o.i !== s.i &&
                                    (function (t, e) {
                                      return (
                                        t.next.i !== e.i &&
                                        t.prev.i !== e.i &&
                                        !(function (t, e) {
                                          var n = t
                                          do {
                                            if (
                                              n.i !== t.i &&
                                              n.next.i !== t.i &&
                                              n.i !== e.i &&
                                              n.next.i !== e.i &&
                                              Cc(n, n.next, t, e)
                                            )
                                              return !0
                                            n = n.next
                                          } while (n !== t)
                                          return !1
                                        })(t, e) &&
                                        ((Ic(t, e) &&
                                          Ic(e, t) &&
                                          (function (t, e) {
                                            var n = t,
                                              r = !1,
                                              i = (t.x + e.x) / 2,
                                              a = (t.y + e.y) / 2
                                            for (
                                              ;
                                              n.y > a != n.next.y > a &&
                                                n.next.y !== n.y &&
                                                i <
                                                  ((n.next.x - n.x) *
                                                    (a - n.y)) /
                                                    (n.next.y - n.y) +
                                                    n.x &&
                                                (r = !r),
                                                (n = n.next),
                                                n !== t;

                                            );
                                            return r
                                          })(t, e) &&
                                          (Lc(t.prev, t, e.prev) ||
                                            Lc(t, e.prev, e))) ||
                                          (Rc(t, e) &&
                                            0 < Lc(t.prev, t, t.next) &&
                                            0 < Lc(e.prev, e, e.next)))
                                      )
                                    })(o, s)
                                  ) {
                                    var c = Dc(o, s)
                                    return (
                                      (o = Mc(o, o.next)),
                                      (c = Mc(c, c.next)),
                                      Sc(o, e, n, r, i, a),
                                      Sc(c, e, n, r, i, a)
                                    )
                                  }
                                  s = s.next
                                }
                                o = o.next
                              } while (o !== t)
                            })(t, e, n, r, i, a)
                        : Sc(Mc(t), e, n, r, i, a, 1)
                      break
                    }
                }
              }
              function Ec(t, e) {
                return t.x - e.x
              }
              function Tc(t, e, n, r, i) {
                return (
                  (t =
                    1431655765 &
                    ((t =
                      858993459 &
                      ((t =
                        252645135 &
                        ((t =
                          16711935 & ((t = 32767 * (t - n) * i) | (t << 8))) |
                          (t << 4))) |
                        (t << 2))) |
                      (t << 1))) |
                  ((e =
                    1431655765 &
                    ((e =
                      858993459 &
                      ((e =
                        252645135 &
                        ((e =
                          16711935 & ((e = 32767 * (e - r) * i) | (e << 8))) |
                          (e << 4))) |
                        (e << 2))) |
                      (e << 1))) <<
                    1)
                )
              }
              function Ac(t, e, n, r, i, a, o, s) {
                return (
                  0 <= (i - o) * (e - s) - (t - o) * (a - s) &&
                  0 <= (t - o) * (r - s) - (n - o) * (e - s) &&
                  0 <= (n - o) * (a - s) - (i - o) * (r - s)
                )
              }
              function Lc(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
              }
              function Rc(t, e) {
                return t.x === e.x && t.y === e.y
              }
              function Cc(t, e, n, r) {
                var i = Oc(Lc(t, e, n)),
                  a = Oc(Lc(t, e, r)),
                  o = Oc(Lc(n, r, t)),
                  s = Oc(Lc(n, r, e))
                return (
                  (i !== a && o !== s) ||
                  (0 === i && Pc(t, n, e)) ||
                  (0 === a && Pc(t, r, e)) ||
                  (0 === o && Pc(n, t, r)) ||
                  !(0 !== s || !Pc(n, e, r))
                )
              }
              function Pc(t, e, n) {
                return (
                  e.x <= Math.max(t.x, n.x) &&
                  e.x >= Math.min(t.x, n.x) &&
                  e.y <= Math.max(t.y, n.y) &&
                  e.y >= Math.min(t.y, n.y)
                )
              }
              function Oc(t) {
                return 0 < t ? 1 : t < 0 ? -1 : 0
              }
              function Ic(t, e) {
                return Lc(t.prev, t, t.next) < 0
                  ? 0 <= Lc(t, e, t.next) && 0 <= Lc(t, t.prev, e)
                  : Lc(t, e, t.prev) < 0 || Lc(t, t.next, e) < 0
              }
              function Dc(t, e) {
                var n = new Uc(t.i, t.x, t.y),
                  r = new Uc(e.i, e.x, e.y),
                  i = t.next,
                  a = e.prev
                return (
                  ((t.next = e).prev = t),
                  ((n.next = i).prev = n),
                  ((r.next = n).prev = r),
                  ((a.next = r).prev = a),
                  r
                )
              }
              function Bc(t, e, n, r) {
                var i = new Uc(t, e, n)
                return (
                  r
                    ? ((i.next = r.next),
                      ((i.prev = r).next.prev = i),
                      (r.next = i))
                    : ((i.prev = i).next = i),
                  i
                )
              }
              function Nc(t) {
                ;(t.next.prev = t.prev),
                  (t.prev.next = t.next),
                  t.prevZ && (t.prevZ.nextZ = t.nextZ),
                  t.nextZ && (t.nextZ.prevZ = t.prevZ)
              }
              function Uc(t, e, n) {
                ;(this.i = t),
                  (this.x = e),
                  (this.y = n),
                  (this.prev = null),
                  (this.next = null),
                  (this.z = null),
                  (this.prevZ = null),
                  (this.nextZ = null),
                  (this.steiner = !1)
              }
              var zc = {
                area: function (t) {
                  for (
                    var e = t.length, n = 0, r = e - 1, i = 0;
                    i < e;
                    r = i++
                  )
                    n += t[r].x * t[i].y - t[i].x * t[r].y
                  return 0.5 * n
                },
                isClockWise: function (t) {
                  return zc.area(t) < 0
                },
                triangulateShape: function (t, e) {
                  var n = [],
                    r = [],
                    i = []
                  Fc(t), Hc(n, t)
                  var a = t.length
                  e.forEach(Fc)
                  for (var o = 0; o < e.length; o++)
                    r.push(a), (a += e[o].length), Hc(n, e[o])
                  for (var s = _c(n, r), c = 0; c < s.length; c += 3)
                    i.push(s.slice(c, c + 3))
                  return i
                },
              }
              function Fc(t) {
                var e = t.length
                2 < e && t[e - 1].equals(t[0]) && t.pop()
              }
              function Hc(t, e) {
                for (var n = 0; n < e.length; n++)
                  t.push(e[n].x), t.push(e[n].y)
              }
              function Gc(t, e) {
                Mi.call(this),
                  (this.type = 'ExtrudeGeometry'),
                  (this.parameters = { shapes: t, options: e }),
                  this.fromBufferGeometry(new kc(t, e)),
                  this.mergeVertices()
              }
              function kc(t, Pt) {
                Kr.call(this),
                  (this.type = 'ExtrudeBufferGeometry'),
                  (this.parameters = { shapes: t, options: Pt }),
                  (t = Array.isArray(t) ? t : [t])
                for (
                  var Ot = this, It = [], Dt = [], e = 0, n = t.length;
                  e < n;
                  e++
                ) {
                  !(function (t) {
                    var r = [],
                      e = void 0 !== Pt.curveSegments ? Pt.curveSegments : 12,
                      h = void 0 !== Pt.steps ? Pt.steps : 1,
                      n = void 0 !== Pt.depth ? Pt.depth : 100,
                      u = void 0 === Pt.bevelEnabled || Pt.bevelEnabled,
                      i = void 0 !== Pt.bevelThickness ? Pt.bevelThickness : 6,
                      a = void 0 !== Pt.bevelSize ? Pt.bevelSize : i - 2,
                      o = void 0 !== Pt.bevelOffset ? Pt.bevelOffset : 0,
                      p = void 0 !== Pt.bevelSegments ? Pt.bevelSegments : 3,
                      s = Pt.extrudePath,
                      l = void 0 !== Pt.UVGenerator ? Pt.UVGenerator : Vc
                    void 0 !== Pt.amount &&
                      (console.warn(
                        'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.',
                      ),
                      (n = Pt.amount))
                    var c,
                      d,
                      f,
                      m,
                      v,
                      g = !1
                    s &&
                      ((c = s.getSpacedPoints(h)),
                      (u = !(g = !0)),
                      (d = s.computeFrenetFrames(h, !1)),
                      (f = new on()),
                      (m = new on()),
                      (v = new on()))
                    u || (o = a = i = p = 0)
                    var y = t.extractPoints(e),
                      x = y.shape,
                      b = y.holes
                    if (!zc.isClockWise(x)) {
                      x = x.reverse()
                      for (var _ = 0, w = b.length; _ < w; _++) {
                        var M = b[_]
                        zc.isClockWise(M) && (b[_] = M.reverse())
                      }
                    }
                    for (
                      var S = zc.triangulateShape(x, b),
                        E = x,
                        T = 0,
                        A = b.length;
                      T < A;
                      T++
                    ) {
                      var L = b[T]
                      x = x.concat(L)
                    }
                    function R(t, e, n) {
                      return (
                        e ||
                          console.error(
                            'THREE.ExtrudeGeometry: vec does not exist',
                          ),
                        e.clone().multiplyScalar(n).add(t)
                      )
                    }
                    var C = x.length,
                      P = S.length
                    function O(t, e, n) {
                      var r,
                        i = t.x - e.x,
                        a = t.y - e.y,
                        o = n.x - t.x,
                        s = n.y - t.y,
                        c = i * i + a * a,
                        l = i * s - a * o
                      if (Math.abs(l) > Number.EPSILON) {
                        var h,
                          u,
                          p = Math.sqrt(c),
                          d = Math.sqrt(o * o + s * s),
                          f = e.x - a / p,
                          m = e.y + i / p,
                          v =
                            ((n.x - s / d - f) * s - (n.y + o / d - m) * o) /
                            (i * s - a * o),
                          g =
                            (h = f + i * v - t.x) * h +
                            (u = m + a * v - t.y) * u
                        if (g <= 2) return new Ye(h, u)
                        r = Math.sqrt(g / 2)
                      } else {
                        var y = !1
                        i > Number.EPSILON
                          ? o > Number.EPSILON && (y = !0)
                          : i < -Number.EPSILON
                            ? o < -Number.EPSILON && (y = !0)
                            : Math.sign(a) === Math.sign(s) && (y = !0),
                          (r = y
                            ? ((h = -a), (u = i), Math.sqrt(c))
                            : ((h = i), (u = a), Math.sqrt(c / 2)))
                      }
                      return new Ye(h / r, u / r)
                    }
                    for (
                      var I = [], D = 0, B = E.length, N = B - 1, U = D + 1;
                      D < B;
                      D++, N++, U++
                    )
                      N === B && (N = 0),
                        U === B && (U = 0),
                        (I[D] = O(E[D], E[N], E[U]))
                    for (
                      var z, F = [], H = I.concat(), G = 0, k = b.length;
                      G < k;
                      G++
                    ) {
                      var V = b[G]
                      z = []
                      for (
                        var j = 0, W = V.length, q = W - 1, X = j + 1;
                        j < W;
                        j++, q++, X++
                      )
                        q === W && (q = 0),
                          X === W && (X = 0),
                          (z[j] = O(V[j], V[q], V[X]))
                      F.push(z), (H = H.concat(z))
                    }
                    for (var Y = 0; Y < p; Y++) {
                      for (
                        var Z = Y / p,
                          J = i * Math.cos((Z * Math.PI) / 2),
                          Q = a * Math.sin((Z * Math.PI) / 2) + o,
                          K = 0,
                          $ = E.length;
                        K < $;
                        K++
                      ) {
                        var tt = R(E[K], I[K], Q)
                        At(tt.x, tt.y, -J)
                      }
                      for (var et = 0, nt = b.length; et < nt; et++) {
                        var rt = b[et]
                        z = F[et]
                        for (var it = 0, at = rt.length; it < at; it++) {
                          var ot = R(rt[it], z[it], Q)
                          At(ot.x, ot.y, -J)
                        }
                      }
                    }
                    for (var st = a + o, ct = 0; ct < C; ct++) {
                      var lt = u ? R(x[ct], H[ct], st) : x[ct]
                      g
                        ? (m.copy(d.normals[0]).multiplyScalar(lt.x),
                          f.copy(d.binormals[0]).multiplyScalar(lt.y),
                          v.copy(c[0]).add(m).add(f),
                          At(v.x, v.y, v.z))
                        : At(lt.x, lt.y, 0)
                    }
                    for (var ht = 1; ht <= h; ht++)
                      for (var ut = 0; ut < C; ut++) {
                        var pt = u ? R(x[ut], H[ut], st) : x[ut]
                        g
                          ? (m.copy(d.normals[ht]).multiplyScalar(pt.x),
                            f.copy(d.binormals[ht]).multiplyScalar(pt.y),
                            v.copy(c[ht]).add(m).add(f),
                            At(v.x, v.y, v.z))
                          : At(pt.x, pt.y, (n / h) * ht)
                      }
                    for (var dt = p - 1; 0 <= dt; dt--) {
                      for (
                        var ft = dt / p,
                          mt = i * Math.cos((ft * Math.PI) / 2),
                          vt = a * Math.sin((ft * Math.PI) / 2) + o,
                          gt = 0,
                          yt = E.length;
                        gt < yt;
                        gt++
                      ) {
                        var xt = R(E[gt], I[gt], vt)
                        At(xt.x, xt.y, n + mt)
                      }
                      for (var bt = 0, _t = b.length; bt < _t; bt++) {
                        var wt = b[bt]
                        z = F[bt]
                        for (var Mt = 0, St = wt.length; Mt < St; Mt++) {
                          var Et = R(wt[Mt], z[Mt], vt)
                          g
                            ? At(Et.x, Et.y + c[h - 1].y, c[h - 1].x + mt)
                            : At(Et.x, Et.y, n + mt)
                        }
                      }
                    }
                    function Tt(t, e) {
                      for (var n = t.length; 0 <= --n; ) {
                        var r = n,
                          i = n - 1
                        i < 0 && (i = t.length - 1)
                        for (var a = 0, o = h + 2 * p; a < o; a++) {
                          var s = C * a,
                            c = C * (a + 1)
                          !(function (t, e, n, r) {
                            Rt(t), Rt(e), Rt(r), Rt(e), Rt(n), Rt(r)
                            var i = It.length / 3,
                              a = l.generateSideWallUV(
                                Ot,
                                It,
                                i - 6,
                                i - 3,
                                i - 2,
                                i - 1,
                              )
                            Ct(a[0]),
                              Ct(a[1]),
                              Ct(a[3]),
                              Ct(a[1]),
                              Ct(a[2]),
                              Ct(a[3])
                          })(e + r + s, e + i + s, e + i + c, e + r + c)
                        }
                      }
                    }
                    function At(t, e, n) {
                      r.push(t), r.push(e), r.push(n)
                    }
                    function Lt(t, e, n) {
                      Rt(t), Rt(e), Rt(n)
                      var r = It.length / 3,
                        i = l.generateTopUV(Ot, It, r - 3, r - 2, r - 1)
                      Ct(i[0]), Ct(i[1]), Ct(i[2])
                    }
                    function Rt(t) {
                      It.push(r[3 * t + 0]),
                        It.push(r[3 * t + 1]),
                        It.push(r[3 * t + 2])
                    }
                    function Ct(t) {
                      Dt.push(t.x), Dt.push(t.y)
                    }
                    ;(function () {
                      var t = It.length / 3
                      if (u) {
                        for (var e = 0 * C, n = 0; n < P; n++) {
                          var r = S[n]
                          Lt(r[2] + e, r[1] + e, r[0] + e)
                        }
                        e = C * (h + 2 * p)
                        for (var i = 0; i < P; i++) {
                          var a = S[i]
                          Lt(a[0] + e, a[1] + e, a[2] + e)
                        }
                      } else {
                        for (var o = 0; o < P; o++) {
                          var s = S[o]
                          Lt(s[2], s[1], s[0])
                        }
                        for (var c = 0; c < P; c++) {
                          var l = S[c]
                          Lt(l[0] + C * h, l[1] + C * h, l[2] + C * h)
                        }
                      }
                      Ot.addGroup(t, It.length / 3 - t, 0)
                    })(),
                      (function () {
                        var t = It.length / 3,
                          e = 0
                        Tt(E, e), (e += E.length)
                        for (var n = 0, r = b.length; n < r; n++) {
                          var i = b[n]
                          Tt(i, e), (e += i.length)
                        }
                        Ot.addGroup(t, It.length / 3 - t, 1)
                      })()
                  })(t[e])
                }
                this.setAttribute('position', new Gr(It, 3)),
                  this.setAttribute('uv', new Gr(Dt, 2)),
                  this.computeVertexNormals()
              }
              ;(((Gc.prototype = Object.create(Mi.prototype)).constructor =
                Gc).prototype.toJSON = function () {
                var t = Mi.prototype.toJSON.call(this)
                return jc(this.parameters.shapes, this.parameters.options, t)
              }),
                (((kc.prototype = Object.create(Kr.prototype)).constructor =
                  kc).prototype.toJSON = function () {
                  var t = Kr.prototype.toJSON.call(this)
                  return jc(this.parameters.shapes, this.parameters.options, t)
                })
              var Vc = {
                generateTopUV: function (t, e, n, r, i) {
                  var a = e[3 * n],
                    o = e[3 * n + 1],
                    s = e[3 * r],
                    c = e[3 * r + 1],
                    l = e[3 * i],
                    h = e[3 * i + 1]
                  return [new Ye(a, o), new Ye(s, c), new Ye(l, h)]
                },
                generateSideWallUV: function (t, e, n, r, i, a) {
                  var o = e[3 * n],
                    s = e[3 * n + 1],
                    c = e[3 * n + 2],
                    l = e[3 * r],
                    h = e[3 * r + 1],
                    u = e[3 * r + 2],
                    p = e[3 * i],
                    d = e[3 * i + 1],
                    f = e[3 * i + 2],
                    m = e[3 * a],
                    v = e[3 * a + 1],
                    g = e[3 * a + 2]
                  return Math.abs(s - h) < 0.01
                    ? [
                        new Ye(o, 1 - c),
                        new Ye(l, 1 - u),
                        new Ye(p, 1 - f),
                        new Ye(m, 1 - g),
                      ]
                    : [
                        new Ye(s, 1 - c),
                        new Ye(h, 1 - u),
                        new Ye(d, 1 - f),
                        new Ye(v, 1 - g),
                      ]
                },
              }
              function jc(t, e, n) {
                if (((n.shapes = []), Array.isArray(t)))
                  for (var r = 0, i = t.length; r < i; r++) {
                    var a = t[r]
                    n.shapes.push(a.uuid)
                  }
                else n.shapes.push(t.uuid)
                return (
                  void 0 !== e.extrudePath &&
                    (n.options.extrudePath = e.extrudePath.toJSON()),
                  n
                )
              }
              function Wc(t, e) {
                Mi.call(this),
                  (this.type = 'TextGeometry'),
                  (this.parameters = { text: t, parameters: e }),
                  this.fromBufferGeometry(new qc(t, e)),
                  this.mergeVertices()
              }
              function qc(t, e) {
                var n = (e = e || {}).font
                if (!n || !n.isFont)
                  return (
                    console.error(
                      'THREE.TextGeometry: font parameter is not an instance of THREE.Font.',
                    ),
                    new Mi()
                  )
                var r = n.generateShapes(t, e.size)
                ;(e.depth = void 0 !== e.height ? e.height : 50),
                  void 0 === e.bevelThickness && (e.bevelThickness = 10),
                  void 0 === e.bevelSize && (e.bevelSize = 8),
                  void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
                  kc.call(this, r, e),
                  (this.type = 'TextBufferGeometry')
              }
              function Xc(t, e, n, r, i, a, o) {
                Mi.call(this),
                  (this.type = 'SphereGeometry'),
                  (this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: a,
                    thetaLength: o,
                  }),
                  this.fromBufferGeometry(new Yc(t, e, n, r, i, a, o)),
                  this.mergeVertices()
              }
              function Yc(t, e, n, r, i, a, o) {
                Kr.call(this),
                  (this.type = 'SphereBufferGeometry'),
                  (this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: a,
                    thetaLength: o,
                  }),
                  (t = t || 1),
                  (e = Math.max(3, Math.floor(e) || 8)),
                  (n = Math.max(2, Math.floor(n) || 6)),
                  (r = void 0 !== r ? r : 0),
                  (i = void 0 !== i ? i : 2 * Math.PI),
                  (a = void 0 !== a ? a : 0),
                  (o = void 0 !== o ? o : Math.PI)
                for (
                  var s = Math.min(a + o, Math.PI),
                    c = 0,
                    l = [],
                    h = new on(),
                    u = new on(),
                    p = [],
                    d = [],
                    f = [],
                    m = [],
                    v = 0;
                  v <= n;
                  v++
                ) {
                  var g = [],
                    y = v / n,
                    x = 0
                  0 == v && 0 == a
                    ? (x = 0.5 / e)
                    : v == n && s == Math.PI && (x = -0.5 / e)
                  for (var b = 0; b <= e; b++) {
                    var _ = b / e
                    ;(h.x = -t * Math.cos(r + _ * i) * Math.sin(a + y * o)),
                      (h.y = t * Math.cos(a + y * o)),
                      (h.z = t * Math.sin(r + _ * i) * Math.sin(a + y * o)),
                      d.push(h.x, h.y, h.z),
                      u.copy(h).normalize(),
                      f.push(u.x, u.y, u.z),
                      m.push(_ + x, 1 - y),
                      g.push(c++)
                  }
                  l.push(g)
                }
                for (var w = 0; w < n; w++)
                  for (var M = 0; M < e; M++) {
                    var S = l[w][M + 1],
                      E = l[w][M],
                      T = l[w + 1][M],
                      A = l[w + 1][M + 1]
                    ;(0 !== w || 0 < a) && p.push(S, E, A),
                      (w !== n - 1 || s < Math.PI) && p.push(E, T, A)
                  }
                this.setIndex(p),
                  this.setAttribute('position', new Gr(d, 3)),
                  this.setAttribute('normal', new Gr(f, 3)),
                  this.setAttribute('uv', new Gr(m, 2))
              }
              function Zc(t, e, n, r, i, a) {
                Mi.call(this),
                  (this.type = 'RingGeometry'),
                  (this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: a,
                  }),
                  this.fromBufferGeometry(new Jc(t, e, n, r, i, a)),
                  this.mergeVertices()
              }
              function Jc(t, e, n, r, i, a) {
                Kr.call(this),
                  (this.type = 'RingBufferGeometry'),
                  (this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: a,
                  }),
                  (t = t || 0.5),
                  (e = e || 1),
                  (i = void 0 !== i ? i : 0),
                  (a = void 0 !== a ? a : 2 * Math.PI),
                  (n = void 0 !== n ? Math.max(3, n) : 8)
                for (
                  var o = [],
                    s = [],
                    c = [],
                    l = [],
                    h = t,
                    u = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1),
                    p = new on(),
                    d = new Ye(),
                    f = 0;
                  f <= r;
                  f++
                ) {
                  for (var m = 0; m <= n; m++) {
                    var v = i + (m / n) * a
                    ;(p.x = h * Math.cos(v)),
                      (p.y = h * Math.sin(v)),
                      s.push(p.x, p.y, p.z),
                      c.push(0, 0, 1),
                      (d.x = (p.x / e + 1) / 2),
                      (d.y = (p.y / e + 1) / 2),
                      l.push(d.x, d.y)
                  }
                  h += u
                }
                for (var g = 0; g < r; g++)
                  for (var y = g * (n + 1), x = 0; x < n; x++) {
                    var b = x + y,
                      _ = b + n + 1,
                      w = b + n + 2,
                      M = b + 1
                    o.push(b, _, M), o.push(_, w, M)
                  }
                this.setIndex(o),
                  this.setAttribute('position', new Gr(s, 3)),
                  this.setAttribute('normal', new Gr(c, 3)),
                  this.setAttribute('uv', new Gr(l, 2))
              }
              function Qc(t, e, n, r) {
                Mi.call(this),
                  (this.type = 'LatheGeometry'),
                  (this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: r,
                  }),
                  this.fromBufferGeometry(new Kc(t, e, n, r)),
                  this.mergeVertices()
              }
              function Kc(t, e, n, r) {
                Kr.call(this),
                  (this.type = 'LatheBufferGeometry'),
                  (this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: r,
                  }),
                  (e = Math.floor(e) || 12),
                  (n = n || 0),
                  (r = r || 2 * Math.PI),
                  (r = Xe.clamp(r, 0, 2 * Math.PI))
                for (
                  var i = [],
                    a = [],
                    o = [],
                    s = 1 / e,
                    c = new on(),
                    l = new Ye(),
                    h = 0;
                  h <= e;
                  h++
                )
                  for (
                    var u = n + h * s * r,
                      p = Math.sin(u),
                      d = Math.cos(u),
                      f = 0;
                    f <= t.length - 1;
                    f++
                  )
                    (c.x = t[f].x * p),
                      (c.y = t[f].y),
                      (c.z = t[f].x * d),
                      a.push(c.x, c.y, c.z),
                      (l.x = h / e),
                      (l.y = f / (t.length - 1)),
                      o.push(l.x, l.y)
                for (var m = 0; m < e; m++)
                  for (var v = 0; v < t.length - 1; v++) {
                    var g = v + m * t.length,
                      y = g + t.length,
                      x = g + t.length + 1,
                      b = g + 1
                    i.push(g, y, b), i.push(y, x, b)
                  }
                if (
                  (this.setIndex(i),
                  this.setAttribute('position', new Gr(a, 3)),
                  this.setAttribute('uv', new Gr(o, 2)),
                  this.computeVertexNormals(),
                  r === 2 * Math.PI)
                )
                  for (
                    var _ = this.attributes.normal.array,
                      w = new on(),
                      M = new on(),
                      S = new on(),
                      E = e * t.length * 3,
                      T = 0,
                      A = 0;
                    T < t.length;
                    T++, A += 3
                  )
                    (w.x = _[A + 0]),
                      (w.y = _[A + 1]),
                      (w.z = _[A + 2]),
                      (M.x = _[E + A + 0]),
                      (M.y = _[E + A + 1]),
                      (M.z = _[E + A + 2]),
                      S.addVectors(w, M).normalize(),
                      (_[A + 0] = _[E + A + 0] = S.x),
                      (_[A + 1] = _[E + A + 1] = S.y),
                      (_[A + 2] = _[E + A + 2] = S.z)
              }
              function $c(t, e) {
                Mi.call(this),
                  (this.type = 'ShapeGeometry'),
                  'object' == typeof e &&
                    (console.warn(
                      'THREE.ShapeGeometry: Options parameter has been removed.',
                    ),
                    (e = e.curveSegments)),
                  (this.parameters = { shapes: t, curveSegments: e }),
                  this.fromBufferGeometry(new tl(t, e)),
                  this.mergeVertices()
              }
              function tl(t, _) {
                Kr.call(this),
                  (this.type = 'ShapeBufferGeometry'),
                  (this.parameters = { shapes: t, curveSegments: _ }),
                  (_ = _ || 12)
                var w = [],
                  M = [],
                  S = [],
                  E = [],
                  e = 0,
                  T = 0
                if (!1 === Array.isArray(t)) r(t)
                else
                  for (var n = 0; n < t.length; n++)
                    r(t[n]), this.addGroup(e, T, n), (e += T), (T = 0)
                function r(t) {
                  var e = M.length / 3,
                    n = t.extractPoints(_),
                    r = n.shape,
                    i = n.holes
                  !1 === zc.isClockWise(r) && (r = r.reverse())
                  for (var a = 0, o = i.length; a < o; a++) {
                    var s = i[a]
                    !0 === zc.isClockWise(s) && (i[a] = s.reverse())
                  }
                  for (
                    var c = zc.triangulateShape(r, i), l = 0, h = i.length;
                    l < h;
                    l++
                  )
                    var u = i[l], r = r.concat(u)
                  for (var p = 0, d = r.length; p < d; p++) {
                    var f = r[p]
                    M.push(f.x, f.y, 0), S.push(0, 0, 1), E.push(f.x, f.y)
                  }
                  for (var m = 0, v = c.length; m < v; m++) {
                    var g = c[m],
                      y = g[0] + e,
                      x = g[1] + e,
                      b = g[2] + e
                    w.push(y, x, b), (T += 3)
                  }
                }
                this.setIndex(w),
                  this.setAttribute('position', new Gr(M, 3)),
                  this.setAttribute('normal', new Gr(S, 3)),
                  this.setAttribute('uv', new Gr(E, 2))
              }
              function el(t, e) {
                if (((e.shapes = []), Array.isArray(t)))
                  for (var n = 0, r = t.length; n < r; n++) {
                    var i = t[n]
                    e.shapes.push(i.uuid)
                  }
                else e.shapes.push(t.uuid)
                return e
              }
              function nl(t, e) {
                Kr.call(this),
                  (this.type = 'EdgesGeometry'),
                  (this.parameters = { thresholdAngle: e }),
                  (e = void 0 !== e ? e : 1)
                var n,
                  r,
                  i,
                  a,
                  o = [],
                  s = Math.cos(Xe.DEG2RAD * e),
                  c = [0, 0],
                  l = {},
                  h = ['a', 'b', 'c']
                t.isBufferGeometry
                  ? (a = new Mi()).fromBufferGeometry(t)
                  : (a = t.clone()),
                  a.mergeVertices(),
                  a.computeFaceNormals()
                for (
                  var u = a.vertices, p = a.faces, d = 0, f = p.length;
                  d < f;
                  d++
                )
                  for (var m = p[d], v = 0; v < 3; v++)
                    (n = m[h[v]]),
                      (r = m[h[(v + 1) % 3]]),
                      (c[0] = Math.min(n, r)),
                      (c[1] = Math.max(n, r)),
                      void 0 === l[(i = c[0] + ',' + c[1])]
                        ? (l[i] = {
                            index1: c[0],
                            index2: c[1],
                            face1: d,
                            face2: void 0,
                          })
                        : (l[i].face2 = d)
                for (i in l) {
                  var g,
                    y = l[i]
                  ;(void 0 === y.face2 ||
                    p[y.face1].normal.dot(p[y.face2].normal) <= s) &&
                    ((g = u[y.index1]),
                    o.push(g.x, g.y, g.z),
                    (g = u[y.index2]),
                    o.push(g.x, g.y, g.z))
                }
                this.setAttribute('position', new Gr(o, 3))
              }
              function rl(t, e, n, r, i, a, o, s) {
                Mi.call(this),
                  (this.type = 'CylinderGeometry'),
                  (this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: r,
                    heightSegments: i,
                    openEnded: a,
                    thetaStart: o,
                    thetaLength: s,
                  }),
                  this.fromBufferGeometry(new il(t, e, n, r, i, a, o, s)),
                  this.mergeVertices()
              }
              function il(x, b, _, w, M, t, S, E) {
                Kr.call(this),
                  (this.type = 'CylinderBufferGeometry'),
                  (this.parameters = {
                    radiusTop: x,
                    radiusBottom: b,
                    height: _,
                    radialSegments: w,
                    heightSegments: M,
                    openEnded: t,
                    thetaStart: S,
                    thetaLength: E,
                  })
                var T = this
                ;(x = void 0 !== x ? x : 1),
                  (b = void 0 !== b ? b : 1),
                  (_ = _ || 1),
                  (w = Math.floor(w) || 8),
                  (M = Math.floor(M) || 1),
                  (t = void 0 !== t && t),
                  (S = void 0 !== S ? S : 0),
                  (E = void 0 !== E ? E : 2 * Math.PI)
                var A = [],
                  L = [],
                  R = [],
                  C = [],
                  P = 0,
                  O = [],
                  I = _ / 2,
                  D = 0
                function e(t) {
                  for (
                    var e,
                      n = new Ye(),
                      r = new on(),
                      i = 0,
                      a = !0 === t ? x : b,
                      o = !0 === t ? 1 : -1,
                      s = P,
                      c = 1;
                    c <= w;
                    c++
                  )
                    L.push(0, I * o, 0), R.push(0, o, 0), C.push(0.5, 0.5), P++
                  e = P
                  for (var l = 0; l <= w; l++) {
                    var h = (l / w) * E + S,
                      u = Math.cos(h),
                      p = Math.sin(h)
                    ;(r.x = a * p),
                      (r.y = I * o),
                      (r.z = a * u),
                      L.push(r.x, r.y, r.z),
                      R.push(0, o, 0),
                      (n.x = 0.5 * u + 0.5),
                      (n.y = 0.5 * p * o + 0.5),
                      C.push(n.x, n.y),
                      P++
                  }
                  for (var d = 0; d < w; d++) {
                    var f = s + d,
                      m = e + d
                    !0 === t ? A.push(m, m + 1, f) : A.push(m + 1, m, f),
                      (i += 3)
                  }
                  T.addGroup(D, i, !0 === t ? 1 : 2), (D += i)
                }
                !(function () {
                  for (
                    var t = new on(),
                      e = new on(),
                      n = 0,
                      r = (b - x) / _,
                      i = 0;
                    i <= M;
                    i++
                  ) {
                    for (
                      var a = [], o = i / M, s = o * (b - x) + x, c = 0;
                      c <= w;
                      c++
                    ) {
                      var l = c / w,
                        h = l * E + S,
                        u = Math.sin(h),
                        p = Math.cos(h)
                      ;(e.x = s * u),
                        (e.y = -o * _ + I),
                        (e.z = s * p),
                        L.push(e.x, e.y, e.z),
                        t.set(u, r, p).normalize(),
                        R.push(t.x, t.y, t.z),
                        C.push(l, 1 - o),
                        a.push(P++)
                    }
                    O.push(a)
                  }
                  for (var d = 0; d < w; d++)
                    for (var f = 0; f < M; f++) {
                      var m = O[f][d],
                        v = O[f + 1][d],
                        g = O[f + 1][d + 1],
                        y = O[f][d + 1]
                      A.push(m, v, y), A.push(v, g, y), (n += 6)
                    }
                  T.addGroup(D, n, 0), (D += n)
                })(),
                  !1 === t && (0 < x && e(!0), 0 < b && e(!1)),
                  this.setIndex(A),
                  this.setAttribute('position', new Gr(L, 3)),
                  this.setAttribute('normal', new Gr(R, 3)),
                  this.setAttribute('uv', new Gr(C, 2))
              }
              function al(t, e, n, r, i, a, o) {
                rl.call(this, 0, t, e, n, r, i, a, o),
                  (this.type = 'ConeGeometry'),
                  (this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: a,
                    thetaLength: o,
                  })
              }
              function ol(t, e, n, r, i, a, o) {
                il.call(this, 0, t, e, n, r, i, a, o),
                  (this.type = 'ConeBufferGeometry'),
                  (this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: a,
                    thetaLength: o,
                  })
              }
              function sl(t, e, n, r) {
                Mi.call(this),
                  (this.type = 'CircleGeometry'),
                  (this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: r,
                  }),
                  this.fromBufferGeometry(new cl(t, e, n, r)),
                  this.mergeVertices()
              }
              function cl(t, e, n, r) {
                Kr.call(this),
                  (this.type = 'CircleBufferGeometry'),
                  (this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: r,
                  }),
                  (t = t || 1),
                  (e = void 0 !== e ? Math.max(3, e) : 8),
                  (n = void 0 !== n ? n : 0),
                  (r = void 0 !== r ? r : 2 * Math.PI)
                var i = [],
                  a = [],
                  o = [],
                  s = [],
                  c = new on(),
                  l = new Ye()
                a.push(0, 0, 0), o.push(0, 0, 1), s.push(0.5, 0.5)
                for (var h = 0, u = 3; h <= e; h++, u += 3) {
                  var p = n + (h / e) * r
                  ;(c.x = t * Math.cos(p)),
                    (c.y = t * Math.sin(p)),
                    a.push(c.x, c.y, c.z),
                    o.push(0, 0, 1),
                    (l.x = (a[u] / t + 1) / 2),
                    (l.y = (a[u + 1] / t + 1) / 2),
                    s.push(l.x, l.y)
                }
                for (var d = 1; d <= e; d++) i.push(d, d + 1, 0)
                this.setIndex(i),
                  this.setAttribute('position', new Gr(a, 3)),
                  this.setAttribute('normal', new Gr(o, 3)),
                  this.setAttribute('uv', new Gr(s, 2))
              }
              ;((Wc.prototype = Object.create(Mi.prototype)).constructor = Wc),
                ((qc.prototype = Object.create(kc.prototype)).constructor = qc),
                ((Xc.prototype = Object.create(Mi.prototype)).constructor = Xc),
                ((Yc.prototype = Object.create(Kr.prototype)).constructor = Yc),
                ((Zc.prototype = Object.create(Mi.prototype)).constructor = Zc),
                ((Jc.prototype = Object.create(Kr.prototype)).constructor = Jc),
                ((Qc.prototype = Object.create(Mi.prototype)).constructor = Qc),
                ((Kc.prototype = Object.create(Kr.prototype)).constructor = Kc),
                ((($c.prototype = Object.create(Mi.prototype)).constructor =
                  $c).prototype.toJSON = function () {
                  var t = Mi.prototype.toJSON.call(this)
                  return el(this.parameters.shapes, t)
                }),
                (((tl.prototype = Object.create(Kr.prototype)).constructor =
                  tl).prototype.toJSON = function () {
                  var t = Kr.prototype.toJSON.call(this)
                  return el(this.parameters.shapes, t)
                }),
                ((nl.prototype = Object.create(Kr.prototype)).constructor = nl),
                ((rl.prototype = Object.create(Mi.prototype)).constructor = rl),
                ((il.prototype = Object.create(Kr.prototype)).constructor = il),
                ((al.prototype = Object.create(rl.prototype)).constructor = al),
                ((ol.prototype = Object.create(il.prototype)).constructor = ol),
                ((sl.prototype = Object.create(Mi.prototype)).constructor = sl),
                ((cl.prototype = Object.create(Kr.prototype)).constructor = cl)
              var ll = Object.freeze({
                __proto__: null,
                WireframeGeometry: nc,
                ParametricGeometry: rc,
                ParametricBufferGeometry: ic,
                TetrahedronGeometry: sc,
                TetrahedronBufferGeometry: cc,
                OctahedronGeometry: lc,
                OctahedronBufferGeometry: hc,
                IcosahedronGeometry: uc,
                IcosahedronBufferGeometry: pc,
                DodecahedronGeometry: dc,
                DodecahedronBufferGeometry: fc,
                PolyhedronGeometry: ac,
                PolyhedronBufferGeometry: oc,
                TubeGeometry: mc,
                TubeBufferGeometry: vc,
                TorusKnotGeometry: gc,
                TorusKnotBufferGeometry: yc,
                TorusGeometry: xc,
                TorusBufferGeometry: bc,
                TextGeometry: Wc,
                TextBufferGeometry: qc,
                SphereGeometry: Xc,
                SphereBufferGeometry: Yc,
                RingGeometry: Zc,
                RingBufferGeometry: Jc,
                PlaneGeometry: Vi,
                PlaneBufferGeometry: ji,
                LatheGeometry: Qc,
                LatheBufferGeometry: Kc,
                ShapeGeometry: $c,
                ShapeBufferGeometry: tl,
                ExtrudeGeometry: Gc,
                ExtrudeBufferGeometry: kc,
                EdgesGeometry: nl,
                ConeGeometry: al,
                ConeBufferGeometry: ol,
                CylinderGeometry: rl,
                CylinderBufferGeometry: il,
                CircleGeometry: sl,
                CircleBufferGeometry: cl,
                BoxGeometry: Si,
                BoxBufferGeometry: Ei,
              })
              function hl(t) {
                Rr.call(this),
                  (this.type = 'ShadowMaterial'),
                  (this.color = new Mr(0)),
                  (this.transparent = !0),
                  this.setValues(t)
              }
              function ul(t) {
                Pi.call(this, t), (this.type = 'RawShaderMaterial')
              }
              function pl(t) {
                Rr.call(this),
                  (this.defines = { STANDARD: '' }),
                  (this.type = 'MeshStandardMaterial'),
                  (this.color = new Mr(16777215)),
                  (this.roughness = 1),
                  (this.metalness = 0),
                  (this.map = null),
                  (this.lightMap = null),
                  (this.lightMapIntensity = 1),
                  (this.aoMap = null),
                  (this.aoMapIntensity = 1),
                  (this.emissive = new Mr(0)),
                  (this.emissiveIntensity = 1),
                  (this.emissiveMap = null),
                  (this.bumpMap = null),
                  (this.bumpScale = 1),
                  (this.normalMap = null),
                  (this.normalMapType = Ue),
                  (this.normalScale = new Ye(1, 1)),
                  (this.displacementMap = null),
                  (this.displacementScale = 1),
                  (this.displacementBias = 0),
                  (this.roughnessMap = null),
                  (this.metalnessMap = null),
                  (this.alphaMap = null),
                  (this.envMap = null),
                  (this.envMapIntensity = 1),
                  (this.refractionRatio = 0.98),
                  (this.wireframe = !1),
                  (this.wireframeLinewidth = 1),
                  (this.wireframeLinecap = 'round'),
                  (this.wireframeLinejoin = 'round'),
                  (this.skinning = !1),
                  (this.morphTargets = !1),
                  (this.morphNormals = !1),
                  (this.vertexTangents = !1),
                  this.setValues(t)
              }
              function dl(t) {
                pl.call(this),
                  (this.defines = { STANDARD: '', PHYSICAL: '' }),
                  (this.type = 'MeshPhysicalMaterial'),
                  (this.clearcoat = 0),
                  (this.clearcoatMap = null),
                  (this.clearcoatRoughness = 0),
                  (this.clearcoatRoughnessMap = null),
                  (this.clearcoatNormalScale = new Ye(1, 1)),
                  (this.clearcoatNormalMap = null),
                  (this.reflectivity = 0.5),
                  (this.sheen = null),
                  (this.transparency = 0),
                  this.setValues(t)
              }
              function fl(t) {
                Rr.call(this),
                  (this.type = 'MeshPhongMaterial'),
                  (this.color = new Mr(16777215)),
                  (this.specular = new Mr(1118481)),
                  (this.shininess = 30),
                  (this.map = null),
                  (this.lightMap = null),
                  (this.lightMapIntensity = 1),
                  (this.aoMap = null),
                  (this.aoMapIntensity = 1),
                  (this.emissive = new Mr(0)),
                  (this.emissiveIntensity = 1),
                  (this.emissiveMap = null),
                  (this.bumpMap = null),
                  (this.bumpScale = 1),
                  (this.normalMap = null),
                  (this.normalMapType = Ue),
                  (this.normalScale = new Ye(1, 1)),
                  (this.displacementMap = null),
                  (this.displacementScale = 1),
                  (this.displacementBias = 0),
                  (this.specularMap = null),
                  (this.alphaMap = null),
                  (this.envMap = null),
                  (this.combine = G),
                  (this.reflectivity = 1),
                  (this.refractionRatio = 0.98),
                  (this.wireframe = !1),
                  (this.wireframeLinewidth = 1),
                  (this.wireframeLinecap = 'round'),
                  (this.wireframeLinejoin = 'round'),
                  (this.skinning = !1),
                  (this.morphTargets = !1),
                  (this.morphNormals = !1),
                  this.setValues(t)
              }
              function ml(t) {
                Rr.call(this),
                  (this.defines = { TOON: '' }),
                  (this.type = 'MeshToonMaterial'),
                  (this.color = new Mr(16777215)),
                  (this.map = null),
                  (this.gradientMap = null),
                  (this.lightMap = null),
                  (this.lightMapIntensity = 1),
                  (this.aoMap = null),
                  (this.aoMapIntensity = 1),
                  (this.emissive = new Mr(0)),
                  (this.emissiveIntensity = 1),
                  (this.emissiveMap = null),
                  (this.bumpMap = null),
                  (this.bumpScale = 1),
                  (this.normalMap = null),
                  (this.normalMapType = Ue),
                  (this.normalScale = new Ye(1, 1)),
                  (this.displacementMap = null),
                  (this.displacementScale = 1),
                  (this.displacementBias = 0),
                  (this.alphaMap = null),
                  (this.wireframe = !1),
                  (this.wireframeLinewidth = 1),
                  (this.wireframeLinecap = 'round'),
                  (this.wireframeLinejoin = 'round'),
                  (this.skinning = !1),
                  (this.morphTargets = !1),
                  (this.morphNormals = !1),
                  this.setValues(t)
              }
              function vl(t) {
                Rr.call(this),
                  (this.type = 'MeshNormalMaterial'),
                  (this.bumpMap = null),
                  (this.bumpScale = 1),
                  (this.normalMap = null),
                  (this.normalMapType = Ue),
                  (this.normalScale = new Ye(1, 1)),
                  (this.displacementMap = null),
                  (this.displacementScale = 1),
                  (this.displacementBias = 0),
                  (this.wireframe = !1),
                  (this.wireframeLinewidth = 1),
                  (this.fog = !1),
                  (this.skinning = !1),
                  (this.morphTargets = !1),
                  (this.morphNormals = !1),
                  this.setValues(t)
              }
              function gl(t) {
                Rr.call(this),
                  (this.type = 'MeshLambertMaterial'),
                  (this.color = new Mr(16777215)),
                  (this.map = null),
                  (this.lightMap = null),
                  (this.lightMapIntensity = 1),
                  (this.aoMap = null),
                  (this.aoMapIntensity = 1),
                  (this.emissive = new Mr(0)),
                  (this.emissiveIntensity = 1),
                  (this.emissiveMap = null),
                  (this.specularMap = null),
                  (this.alphaMap = null),
                  (this.envMap = null),
                  (this.combine = G),
                  (this.reflectivity = 1),
                  (this.refractionRatio = 0.98),
                  (this.wireframe = !1),
                  (this.wireframeLinewidth = 1),
                  (this.wireframeLinecap = 'round'),
                  (this.wireframeLinejoin = 'round'),
                  (this.skinning = !1),
                  (this.morphTargets = !1),
                  (this.morphNormals = !1),
                  this.setValues(t)
              }
              function yl(t) {
                Rr.call(this),
                  (this.defines = { MATCAP: '' }),
                  (this.type = 'MeshMatcapMaterial'),
                  (this.color = new Mr(16777215)),
                  (this.matcap = null),
                  (this.map = null),
                  (this.bumpMap = null),
                  (this.bumpScale = 1),
                  (this.normalMap = null),
                  (this.normalMapType = Ue),
                  (this.normalScale = new Ye(1, 1)),
                  (this.displacementMap = null),
                  (this.displacementScale = 1),
                  (this.displacementBias = 0),
                  (this.alphaMap = null),
                  (this.skinning = !1),
                  (this.morphTargets = !1),
                  (this.morphNormals = !1),
                  this.setValues(t)
              }
              function xl(t) {
                Ds.call(this),
                  (this.type = 'LineDashedMaterial'),
                  (this.scale = 1),
                  (this.dashSize = 3),
                  (this.gapSize = 1),
                  this.setValues(t)
              }
              ;(((hl.prototype = Object.create(Rr.prototype)).constructor =
                hl).prototype.isShadowMaterial = !0),
                (hl.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    this
                  )
                }),
                (((ul.prototype = Object.create(Pi.prototype)).constructor =
                  ul).prototype.isRawShaderMaterial = !0),
                (((pl.prototype = Object.create(Rr.prototype)).constructor =
                  pl).prototype.isMeshStandardMaterial = !0),
                (pl.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    (this.defines = { STANDARD: '' }),
                    this.color.copy(t.color),
                    (this.roughness = t.roughness),
                    (this.metalness = t.metalness),
                    (this.map = t.map),
                    (this.lightMap = t.lightMap),
                    (this.lightMapIntensity = t.lightMapIntensity),
                    (this.aoMap = t.aoMap),
                    (this.aoMapIntensity = t.aoMapIntensity),
                    this.emissive.copy(t.emissive),
                    (this.emissiveMap = t.emissiveMap),
                    (this.emissiveIntensity = t.emissiveIntensity),
                    (this.bumpMap = t.bumpMap),
                    (this.bumpScale = t.bumpScale),
                    (this.normalMap = t.normalMap),
                    (this.normalMapType = t.normalMapType),
                    this.normalScale.copy(t.normalScale),
                    (this.displacementMap = t.displacementMap),
                    (this.displacementScale = t.displacementScale),
                    (this.displacementBias = t.displacementBias),
                    (this.roughnessMap = t.roughnessMap),
                    (this.metalnessMap = t.metalnessMap),
                    (this.alphaMap = t.alphaMap),
                    (this.envMap = t.envMap),
                    (this.envMapIntensity = t.envMapIntensity),
                    (this.refractionRatio = t.refractionRatio),
                    (this.wireframe = t.wireframe),
                    (this.wireframeLinewidth = t.wireframeLinewidth),
                    (this.wireframeLinecap = t.wireframeLinecap),
                    (this.wireframeLinejoin = t.wireframeLinejoin),
                    (this.skinning = t.skinning),
                    (this.morphTargets = t.morphTargets),
                    (this.morphNormals = t.morphNormals),
                    (this.vertexTangents = t.vertexTangents),
                    this
                  )
                }),
                (((dl.prototype = Object.create(pl.prototype)).constructor =
                  dl).prototype.isMeshPhysicalMaterial = !0),
                (dl.prototype.copy = function (t) {
                  return (
                    pl.prototype.copy.call(this, t),
                    (this.defines = { STANDARD: '', PHYSICAL: '' }),
                    (this.clearcoat = t.clearcoat),
                    (this.clearcoatMap = t.clearcoatMap),
                    (this.clearcoatRoughness = t.clearcoatRoughness),
                    (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
                    (this.clearcoatNormalMap = t.clearcoatNormalMap),
                    this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
                    (this.reflectivity = t.reflectivity),
                    t.sheen
                      ? (this.sheen = (this.sheen || new Mr()).copy(t.sheen))
                      : (this.sheen = null),
                    (this.transparency = t.transparency),
                    this
                  )
                }),
                (((fl.prototype = Object.create(Rr.prototype)).constructor =
                  fl).prototype.isMeshPhongMaterial = !0),
                (fl.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    this.specular.copy(t.specular),
                    (this.shininess = t.shininess),
                    (this.map = t.map),
                    (this.lightMap = t.lightMap),
                    (this.lightMapIntensity = t.lightMapIntensity),
                    (this.aoMap = t.aoMap),
                    (this.aoMapIntensity = t.aoMapIntensity),
                    this.emissive.copy(t.emissive),
                    (this.emissiveMap = t.emissiveMap),
                    (this.emissiveIntensity = t.emissiveIntensity),
                    (this.bumpMap = t.bumpMap),
                    (this.bumpScale = t.bumpScale),
                    (this.normalMap = t.normalMap),
                    (this.normalMapType = t.normalMapType),
                    this.normalScale.copy(t.normalScale),
                    (this.displacementMap = t.displacementMap),
                    (this.displacementScale = t.displacementScale),
                    (this.displacementBias = t.displacementBias),
                    (this.specularMap = t.specularMap),
                    (this.alphaMap = t.alphaMap),
                    (this.envMap = t.envMap),
                    (this.combine = t.combine),
                    (this.reflectivity = t.reflectivity),
                    (this.refractionRatio = t.refractionRatio),
                    (this.wireframe = t.wireframe),
                    (this.wireframeLinewidth = t.wireframeLinewidth),
                    (this.wireframeLinecap = t.wireframeLinecap),
                    (this.wireframeLinejoin = t.wireframeLinejoin),
                    (this.skinning = t.skinning),
                    (this.morphTargets = t.morphTargets),
                    (this.morphNormals = t.morphNormals),
                    this
                  )
                }),
                (((ml.prototype = Object.create(Rr.prototype)).constructor =
                  ml).prototype.isMeshToonMaterial = !0),
                (ml.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    (this.map = t.map),
                    (this.gradientMap = t.gradientMap),
                    (this.lightMap = t.lightMap),
                    (this.lightMapIntensity = t.lightMapIntensity),
                    (this.aoMap = t.aoMap),
                    (this.aoMapIntensity = t.aoMapIntensity),
                    this.emissive.copy(t.emissive),
                    (this.emissiveMap = t.emissiveMap),
                    (this.emissiveIntensity = t.emissiveIntensity),
                    (this.bumpMap = t.bumpMap),
                    (this.bumpScale = t.bumpScale),
                    (this.normalMap = t.normalMap),
                    (this.normalMapType = t.normalMapType),
                    this.normalScale.copy(t.normalScale),
                    (this.displacementMap = t.displacementMap),
                    (this.displacementScale = t.displacementScale),
                    (this.displacementBias = t.displacementBias),
                    (this.alphaMap = t.alphaMap),
                    (this.wireframe = t.wireframe),
                    (this.wireframeLinewidth = t.wireframeLinewidth),
                    (this.wireframeLinecap = t.wireframeLinecap),
                    (this.wireframeLinejoin = t.wireframeLinejoin),
                    (this.skinning = t.skinning),
                    (this.morphTargets = t.morphTargets),
                    (this.morphNormals = t.morphNormals),
                    this
                  )
                }),
                (((vl.prototype = Object.create(Rr.prototype)).constructor =
                  vl).prototype.isMeshNormalMaterial = !0),
                (vl.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    (this.bumpMap = t.bumpMap),
                    (this.bumpScale = t.bumpScale),
                    (this.normalMap = t.normalMap),
                    (this.normalMapType = t.normalMapType),
                    this.normalScale.copy(t.normalScale),
                    (this.displacementMap = t.displacementMap),
                    (this.displacementScale = t.displacementScale),
                    (this.displacementBias = t.displacementBias),
                    (this.wireframe = t.wireframe),
                    (this.wireframeLinewidth = t.wireframeLinewidth),
                    (this.skinning = t.skinning),
                    (this.morphTargets = t.morphTargets),
                    (this.morphNormals = t.morphNormals),
                    this
                  )
                }),
                (((gl.prototype = Object.create(Rr.prototype)).constructor =
                  gl).prototype.isMeshLambertMaterial = !0),
                (gl.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    this.color.copy(t.color),
                    (this.map = t.map),
                    (this.lightMap = t.lightMap),
                    (this.lightMapIntensity = t.lightMapIntensity),
                    (this.aoMap = t.aoMap),
                    (this.aoMapIntensity = t.aoMapIntensity),
                    this.emissive.copy(t.emissive),
                    (this.emissiveMap = t.emissiveMap),
                    (this.emissiveIntensity = t.emissiveIntensity),
                    (this.specularMap = t.specularMap),
                    (this.alphaMap = t.alphaMap),
                    (this.envMap = t.envMap),
                    (this.combine = t.combine),
                    (this.reflectivity = t.reflectivity),
                    (this.refractionRatio = t.refractionRatio),
                    (this.wireframe = t.wireframe),
                    (this.wireframeLinewidth = t.wireframeLinewidth),
                    (this.wireframeLinecap = t.wireframeLinecap),
                    (this.wireframeLinejoin = t.wireframeLinejoin),
                    (this.skinning = t.skinning),
                    (this.morphTargets = t.morphTargets),
                    (this.morphNormals = t.morphNormals),
                    this
                  )
                }),
                (((yl.prototype = Object.create(Rr.prototype)).constructor =
                  yl).prototype.isMeshMatcapMaterial = !0),
                (yl.prototype.copy = function (t) {
                  return (
                    Rr.prototype.copy.call(this, t),
                    (this.defines = { MATCAP: '' }),
                    this.color.copy(t.color),
                    (this.matcap = t.matcap),
                    (this.map = t.map),
                    (this.bumpMap = t.bumpMap),
                    (this.bumpScale = t.bumpScale),
                    (this.normalMap = t.normalMap),
                    (this.normalMapType = t.normalMapType),
                    this.normalScale.copy(t.normalScale),
                    (this.displacementMap = t.displacementMap),
                    (this.displacementScale = t.displacementScale),
                    (this.displacementBias = t.displacementBias),
                    (this.alphaMap = t.alphaMap),
                    (this.skinning = t.skinning),
                    (this.morphTargets = t.morphTargets),
                    (this.morphNormals = t.morphNormals),
                    this
                  )
                }),
                (((xl.prototype = Object.create(Ds.prototype)).constructor =
                  xl).prototype.isLineDashedMaterial = !0),
                (xl.prototype.copy = function (t) {
                  return (
                    Ds.prototype.copy.call(this, t),
                    (this.scale = t.scale),
                    (this.dashSize = t.dashSize),
                    (this.gapSize = t.gapSize),
                    this
                  )
                })
              var bl = Object.freeze({
                  __proto__: null,
                  ShadowMaterial: hl,
                  SpriteMaterial: es,
                  RawShaderMaterial: ul,
                  ShaderMaterial: Pi,
                  PointsMaterial: Ws,
                  MeshPhysicalMaterial: dl,
                  MeshStandardMaterial: pl,
                  MeshPhongMaterial: fl,
                  MeshToonMaterial: ml,
                  MeshNormalMaterial: vl,
                  MeshLambertMaterial: gl,
                  MeshDepthMaterial: Do,
                  MeshDistanceMaterial: Bo,
                  MeshBasicMaterial: Cr,
                  MeshMatcapMaterial: yl,
                  LineDashedMaterial: xl,
                  LineBasicMaterial: Ds,
                  Material: Rr,
                }),
                _l = {
                  arraySlice: function (t, e, n) {
                    return _l.isTypedArray(t)
                      ? new t.constructor(
                          t.subarray(e, void 0 !== n ? n : t.length),
                        )
                      : t.slice(e, n)
                  },
                  convertArray: function (t, e, n) {
                    return !t || (!n && t.constructor === e)
                      ? t
                      : 'number' == typeof e.BYTES_PER_ELEMENT
                        ? new e(t)
                        : Array.prototype.slice.call(t)
                  },
                  isTypedArray: function (t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                  },
                  getKeyframeOrder: function (n) {
                    for (
                      var t = n.length, e = new Array(t), r = 0;
                      r !== t;
                      ++r
                    )
                      e[r] = r
                    return (
                      e.sort(function (t, e) {
                        return n[t] - n[e]
                      }),
                      e
                    )
                  },
                  sortedArray: function (t, e, n) {
                    for (
                      var r = t.length, i = new t.constructor(r), a = 0, o = 0;
                      o !== r;
                      ++a
                    )
                      for (var s = n[a] * e, c = 0; c !== e; ++c)
                        i[o++] = t[s + c]
                    return i
                  },
                  flattenJSON: function (t, e, n, r) {
                    for (var i = 1, a = t[0]; void 0 !== a && void 0 === a[r]; )
                      a = t[i++]
                    if (void 0 !== a) {
                      var o = a[r]
                      if (void 0 !== o)
                        if (Array.isArray(o))
                          for (
                            ;
                            void 0 !== (o = a[r]) &&
                              (e.push(a.time), n.push.apply(n, o)),
                              void 0 !== (a = t[i++]);

                          );
                        else if (void 0 !== o.toArray)
                          for (
                            ;
                            void 0 !== (o = a[r]) &&
                              (e.push(a.time), o.toArray(n, n.length)),
                              void 0 !== (a = t[i++]);

                          );
                        else
                          for (
                            ;
                            void 0 !== (o = a[r]) &&
                              (e.push(a.time), n.push(o)),
                              void 0 !== (a = t[i++]);

                          );
                    }
                  },
                  subclip: function (t, e, n, r, i) {
                    i = i || 30
                    var a = t.clone()
                    a.name = e
                    for (var o = [], s = 0; s < a.tracks.length; ++s) {
                      for (
                        var c = a.tracks[s],
                          l = c.getValueSize(),
                          h = [],
                          u = [],
                          p = 0;
                        p < c.times.length;
                        ++p
                      ) {
                        var d = c.times[p] * i
                        if (!(d < n || r <= d)) {
                          h.push(c.times[p])
                          for (var f = 0; f < l; ++f)
                            u.push(c.values[p * l + f])
                        }
                      }
                      0 !== h.length &&
                        ((c.times = _l.convertArray(h, c.times.constructor)),
                        (c.values = _l.convertArray(u, c.values.constructor)),
                        o.push(c))
                    }
                    a.tracks = o
                    for (var m = 1 / 0, v = 0; v < a.tracks.length; ++v)
                      m > a.tracks[v].times[0] && (m = a.tracks[v].times[0])
                    for (var g = 0; g < a.tracks.length; ++g)
                      a.tracks[g].shift(-1 * m)
                    return a.resetDuration(), a
                  },
                  makeClipAdditive: function (d, t, f, e) {
                    void 0 === t && (t = 0),
                      void 0 === f && (f = d),
                      (void 0 === e || e <= 0) && (e = 30)
                    for (var n = d.tracks.length, m = t / e, r = 0; r < n; ++r)
                      !(function (t) {
                        var e = f.tracks[t],
                          n = e.ValueTypeName
                        if ('bool' !== n && 'string' !== n) {
                          var r = d.tracks.find(function (t) {
                            return t.name === e.name && t.ValueTypeName === n
                          })
                          if (void 0 !== r) {
                            var i,
                              a,
                              o = e.getValueSize(),
                              s = e.times.length - 1,
                              c = void 0
                            ;(c =
                              m <= e.times[0]
                                ? _l.arraySlice(e.values, 0, e.valueSize)
                                : m >= e.times[s]
                                  ? ((i = s * o), _l.arraySlice(e.values, i))
                                  : ((a = e.createInterpolant()).evaluate(m),
                                    a.resultBuffer)),
                              'quaternion' === n &&
                                new nn(c[0], c[1], c[2], c[3])
                                  .normalize()
                                  .conjugate()
                                  .toArray(c)
                            for (var l = r.times.length, h = 0; h < l; ++h) {
                              var u = h * o
                              if ('quaternion' === n)
                                nn.multiplyQuaternionsFlat(
                                  r.values,
                                  u,
                                  c,
                                  0,
                                  r.values,
                                  u,
                                )
                              else
                                for (var p = 0; p < o; ++p)
                                  r.values[u + p] -= c[p]
                            }
                          }
                        }
                      })(r)
                    return (d.blendMode = 2501), d
                  },
                }
              function wl(t, e, n, r) {
                ;(this.parameterPositions = t),
                  (this._cachedIndex = 0),
                  (this.resultBuffer = void 0 !== r ? r : new e.constructor(n)),
                  (this.sampleValues = e),
                  (this.valueSize = n)
              }
              function Ml(t, e, n, r) {
                wl.call(this, t, e, n, r),
                  (this._weightPrev = -0),
                  (this._offsetPrev = -0),
                  (this._weightNext = -0),
                  (this._offsetNext = -0)
              }
              function Sl(t, e, n, r) {
                wl.call(this, t, e, n, r)
              }
              function El(t, e, n, r) {
                wl.call(this, t, e, n, r)
              }
              function Tl(t, e, n, r) {
                if (void 0 === t)
                  throw new Error(
                    'THREE.KeyframeTrack: track name is undefined',
                  )
                if (void 0 === e || 0 === e.length)
                  throw new Error(
                    'THREE.KeyframeTrack: no keyframes in track named ' + t,
                  )
                ;(this.name = t),
                  (this.times = _l.convertArray(e, this.TimeBufferType)),
                  (this.values = _l.convertArray(n, this.ValueBufferType)),
                  this.setInterpolation(r || this.DefaultInterpolation)
              }
              function Al(t, e, n) {
                Tl.call(this, t, e, n)
              }
              function Ll(t, e, n, r) {
                Tl.call(this, t, e, n, r)
              }
              function Rl(t, e, n, r) {
                Tl.call(this, t, e, n, r)
              }
              function Cl(t, e, n, r) {
                wl.call(this, t, e, n, r)
              }
              function Pl(t, e, n, r) {
                Tl.call(this, t, e, n, r)
              }
              function Ol(t, e, n, r) {
                Tl.call(this, t, e, n, r)
              }
              function Il(t, e, n, r) {
                Tl.call(this, t, e, n, r)
              }
              function Dl(t, e, n, r) {
                ;(this.name = t),
                  (this.tracks = n),
                  (this.duration = void 0 !== e ? e : -1),
                  (this.blendMode = void 0 !== r ? r : 2500),
                  (this.uuid = Xe.generateUUID()),
                  this.duration < 0 && this.resetDuration()
              }
              function Bl(t) {
                if (void 0 === t.type)
                  throw new Error(
                    'THREE.KeyframeTrack: track type undefined, can not parse',
                  )
                var e,
                  n,
                  r = (function (t) {
                    switch (t.toLowerCase()) {
                      case 'scalar':
                      case 'double':
                      case 'float':
                      case 'number':
                      case 'integer':
                        return Rl
                      case 'vector':
                      case 'vector2':
                      case 'vector3':
                      case 'vector4':
                        return Il
                      case 'color':
                        return Ll
                      case 'quaternion':
                        return Pl
                      case 'bool':
                      case 'boolean':
                        return Al
                      case 'string':
                        return Ol
                    }
                    throw new Error(
                      'THREE.KeyframeTrack: Unsupported typeName: ' + t,
                    )
                  })(t.type)
                return (
                  void 0 === t.times &&
                    ((e = []),
                    (n = []),
                    _l.flattenJSON(t.keys, e, n, 'value'),
                    (t.times = e),
                    (t.values = n)),
                  void 0 !== r.parse
                    ? r.parse(t)
                    : new r(t.name, t.times, t.values, t.interpolation)
                )
              }
              Object.assign(wl.prototype, {
                evaluate: function (t) {
                  var e,
                    n = this.parameterPositions,
                    r = this._cachedIndex,
                    i = n[r],
                    a = n[r - 1]
                  t: {
                    e: {
                      n: {
                        r: if (!(t < i)) {
                          for (var o = r + 2; ; ) {
                            if (void 0 === i) {
                              if (t < a) break r
                              return (
                                (r = n.length),
                                (this._cachedIndex = r),
                                this.afterEnd_(r - 1, t, a)
                              )
                            }
                            if (r === o) break
                            if (((a = i), t < (i = n[++r]))) break e
                          }
                          e = n.length
                          break n
                        }
                        if (a <= t) break t
                        var s = n[1]
                        t < s && ((r = 2), (a = s))
                        for (var c = r - 2; ; ) {
                          if (void 0 === a)
                            return (
                              (this._cachedIndex = 0),
                              this.beforeStart_(0, t, i)
                            )
                          if (r === c) break
                          if (((i = a), (a = n[--r - 1]) <= t)) break e
                        }
                        ;(e = r), (r = 0)
                      }
                      for (; r < e; ) {
                        var l = (r + e) >>> 1
                        t < n[l] ? (e = l) : (r = 1 + l)
                      }
                      if (((i = n[r]), void 0 === (a = n[r - 1])))
                        return (
                          (this._cachedIndex = 0), this.beforeStart_(0, t, i)
                        )
                      if (void 0 === i)
                        return (
                          (r = n.length),
                          (this._cachedIndex = r),
                          this.afterEnd_(r - 1, a, t)
                        )
                    }
                    ;(this._cachedIndex = r), this.intervalChanged_(r, a, i)
                  }
                  return this.interpolate_(r, a, t, i)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function () {
                  return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function (t) {
                  for (
                    var e = this.resultBuffer,
                      n = this.sampleValues,
                      r = this.valueSize,
                      i = t * r,
                      a = 0;
                    a !== r;
                    ++a
                  )
                    e[a] = n[i + a]
                  return e
                },
                interpolate_: function () {
                  throw new Error('call to abstract method')
                },
                intervalChanged_: function () {},
              }),
                Object.assign(wl.prototype, {
                  beforeStart_: wl.prototype.copySampleValue_,
                  afterEnd_: wl.prototype.copySampleValue_,
                }),
                (Ml.prototype = Object.assign(Object.create(wl.prototype), {
                  constructor: Ml,
                  DefaultSettings_: { endingStart: Te, endingEnd: Te },
                  intervalChanged_: function (t, e, n) {
                    var r = this.parameterPositions,
                      i = t - 2,
                      a = t + 1,
                      o = r[i],
                      s = r[a]
                    if (void 0 === o)
                      switch (this.getSettings_().endingStart) {
                        case Ae:
                          ;(i = t), (o = 2 * e - n)
                          break
                        case Le:
                          o = e + r[(i = r.length - 2)] - r[i + 1]
                          break
                        default:
                          ;(i = t), (o = n)
                      }
                    if (void 0 === s)
                      switch (this.getSettings_().endingEnd) {
                        case Ae:
                          ;(a = t), (s = 2 * n - e)
                          break
                        case Le:
                          s = n + r[(a = 1)] - r[0]
                          break
                        default:
                          ;(a = t - 1), (s = e)
                      }
                    var c = 0.5 * (n - e),
                      l = this.valueSize
                    ;(this._weightPrev = c / (e - o)),
                      (this._weightNext = c / (s - n)),
                      (this._offsetPrev = i * l),
                      (this._offsetNext = a * l)
                  },
                  interpolate_: function (t, e, n, r) {
                    for (
                      var i = this.resultBuffer,
                        a = this.sampleValues,
                        o = this.valueSize,
                        s = t * o,
                        c = s - o,
                        l = this._offsetPrev,
                        h = this._offsetNext,
                        u = this._weightPrev,
                        p = this._weightNext,
                        d = (n - e) / (r - e),
                        f = d * d,
                        m = f * d,
                        v = -u * m + 2 * u * f - u * d,
                        g =
                          (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * d + 1,
                        y = (-1 - p) * m + (1.5 + p) * f + 0.5 * d,
                        x = p * m - p * f,
                        b = 0;
                      b !== o;
                      ++b
                    )
                      i[b] =
                        v * a[l + b] +
                        g * a[c + b] +
                        y * a[s + b] +
                        x * a[h + b]
                    return i
                  },
                })),
                (Sl.prototype = Object.assign(Object.create(wl.prototype), {
                  constructor: Sl,
                  interpolate_: function (t, e, n, r) {
                    for (
                      var i = this.resultBuffer,
                        a = this.sampleValues,
                        o = this.valueSize,
                        s = t * o,
                        c = s - o,
                        l = (n - e) / (r - e),
                        h = 1 - l,
                        u = 0;
                      u !== o;
                      ++u
                    )
                      i[u] = a[c + u] * h + a[s + u] * l
                    return i
                  },
                })),
                (El.prototype = Object.assign(Object.create(wl.prototype), {
                  constructor: El,
                  interpolate_: function (t) {
                    return this.copySampleValue_(t - 1)
                  },
                })),
                Object.assign(Tl, {
                  toJSON: function (t) {
                    var e,
                      n,
                      r = t.constructor
                    return (
                      void 0 !== r.toJSON
                        ? (e = r.toJSON(t))
                        : ((e = {
                            name: t.name,
                            times: _l.convertArray(t.times, Array),
                            values: _l.convertArray(t.values, Array),
                          }),
                          (n = t.getInterpolation()) !==
                            t.DefaultInterpolation && (e.interpolation = n)),
                      (e.type = t.ValueTypeName),
                      e
                    )
                  },
                }),
                Object.assign(Tl.prototype, {
                  constructor: Tl,
                  TimeBufferType: Float32Array,
                  ValueBufferType: Float32Array,
                  DefaultInterpolation: Ee,
                  InterpolantFactoryMethodDiscrete: function (t) {
                    return new El(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      t,
                    )
                  },
                  InterpolantFactoryMethodLinear: function (t) {
                    return new Sl(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      t,
                    )
                  },
                  InterpolantFactoryMethodSmooth: function (t) {
                    return new Ml(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      t,
                    )
                  },
                  setInterpolation: function (t) {
                    var e
                    switch (t) {
                      case r:
                        e = this.InterpolantFactoryMethodDiscrete
                        break
                      case Ee:
                        e = this.InterpolantFactoryMethodLinear
                        break
                      case 2302:
                        e = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 !== e) return (this.createInterpolant = e), this
                    var n =
                      'unsupported interpolation for ' +
                      this.ValueTypeName +
                      ' keyframe track named ' +
                      this.name
                    if (void 0 === this.createInterpolant) {
                      if (t === this.DefaultInterpolation) throw new Error(n)
                      this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn('THREE.KeyframeTrack:', n), this
                  },
                  getInterpolation: function () {
                    switch (this.createInterpolant) {
                      case this.InterpolantFactoryMethodDiscrete:
                        return r
                      case this.InterpolantFactoryMethodLinear:
                        return Ee
                      case this.InterpolantFactoryMethodSmooth:
                        return 2302
                    }
                  },
                  getValueSize: function () {
                    return this.values.length / this.times.length
                  },
                  shift: function (t) {
                    if (0 !== t)
                      for (
                        var e = this.times, n = 0, r = e.length;
                        n !== r;
                        ++n
                      )
                        e[n] += t
                    return this
                  },
                  scale: function (t) {
                    if (1 !== t)
                      for (
                        var e = this.times, n = 0, r = e.length;
                        n !== r;
                        ++n
                      )
                        e[n] *= t
                    return this
                  },
                  trim: function (t, e) {
                    for (
                      var n, r = this.times, i = r.length, a = 0, o = i - 1;
                      a !== i && r[a] < t;

                    )
                      ++a
                    for (; -1 !== o && r[o] > e; ) --o
                    return (
                      ++o,
                      (0 === a && o === i) ||
                        (o <= a && (a = (o = Math.max(o, 1)) - 1),
                        (n = this.getValueSize()),
                        (this.times = _l.arraySlice(r, a, o)),
                        (this.values = _l.arraySlice(
                          this.values,
                          a * n,
                          o * n,
                        ))),
                      this
                    )
                  },
                  validate: function () {
                    var t = !0,
                      e = this.getValueSize()
                    e - Math.floor(e) != 0 &&
                      (console.error(
                        'THREE.KeyframeTrack: Invalid value size in track.',
                        this,
                      ),
                      (t = !1))
                    var n = this.times,
                      r = this.values,
                      i = n.length
                    0 === i &&
                      (console.error(
                        'THREE.KeyframeTrack: Track is empty.',
                        this,
                      ),
                      (t = !1))
                    for (var a = null, o = 0; o !== i; o++) {
                      var s = n[o]
                      if ('number' == typeof s && isNaN(s)) {
                        console.error(
                          'THREE.KeyframeTrack: Time is not a valid number.',
                          this,
                          o,
                          s,
                        ),
                          (t = !1)
                        break
                      }
                      if (null !== a && s < a) {
                        console.error(
                          'THREE.KeyframeTrack: Out of order keys.',
                          this,
                          o,
                          s,
                          a,
                        ),
                          (t = !1)
                        break
                      }
                      a = s
                    }
                    if (void 0 !== r && _l.isTypedArray(r))
                      for (var c = 0, l = r.length; c !== l; ++c) {
                        var h = r[c]
                        if (isNaN(h)) {
                          console.error(
                            'THREE.KeyframeTrack: Value is not a valid number.',
                            this,
                            c,
                            h,
                          ),
                            (t = !1)
                          break
                        }
                      }
                    return t
                  },
                  optimize: function () {
                    for (
                      var t = _l.arraySlice(this.times),
                        e = _l.arraySlice(this.values),
                        n = this.getValueSize(),
                        r = 2302 === this.getInterpolation(),
                        i = t.length - 1,
                        a = 1,
                        o = 1;
                      o < i;
                      ++o
                    ) {
                      var s = !1,
                        c = t[o]
                      if (c !== t[o + 1] && (1 !== o || c !== c[0]))
                        if (r) s = !0
                        else
                          for (
                            var l = o * n, h = l - n, u = l + n, p = 0;
                            p !== n;
                            ++p
                          ) {
                            var d = e[l + p]
                            if (d !== e[h + p] || d !== e[u + p]) {
                              s = !0
                              break
                            }
                          }
                      if (s) {
                        if (o !== a) {
                          t[a] = t[o]
                          for (var f = o * n, m = a * n, v = 0; v !== n; ++v)
                            e[m + v] = e[f + v]
                        }
                        ++a
                      }
                    }
                    if (0 < i) {
                      t[a] = t[i]
                      for (var g = i * n, y = a * n, x = 0; x !== n; ++x)
                        e[y + x] = e[g + x]
                      ++a
                    }
                    return (
                      a !== t.length
                        ? ((this.times = _l.arraySlice(t, 0, a)),
                          (this.values = _l.arraySlice(e, 0, a * n)))
                        : ((this.times = t), (this.values = e)),
                      this
                    )
                  },
                  clone: function () {
                    var t = _l.arraySlice(this.times, 0),
                      e = _l.arraySlice(this.values, 0),
                      n = new this.constructor(this.name, t, e)
                    return (n.createInterpolant = this.createInterpolant), n
                  },
                }),
                (Al.prototype = Object.assign(Object.create(Tl.prototype), {
                  constructor: Al,
                  ValueTypeName: 'bool',
                  ValueBufferType: Array,
                  DefaultInterpolation: r,
                  InterpolantFactoryMethodLinear: void 0,
                  InterpolantFactoryMethodSmooth: void 0,
                })),
                (Ll.prototype = Object.assign(Object.create(Tl.prototype), {
                  constructor: Ll,
                  ValueTypeName: 'color',
                })),
                (Rl.prototype = Object.assign(Object.create(Tl.prototype), {
                  constructor: Rl,
                  ValueTypeName: 'number',
                })),
                (Cl.prototype = Object.assign(Object.create(wl.prototype), {
                  constructor: Cl,
                  interpolate_: function (t, e, n, r) {
                    for (
                      var i = this.resultBuffer,
                        a = this.sampleValues,
                        o = this.valueSize,
                        s = (n - e) / (r - e),
                        c = t * o,
                        l = c + o;
                      c !== l;
                      c += 4
                    )
                      nn.slerpFlat(i, 0, a, c - o, a, c, s)
                    return i
                  },
                })),
                (Pl.prototype = Object.assign(Object.create(Tl.prototype), {
                  constructor: Pl,
                  ValueTypeName: 'quaternion',
                  DefaultInterpolation: Ee,
                  InterpolantFactoryMethodLinear: function (t) {
                    return new Cl(
                      this.times,
                      this.values,
                      this.getValueSize(),
                      t,
                    )
                  },
                  InterpolantFactoryMethodSmooth: void 0,
                })),
                (Ol.prototype = Object.assign(Object.create(Tl.prototype), {
                  constructor: Ol,
                  ValueTypeName: 'string',
                  ValueBufferType: Array,
                  DefaultInterpolation: r,
                  InterpolantFactoryMethodLinear: void 0,
                  InterpolantFactoryMethodSmooth: void 0,
                })),
                (Il.prototype = Object.assign(Object.create(Tl.prototype), {
                  constructor: Il,
                  ValueTypeName: 'vector',
                })),
                Object.assign(Dl, {
                  parse: function (t) {
                    for (
                      var e = [],
                        n = t.tracks,
                        r = 1 / (t.fps || 1),
                        i = 0,
                        a = n.length;
                      i !== a;
                      ++i
                    )
                      e.push(Bl(n[i]).scale(r))
                    return new Dl(t.name, t.duration, e, t.blendMode)
                  },
                  toJSON: function (t) {
                    for (
                      var e = [],
                        n = t.tracks,
                        r = {
                          name: t.name,
                          duration: t.duration,
                          tracks: e,
                          uuid: t.uuid,
                          blendMode: t.blendMode,
                        },
                        i = 0,
                        a = n.length;
                      i !== a;
                      ++i
                    )
                      e.push(Tl.toJSON(n[i]))
                    return r
                  },
                  CreateFromMorphTargetSequence: function (t, e, n, r) {
                    for (var i = e.length, a = [], o = 0; o < i; o++) {
                      var s = []
                      ;(l = []).push((o + i - 1) % i, o, (o + 1) % i),
                        s.push(0, 1, 0)
                      var c = _l.getKeyframeOrder(l),
                        l = _l.sortedArray(l, 1, c),
                        s = _l.sortedArray(s, 1, c)
                      r || 0 !== l[0] || (l.push(i), s.push(s[0])),
                        a.push(
                          new Rl(
                            '.morphTargetInfluences[' + e[o].name + ']',
                            l,
                            s,
                          ).scale(1 / n),
                        )
                    }
                    return new Dl(t, -1, a)
                  },
                  findByName: function (t, e) {
                    var n = t
                    Array.isArray(t) ||
                      (n =
                        (t.geometry && t.geometry.animations) || t.animations)
                    for (var r = 0; r < n.length; r++)
                      if (n[r].name === e) return n[r]
                    return null
                  },
                  CreateClipsFromMorphTargetSequences: function (t, e, n) {
                    for (
                      var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length;
                      a < o;
                      a++
                    ) {
                      var s,
                        c,
                        l = t[a],
                        h = l.name.match(i)
                      h &&
                        1 < h.length &&
                        ((c = r[(s = h[1])]) || (r[s] = c = []), c.push(l))
                    }
                    var u = []
                    for (var p in r)
                      u.push(Dl.CreateFromMorphTargetSequence(p, r[p], e, n))
                    return u
                  },
                  parseAnimation: function (t, e) {
                    if (!t)
                      return (
                        console.error(
                          'THREE.AnimationClip: No animation in JSONLoader data.',
                        ),
                        null
                      )
                    for (
                      var n = function (t, e, n, r, i) {
                          var a, o
                          0 !== n.length &&
                            ((a = []),
                            (o = []),
                            _l.flattenJSON(n, a, o, r),
                            0 !== a.length && i.push(new t(e, a, o)))
                        },
                        r = [],
                        i = t.name || 'default',
                        a = t.fps || 30,
                        o = t.blendMode,
                        s = t.length || -1,
                        c = t.hierarchy || [],
                        l = 0;
                      l < c.length;
                      l++
                    ) {
                      var h = c[l].keys
                      if (h && 0 !== h.length)
                        if (h[0].morphTargets) {
                          for (var u = {}, p = void 0, p = 0; p < h.length; p++)
                            if (h[p].morphTargets)
                              for (var d = 0; d < h[p].morphTargets.length; d++)
                                u[h[p].morphTargets[d]] = -1
                          for (var f in u) {
                            for (
                              var m = [], v = [], g = 0;
                              g !== h[p].morphTargets.length;
                              ++g
                            ) {
                              var y = h[p]
                              m.push(y.time),
                                v.push(y.morphTarget === f ? 1 : 0)
                            }
                            r.push(
                              new Rl('.morphTargetInfluence[' + f + ']', m, v),
                            )
                          }
                          s = u.length * (a || 1)
                        } else {
                          var x = '.bones[' + e[l].name + ']'
                          n(Il, x + '.position', h, 'pos', r),
                            n(Pl, x + '.quaternion', h, 'rot', r),
                            n(Il, x + '.scale', h, 'scl', r)
                        }
                    }
                    return 0 === r.length ? null : new Dl(i, s, r, o)
                  },
                }),
                Object.assign(Dl.prototype, {
                  resetDuration: function () {
                    for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e)
                      var r = this.tracks[e],
                        t = Math.max(t, r.times[r.times.length - 1])
                    return (this.duration = t), this
                  },
                  trim: function () {
                    for (var t = 0; t < this.tracks.length; t++)
                      this.tracks[t].trim(0, this.duration)
                    return this
                  },
                  validate: function () {
                    for (var t = !0, e = 0; e < this.tracks.length; e++)
                      t = t && this.tracks[e].validate()
                    return t
                  },
                  optimize: function () {
                    for (var t = 0; t < this.tracks.length; t++)
                      this.tracks[t].optimize()
                    return this
                  },
                  clone: function () {
                    for (var t = [], e = 0; e < this.tracks.length; e++)
                      t.push(this.tracks[e].clone())
                    return new Dl(this.name, this.duration, t, this.blendMode)
                  },
                })
              var Nl = {
                enabled: !1,
                files: {},
                add: function (t, e) {
                  !1 !== this.enabled && (this.files[t] = e)
                },
                get: function (t) {
                  if (!1 !== this.enabled) return this.files[t]
                },
                remove: function (t) {
                  delete this.files[t]
                },
                clear: function () {
                  this.files = {}
                },
              }
              function Ul(t, e, n) {
                var r = this,
                  i = !1,
                  a = 0,
                  o = 0,
                  s = void 0,
                  c = []
                ;(this.onStart = void 0),
                  (this.onLoad = t),
                  (this.onProgress = e),
                  (this.onError = n),
                  (this.itemStart = function (t) {
                    o++,
                      !1 === i && void 0 !== r.onStart && r.onStart(t, a, o),
                      (i = !0)
                  }),
                  (this.itemEnd = function (t) {
                    a++,
                      void 0 !== r.onProgress && r.onProgress(t, a, o),
                      a === o && ((i = !1), void 0 !== r.onLoad && r.onLoad())
                  }),
                  (this.itemError = function (t) {
                    void 0 !== r.onError && r.onError(t)
                  }),
                  (this.resolveURL = function (t) {
                    return s ? s(t) : t
                  }),
                  (this.setURLModifier = function (t) {
                    return (s = t), this
                  }),
                  (this.addHandler = function (t, e) {
                    return c.push(t, e), this
                  }),
                  (this.removeHandler = function (t) {
                    var e = c.indexOf(t)
                    return -1 !== e && c.splice(e, 2), this
                  }),
                  (this.getHandler = function (t) {
                    for (var e = 0, n = c.length; e < n; e += 2) {
                      var r = c[e],
                        i = c[e + 1]
                      if ((r.global && (r.lastIndex = 0), r.test(t))) return i
                    }
                    return null
                  })
              }
              var zl = new Ul()
              function Fl(t) {
                ;(this.manager = void 0 !== t ? t : zl),
                  (this.crossOrigin = 'anonymous'),
                  (this.path = ''),
                  (this.resourcePath = ''),
                  (this.requestHeader = {})
              }
              Object.assign(Fl.prototype, {
                load: function () {},
                loadAsync: function (n, r) {
                  var i = this
                  return new Promise(function (t, e) {
                    i.load(n, t, r, e)
                  })
                },
                parse: function () {},
                setCrossOrigin: function (t) {
                  return (this.crossOrigin = t), this
                },
                setPath: function (t) {
                  return (this.path = t), this
                },
                setResourcePath: function (t) {
                  return (this.resourcePath = t), this
                },
                setRequestHeader: function (t) {
                  return (this.requestHeader = t), this
                },
              })
              var Hl = {}
              function Gl(t) {
                Fl.call(this, t)
              }
              function kl(t) {
                Fl.call(this, t)
              }
              function Vl(t) {
                Fl.call(this, t)
              }
              function jl(t) {
                Fl.call(this, t)
              }
              function Wl(t) {
                Fl.call(this, t)
              }
              function ql(t) {
                Fl.call(this, t)
              }
              function Xl(t) {
                Fl.call(this, t)
              }
              function Yl() {
                ;(this.type = 'Curve'), (this.arcLengthDivisions = 200)
              }
              function Zl(t, e, n, r, i, a, o, s) {
                Yl.call(this),
                  (this.type = 'EllipseCurve'),
                  (this.aX = t || 0),
                  (this.aY = e || 0),
                  (this.xRadius = n || 1),
                  (this.yRadius = r || 1),
                  (this.aStartAngle = i || 0),
                  (this.aEndAngle = a || 2 * Math.PI),
                  (this.aClockwise = o || !1),
                  (this.aRotation = s || 0)
              }
              function Jl(t, e, n, r, i, a) {
                Zl.call(this, t, e, n, n, r, i, a), (this.type = 'ArcCurve')
              }
              function Ql() {
                var i = 0,
                  a = 0,
                  o = 0,
                  s = 0
                function l(t, e, n, r) {
                  ;(o = -3 * (i = t) + 3 * e - 2 * (a = n) - r),
                    (s = 2 * t - 2 * e + n + r)
                }
                return {
                  initCatmullRom: function (t, e, n, r, i) {
                    l(e, n, i * (n - t), i * (r - e))
                  },
                  initNonuniformCatmullRom: function (t, e, n, r, i, a, o) {
                    var s = (e - t) / i - (n - t) / (i + a) + (n - e) / a,
                      c = (n - e) / a - (r - e) / (a + o) + (r - n) / o
                    l(e, n, (s *= a), (c *= a))
                  },
                  calc: function (t) {
                    var e = t * t
                    return i + a * t + o * e + s * (e * t)
                  },
                }
              }
              ;(Gl.prototype = Object.assign(Object.create(Fl.prototype), {
                constructor: Gl,
                load: function (l, t, e, n) {
                  void 0 === l && (l = ''),
                    void 0 !== this.path && (l = this.path + l),
                    (l = this.manager.resolveURL(l))
                  var h = this,
                    r = Nl.get(l)
                  if (void 0 !== r)
                    return (
                      h.manager.itemStart(l),
                      setTimeout(function () {
                        t && t(r), h.manager.itemEnd(l)
                      }, 0),
                      r
                    )
                  if (void 0 === Hl[l]) {
                    var i,
                      a = l.match(/^data:(.*?)(;base64)?,(.*)$/)
                    if (a) {
                      var o = a[1],
                        s = !!a[2],
                        c = a[3],
                        c = decodeURIComponent(c)
                      s && (c = atob(c))
                      try {
                        var u = (this.responseType || '').toLowerCase()
                        switch (u) {
                          case 'arraybuffer':
                          case 'blob':
                            for (
                              var p = new Uint8Array(c.length), d = 0;
                              d < c.length;
                              d++
                            )
                              p[d] = c.charCodeAt(d)
                            f =
                              'blob' === u
                                ? new Blob([p.buffer], { type: o })
                                : p.buffer
                            break
                          case 'document':
                            var f = new DOMParser().parseFromString(c, o)
                            break
                          case 'json':
                            f = JSON.parse(c)
                            break
                          default:
                            f = c
                        }
                        setTimeout(function () {
                          t && t(f), h.manager.itemEnd(l)
                        }, 0)
                      } catch (t) {
                        setTimeout(function () {
                          n && n(t),
                            h.manager.itemError(l),
                            h.manager.itemEnd(l)
                        }, 0)
                      }
                    } else {
                      for (var m in ((Hl[l] = []),
                      Hl[l].push({ onLoad: t, onProgress: e, onError: n }),
                      (i = new XMLHttpRequest()).open('GET', l, !0),
                      i.addEventListener(
                        'load',
                        function (t) {
                          var e = this.response,
                            n = Hl[l]
                          if (
                            (delete Hl[l],
                            200 === this.status || 0 === this.status)
                          ) {
                            0 === this.status &&
                              console.warn(
                                'THREE.FileLoader: HTTP Status 0 received.',
                              ),
                              Nl.add(l, e)
                            for (var r = 0, i = n.length; r < i; r++) {
                              var a = n[r]
                              a.onLoad && a.onLoad(e)
                            }
                            h.manager.itemEnd(l)
                          } else {
                            for (var o = 0, s = n.length; o < s; o++) {
                              var c = n[o]
                              c.onError && c.onError(t)
                            }
                            h.manager.itemError(l), h.manager.itemEnd(l)
                          }
                        },
                        !1,
                      ),
                      i.addEventListener(
                        'progress',
                        function (t) {
                          for (var e = Hl[l], n = 0, r = e.length; n < r; n++) {
                            var i = e[n]
                            i.onProgress && i.onProgress(t)
                          }
                        },
                        !1,
                      ),
                      i.addEventListener(
                        'error',
                        function (t) {
                          var e = Hl[l]
                          delete Hl[l]
                          for (var n = 0, r = e.length; n < r; n++) {
                            var i = e[n]
                            i.onError && i.onError(t)
                          }
                          h.manager.itemError(l), h.manager.itemEnd(l)
                        },
                        !1,
                      ),
                      i.addEventListener(
                        'abort',
                        function (t) {
                          var e = Hl[l]
                          delete Hl[l]
                          for (var n = 0, r = e.length; n < r; n++) {
                            var i = e[n]
                            i.onError && i.onError(t)
                          }
                          h.manager.itemError(l), h.manager.itemEnd(l)
                        },
                        !1,
                      ),
                      void 0 !== this.responseType &&
                        (i.responseType = this.responseType),
                      void 0 !== this.withCredentials &&
                        (i.withCredentials = this.withCredentials),
                      i.overrideMimeType &&
                        i.overrideMimeType(
                          void 0 !== this.mimeType
                            ? this.mimeType
                            : 'text/plain',
                        ),
                      this.requestHeader))
                        i.setRequestHeader(m, this.requestHeader[m])
                      i.send(null)
                    }
                    return h.manager.itemStart(l), i
                  }
                  Hl[l].push({ onLoad: t, onProgress: e, onError: n })
                },
                setResponseType: function (t) {
                  return (this.responseType = t), this
                },
                setWithCredentials: function (t) {
                  return (this.withCredentials = t), this
                },
                setMimeType: function (t) {
                  return (this.mimeType = t), this
                },
              })),
                (kl.prototype = Object.assign(Object.create(Fl.prototype), {
                  constructor: kl,
                  load: function (e, n, t, r) {
                    var i = this,
                      a = new Gl(i.manager)
                    a.setPath(i.path),
                      a.load(
                        e,
                        function (t) {
                          try {
                            n(i.parse(JSON.parse(t)))
                          } catch (t) {
                            r ? r(t) : console.error(t), i.manager.itemError(e)
                          }
                        },
                        t,
                        r,
                      )
                  },
                  parse: function (t) {
                    for (var e = [], n = 0; n < t.length; n++) {
                      var r = Dl.parse(t[n])
                      e.push(r)
                    }
                    return e
                  },
                })),
                (Vl.prototype = Object.assign(Object.create(Fl.prototype), {
                  constructor: Vl,
                  load: function (t, a, e, r) {
                    var o = this,
                      s = [],
                      c = new $s()
                    c.image = s
                    var i = new Gl(this.manager)
                    i.setPath(this.path), i.setResponseType('arraybuffer')
                    var l = 0
                    if (Array.isArray(t))
                      for (var n = 0, h = t.length; n < h; ++n)
                        !(function (n) {
                          i.load(
                            t[n],
                            function (t) {
                              var e = o.parse(t, !0)
                              ;(s[n] = {
                                width: e.width,
                                height: e.height,
                                format: e.format,
                                mipmaps: e.mipmaps,
                              }),
                                6 === (l += 1) &&
                                  (1 === e.mipmapCount && (c.minFilter = Vt),
                                  (c.format = e.format),
                                  (c.needsUpdate = !0),
                                  a && a(c))
                            },
                            e,
                            r,
                          )
                        })(n)
                    else
                      i.load(
                        t,
                        function (t) {
                          var e = o.parse(t, !0)
                          if (e.isCubemap)
                            for (
                              var n = e.mipmaps.length / e.mipmapCount, r = 0;
                              r < n;
                              r++
                            ) {
                              s[r] = { mipmaps: [] }
                              for (var i = 0; i < e.mipmapCount; i++)
                                s[r].mipmaps.push(
                                  e.mipmaps[r * e.mipmapCount + i],
                                ),
                                  (s[r].format = e.format),
                                  (s[r].width = e.width),
                                  (s[r].height = e.height)
                            }
                          else
                            (c.image.width = e.width),
                              (c.image.height = e.height),
                              (c.mipmaps = e.mipmaps)
                          1 === e.mipmapCount && (c.minFilter = Vt),
                            (c.format = e.format),
                            (c.needsUpdate = !0),
                            a && a(c)
                        },
                        e,
                        r,
                      )
                    return c
                  },
                })),
                (jl.prototype = Object.assign(Object.create(Fl.prototype), {
                  constructor: jl,
                  load: function (t, n, e, r) {
                    var i = this,
                      a = new Ni(),
                      o = new Gl(this.manager)
                    return (
                      o.setResponseType('arraybuffer'),
                      o.setPath(this.path),
                      o.load(
                        t,
                        function (t) {
                          var e = i.parse(t)
                          e &&
                            (void 0 !== e.image
                              ? (a.image = e.image)
                              : void 0 !== e.data &&
                                ((a.image.width = e.width),
                                (a.image.height = e.height),
                                (a.image.data = e.data)),
                            (a.wrapS = void 0 !== e.wrapS ? e.wrapS : zt),
                            (a.wrapT = void 0 !== e.wrapT ? e.wrapT : zt),
                            (a.magFilter =
                              void 0 !== e.magFilter ? e.magFilter : Vt),
                            (a.minFilter =
                              void 0 !== e.minFilter ? e.minFilter : Vt),
                            (a.anisotropy =
                              void 0 !== e.anisotropy ? e.anisotropy : 1),
                            void 0 !== e.format && (a.format = e.format),
                            void 0 !== e.type && (a.type = e.type),
                            void 0 !== e.mipmaps &&
                              ((a.mipmaps = e.mipmaps), (a.minFilter = Wt)),
                            1 === e.mipmapCount && (a.minFilter = Vt),
                            (a.needsUpdate = !0),
                            n && n(a, e))
                        },
                        e,
                        r,
                      ),
                      a
                    )
                  },
                })),
                (Wl.prototype = Object.assign(Object.create(Fl.prototype), {
                  constructor: Wl,
                  load: function (e, t, n, r) {
                    void 0 !== this.path && (e = this.path + e),
                      (e = this.manager.resolveURL(e))
                    var i = this,
                      a = Nl.get(e)
                    if (void 0 !== a)
                      return (
                        i.manager.itemStart(e),
                        setTimeout(function () {
                          t && t(a), i.manager.itemEnd(e)
                        }, 0),
                        a
                      )
                    var o = document.createElementNS(
                      'http://www.w3.org/1999/xhtml',
                      'img',
                    )
                    function s() {
                      o.removeEventListener('load', s, !1),
                        o.removeEventListener('error', c, !1),
                        Nl.add(e, this),
                        t && t(this),
                        i.manager.itemEnd(e)
                    }
                    function c(t) {
                      o.removeEventListener('load', s, !1),
                        o.removeEventListener('error', c, !1),
                        r && r(t),
                        i.manager.itemError(e),
                        i.manager.itemEnd(e)
                    }
                    return (
                      o.addEventListener('load', s, !1),
                      o.addEventListener('error', c, !1),
                      'data:' !== e.substr(0, 5) &&
                        void 0 !== this.crossOrigin &&
                        (o.crossOrigin = this.crossOrigin),
                      i.manager.itemStart(e),
                      (o.src = e),
                      o
                    )
                  },
                })),
                (ql.prototype = Object.assign(Object.create(Fl.prototype), {
                  constructor: ql,
                  load: function (t, n, e, r) {
                    var i = new oa(),
                      a = new Wl(this.manager)
                    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path)
                    var o = 0
                    for (var s = 0; s < t.length; ++s)
                      !(function (e) {
                        a.load(
                          t[e],
                          function (t) {
                            ;(i.images[e] = t),
                              6 === ++o && ((i.needsUpdate = !0), n && n(i))
                          },
                          void 0,
                          r,
                        )
                      })(s)
                    return i
                  },
                })),
                (Xl.prototype = Object.assign(Object.create(Fl.prototype), {
                  constructor: Xl,
                  load: function (n, r, t, e) {
                    var i = new Ke(),
                      a = new Wl(this.manager)
                    return (
                      a.setCrossOrigin(this.crossOrigin),
                      a.setPath(this.path),
                      a.load(
                        n,
                        function (t) {
                          i.image = t
                          var e =
                            0 < n.search(/\.jpe?g($|\?)/i) ||
                            0 === n.search(/^data\:image\/jpeg/)
                          ;(i.format = e ? Kt : $t),
                            (i.needsUpdate = !0),
                            void 0 !== r && r(i)
                        },
                        t,
                        e,
                      ),
                      i
                    )
                  },
                })),
                Object.assign(Yl.prototype, {
                  getPoint: function () {
                    return (
                      console.warn('THREE.Curve: .getPoint() not implemented.'),
                      null
                    )
                  },
                  getPointAt: function (t, e) {
                    var n = this.getUtoTmapping(t)
                    return this.getPoint(n, e)
                  },
                  getPoints: function (t) {
                    void 0 === t && (t = 5)
                    for (var e = [], n = 0; n <= t; n++)
                      e.push(this.getPoint(n / t))
                    return e
                  },
                  getSpacedPoints: function (t) {
                    void 0 === t && (t = 5)
                    for (var e = [], n = 0; n <= t; n++)
                      e.push(this.getPointAt(n / t))
                    return e
                  },
                  getLength: function () {
                    var t = this.getLengths()
                    return t[t.length - 1]
                  },
                  getLengths: function (t) {
                    if (
                      (void 0 === t && (t = this.arcLengthDivisions),
                      this.cacheArcLengths &&
                        this.cacheArcLengths.length === t + 1 &&
                        !this.needsUpdate)
                    )
                      return this.cacheArcLengths
                    this.needsUpdate = !1
                    var e,
                      n = [],
                      r = this.getPoint(0),
                      i = 0
                    n.push(0)
                    for (var a = 1; a <= t; a++)
                      (i += (e = this.getPoint(a / t)).distanceTo(r)),
                        n.push(i),
                        (r = e)
                    return (this.cacheArcLengths = n)
                  },
                  updateArcLengths: function () {
                    ;(this.needsUpdate = !0), this.getLengths()
                  },
                  getUtoTmapping: function (t, e) {
                    for (
                      var n,
                        r = this.getLengths(),
                        i = 0,
                        a = r.length,
                        o = e || t * r[a - 1],
                        s = 0,
                        c = a - 1;
                      s <= c;

                    )
                      if ((n = r[(i = Math.floor(s + (c - s) / 2))] - o) < 0)
                        s = i + 1
                      else {
                        if (!(0 < n)) {
                          c = i
                          break
                        }
                        c = i - 1
                      }
                    if (r[(i = c)] === o) return i / (a - 1)
                    var l = r[i]
                    return (i + (o - l) / (r[i + 1] - l)) / (a - 1)
                  },
                  getTangent: function (t, e) {
                    var n = t - 1e-4,
                      r = t + 1e-4
                    n < 0 && (n = 0), 1 < r && (r = 1)
                    var i = this.getPoint(n),
                      a = this.getPoint(r),
                      o = e || new (i.isVector2 ? Ye : on)()
                    return o.copy(a).sub(i).normalize(), o
                  },
                  getTangentAt: function (t, e) {
                    var n = this.getUtoTmapping(t)
                    return this.getTangent(n, e)
                  },
                  computeFrenetFrames: function (t, e) {
                    for (
                      var n = new on(),
                        r = [],
                        i = [],
                        a = [],
                        o = new on(),
                        s = new fn(),
                        c = 0;
                      c <= t;
                      c++
                    ) {
                      var l = c / t
                      ;(r[c] = this.getTangentAt(l, new on())), r[c].normalize()
                    }
                    ;(i[0] = new on()), (a[0] = new on())
                    var h = Number.MAX_VALUE,
                      u = Math.abs(r[0].x),
                      p = Math.abs(r[0].y),
                      d = Math.abs(r[0].z)
                    u <= h && ((h = u), n.set(1, 0, 0)),
                      p <= h && ((h = p), n.set(0, 1, 0)),
                      d <= h && n.set(0, 0, 1),
                      o.crossVectors(r[0], n).normalize(),
                      i[0].crossVectors(r[0], o),
                      a[0].crossVectors(r[0], i[0])
                    for (var f, m = 1; m <= t; m++) {
                      ;(i[m] = i[m - 1].clone()),
                        (a[m] = a[m - 1].clone()),
                        o.crossVectors(r[m - 1], r[m]),
                        o.length() > Number.EPSILON &&
                          (o.normalize(),
                          (f = Math.acos(Xe.clamp(r[m - 1].dot(r[m]), -1, 1))),
                          i[m].applyMatrix4(s.makeRotationAxis(o, f))),
                        a[m].crossVectors(r[m], i[m])
                    }
                    if (!0 === e) {
                      var v = Math.acos(Xe.clamp(i[0].dot(i[t]), -1, 1))
                      ;(v /= t),
                        0 < r[0].dot(o.crossVectors(i[0], i[t])) && (v = -v)
                      for (var g = 1; g <= t; g++)
                        i[g].applyMatrix4(s.makeRotationAxis(r[g], v * g)),
                          a[g].crossVectors(r[g], i[g])
                    }
                    return { tangents: r, normals: i, binormals: a }
                  },
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                  copy: function (t) {
                    return (
                      (this.arcLengthDivisions = t.arcLengthDivisions), this
                    )
                  },
                  toJSON: function () {
                    var t = {
                      metadata: {
                        version: 4.5,
                        type: 'Curve',
                        generator: 'Curve.toJSON',
                      },
                    }
                    return (
                      (t.arcLengthDivisions = this.arcLengthDivisions),
                      (t.type = this.type),
                      t
                    )
                  },
                  fromJSON: function (t) {
                    return (
                      (this.arcLengthDivisions = t.arcLengthDivisions), this
                    )
                  },
                }),
                (((Zl.prototype = Object.create(Yl.prototype)).constructor =
                  Zl).prototype.isEllipseCurve = !0),
                (Zl.prototype.getPoint = function (t, e) {
                  for (
                    var n = e || new Ye(),
                      r = 2 * Math.PI,
                      i = this.aEndAngle - this.aStartAngle,
                      a = Math.abs(i) < Number.EPSILON;
                    i < 0;

                  )
                    i += r
                  for (; r < i; ) i -= r
                  i < Number.EPSILON && (i = a ? 0 : r),
                    !0 !== this.aClockwise ||
                      a ||
                      (i === r ? (i = -r) : (i -= r))
                  var o,
                    s,
                    c,
                    l,
                    h = this.aStartAngle + t * i,
                    u = this.aX + this.xRadius * Math.cos(h),
                    p = this.aY + this.yRadius * Math.sin(h)
                  return (
                    0 !== this.aRotation &&
                      ((o = Math.cos(this.aRotation)),
                      (s = Math.sin(this.aRotation)),
                      (u =
                        (c = u - this.aX) * o -
                        (l = p - this.aY) * s +
                        this.aX),
                      (p = c * s + l * o + this.aY)),
                    n.set(u, p)
                  )
                }),
                (Zl.prototype.copy = function (t) {
                  return (
                    Yl.prototype.copy.call(this, t),
                    (this.aX = t.aX),
                    (this.aY = t.aY),
                    (this.xRadius = t.xRadius),
                    (this.yRadius = t.yRadius),
                    (this.aStartAngle = t.aStartAngle),
                    (this.aEndAngle = t.aEndAngle),
                    (this.aClockwise = t.aClockwise),
                    (this.aRotation = t.aRotation),
                    this
                  )
                }),
                (Zl.prototype.toJSON = function () {
                  var t = Yl.prototype.toJSON.call(this)
                  return (
                    (t.aX = this.aX),
                    (t.aY = this.aY),
                    (t.xRadius = this.xRadius),
                    (t.yRadius = this.yRadius),
                    (t.aStartAngle = this.aStartAngle),
                    (t.aEndAngle = this.aEndAngle),
                    (t.aClockwise = this.aClockwise),
                    (t.aRotation = this.aRotation),
                    t
                  )
                }),
                (Zl.prototype.fromJSON = function (t) {
                  return (
                    Yl.prototype.fromJSON.call(this, t),
                    (this.aX = t.aX),
                    (this.aY = t.aY),
                    (this.xRadius = t.xRadius),
                    (this.yRadius = t.yRadius),
                    (this.aStartAngle = t.aStartAngle),
                    (this.aEndAngle = t.aEndAngle),
                    (this.aClockwise = t.aClockwise),
                    (this.aRotation = t.aRotation),
                    this
                  )
                }),
                (((Jl.prototype = Object.create(Zl.prototype)).constructor =
                  Jl).prototype.isArcCurve = !0)
              var Kl = new on(),
                $l = new Ql(),
                th = new Ql(),
                eh = new Ql()
              function nh(t, e, n, r) {
                Yl.call(this),
                  (this.type = 'CatmullRomCurve3'),
                  (this.points = t || []),
                  (this.closed = e || !1),
                  (this.curveType = n || 'centripetal'),
                  (this.tension = r || 0.5)
              }
              function rh(t, e, n, r, i) {
                var a = 0.5 * (r - e),
                  o = 0.5 * (i - n),
                  s = t * t
                return (
                  (2 * n - 2 * r + a + o) * (t * s) +
                  (-3 * n + 3 * r - 2 * a - o) * s +
                  a * t +
                  n
                )
              }
              function ih(t, e, n, r) {
                return (
                  (o = 1 - t) * o * e +
                  2 * (1 - (a = t)) * a * n +
                  (i = t) * i * r
                )
                var i, a, o
              }
              function ah(t, e, n, r, i) {
                return (
                  (l = 1 - t) * l * l * e +
                  3 * (c = 1 - (s = t)) * c * s * n +
                  3 * (1 - (o = t)) * o * o * r +
                  (a = t) * a * a * i
                )
                var a, o, s, c, l
              }
              function oh(t, e, n, r) {
                Yl.call(this),
                  (this.type = 'CubicBezierCurve'),
                  (this.v0 = t || new Ye()),
                  (this.v1 = e || new Ye()),
                  (this.v2 = n || new Ye()),
                  (this.v3 = r || new Ye())
              }
              function sh(t, e, n, r) {
                Yl.call(this),
                  (this.type = 'CubicBezierCurve3'),
                  (this.v0 = t || new on()),
                  (this.v1 = e || new on()),
                  (this.v2 = n || new on()),
                  (this.v3 = r || new on())
              }
              function ch(t, e) {
                Yl.call(this),
                  (this.type = 'LineCurve'),
                  (this.v1 = t || new Ye()),
                  (this.v2 = e || new Ye())
              }
              function lh(t, e) {
                Yl.call(this),
                  (this.type = 'LineCurve3'),
                  (this.v1 = t || new on()),
                  (this.v2 = e || new on())
              }
              function hh(t, e, n) {
                Yl.call(this),
                  (this.type = 'QuadraticBezierCurve'),
                  (this.v0 = t || new Ye()),
                  (this.v1 = e || new Ye()),
                  (this.v2 = n || new Ye())
              }
              function uh(t, e, n) {
                Yl.call(this),
                  (this.type = 'QuadraticBezierCurve3'),
                  (this.v0 = t || new on()),
                  (this.v1 = e || new on()),
                  (this.v2 = n || new on())
              }
              function ph(t) {
                Yl.call(this),
                  (this.type = 'SplineCurve'),
                  (this.points = t || [])
              }
              ;(((nh.prototype = Object.create(Yl.prototype)).constructor =
                nh).prototype.isCatmullRomCurve3 = !0),
                (nh.prototype.getPoint = function (t, e) {
                  var n,
                    r,
                    i,
                    a,
                    o,
                    s,
                    c,
                    l,
                    h = e || new on(),
                    u = this.points,
                    p = u.length,
                    d = (p - (this.closed ? 0 : 1)) * t,
                    f = Math.floor(d),
                    m = d - f
                  return (
                    this.closed
                      ? (f += 0 < f ? 0 : (Math.floor(Math.abs(f) / p) + 1) * p)
                      : 0 === m && f === p - 1 && ((f = p - 2), (m = 1)),
                    (n =
                      this.closed || 0 < f
                        ? u[(f - 1) % p]
                        : (Kl.subVectors(u[0], u[1]).add(u[0]), Kl)),
                    (r = u[f % p]),
                    (i = u[(f + 1) % p]),
                    (a =
                      this.closed || f + 2 < p
                        ? u[(f + 2) % p]
                        : (Kl.subVectors(u[p - 1], u[p - 2]).add(u[p - 1]),
                          Kl)),
                    'centripetal' === this.curveType ||
                    'chordal' === this.curveType
                      ? ((o = 'chordal' === this.curveType ? 0.5 : 0.25),
                        (s = Math.pow(n.distanceToSquared(r), o)),
                        (c = Math.pow(r.distanceToSquared(i), o)) < 1e-4 &&
                          (c = 1),
                        s < 1e-4 && (s = c),
                        (l = Math.pow(i.distanceToSquared(a), o)) < 1e-4 &&
                          (l = c),
                        $l.initNonuniformCatmullRom(
                          n.x,
                          r.x,
                          i.x,
                          a.x,
                          s,
                          c,
                          l,
                        ),
                        th.initNonuniformCatmullRom(
                          n.y,
                          r.y,
                          i.y,
                          a.y,
                          s,
                          c,
                          l,
                        ),
                        eh.initNonuniformCatmullRom(
                          n.z,
                          r.z,
                          i.z,
                          a.z,
                          s,
                          c,
                          l,
                        ))
                      : 'catmullrom' === this.curveType &&
                        ($l.initCatmullRom(n.x, r.x, i.x, a.x, this.tension),
                        th.initCatmullRom(n.y, r.y, i.y, a.y, this.tension),
                        eh.initCatmullRom(n.z, r.z, i.z, a.z, this.tension)),
                    h.set($l.calc(m), th.calc(m), eh.calc(m)),
                    h
                  )
                }),
                (nh.prototype.copy = function (t) {
                  Yl.prototype.copy.call(this, t), (this.points = [])
                  for (var e = 0, n = t.points.length; e < n; e++) {
                    var r = t.points[e]
                    this.points.push(r.clone())
                  }
                  return (
                    (this.closed = t.closed),
                    (this.curveType = t.curveType),
                    (this.tension = t.tension),
                    this
                  )
                }),
                (nh.prototype.toJSON = function () {
                  var t = Yl.prototype.toJSON.call(this)
                  t.points = []
                  for (var e = 0, n = this.points.length; e < n; e++) {
                    var r = this.points[e]
                    t.points.push(r.toArray())
                  }
                  return (
                    (t.closed = this.closed),
                    (t.curveType = this.curveType),
                    (t.tension = this.tension),
                    t
                  )
                }),
                (nh.prototype.fromJSON = function (t) {
                  Yl.prototype.fromJSON.call(this, t), (this.points = [])
                  for (var e = 0, n = t.points.length; e < n; e++) {
                    var r = t.points[e]
                    this.points.push(new on().fromArray(r))
                  }
                  return (
                    (this.closed = t.closed),
                    (this.curveType = t.curveType),
                    (this.tension = t.tension),
                    this
                  )
                }),
                (((oh.prototype = Object.create(Yl.prototype)).constructor =
                  oh).prototype.isCubicBezierCurve = !0),
                (oh.prototype.getPoint = function (t, e) {
                  var n = e || new Ye(),
                    r = this.v0,
                    i = this.v1,
                    a = this.v2,
                    o = this.v3
                  return (
                    n.set(ah(t, r.x, i.x, a.x, o.x), ah(t, r.y, i.y, a.y, o.y)),
                    n
                  )
                }),
                (oh.prototype.copy = function (t) {
                  return (
                    Yl.prototype.copy.call(this, t),
                    this.v0.copy(t.v0),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this.v3.copy(t.v3),
                    this
                  )
                }),
                (oh.prototype.toJSON = function () {
                  var t = Yl.prototype.toJSON.call(this)
                  return (
                    (t.v0 = this.v0.toArray()),
                    (t.v1 = this.v1.toArray()),
                    (t.v2 = this.v2.toArray()),
                    (t.v3 = this.v3.toArray()),
                    t
                  )
                }),
                (oh.prototype.fromJSON = function (t) {
                  return (
                    Yl.prototype.fromJSON.call(this, t),
                    this.v0.fromArray(t.v0),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this.v3.fromArray(t.v3),
                    this
                  )
                }),
                (((sh.prototype = Object.create(Yl.prototype)).constructor =
                  sh).prototype.isCubicBezierCurve3 = !0),
                (sh.prototype.getPoint = function (t, e) {
                  var n = e || new on(),
                    r = this.v0,
                    i = this.v1,
                    a = this.v2,
                    o = this.v3
                  return (
                    n.set(
                      ah(t, r.x, i.x, a.x, o.x),
                      ah(t, r.y, i.y, a.y, o.y),
                      ah(t, r.z, i.z, a.z, o.z),
                    ),
                    n
                  )
                }),
                (sh.prototype.copy = function (t) {
                  return (
                    Yl.prototype.copy.call(this, t),
                    this.v0.copy(t.v0),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this.v3.copy(t.v3),
                    this
                  )
                }),
                (sh.prototype.toJSON = function () {
                  var t = Yl.prototype.toJSON.call(this)
                  return (
                    (t.v0 = this.v0.toArray()),
                    (t.v1 = this.v1.toArray()),
                    (t.v2 = this.v2.toArray()),
                    (t.v3 = this.v3.toArray()),
                    t
                  )
                }),
                (sh.prototype.fromJSON = function (t) {
                  return (
                    Yl.prototype.fromJSON.call(this, t),
                    this.v0.fromArray(t.v0),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this.v3.fromArray(t.v3),
                    this
                  )
                }),
                (((ch.prototype = Object.create(Yl.prototype)).constructor =
                  ch).prototype.isLineCurve = !0),
                (ch.prototype.getPoint = function (t, e) {
                  var n = e || new Ye()
                  return (
                    1 === t
                      ? n.copy(this.v2)
                      : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(t).add(this.v1)),
                    n
                  )
                }),
                (ch.prototype.getPointAt = function (t, e) {
                  return this.getPoint(t, e)
                }),
                (ch.prototype.getTangent = function (t, e) {
                  var n = e || new Ye()
                  return n.copy(this.v2).sub(this.v1).normalize(), n
                }),
                (ch.prototype.copy = function (t) {
                  return (
                    Yl.prototype.copy.call(this, t),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
                  )
                }),
                (ch.prototype.toJSON = function () {
                  var t = Yl.prototype.toJSON.call(this)
                  return (
                    (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
                  )
                }),
                (ch.prototype.fromJSON = function (t) {
                  return (
                    Yl.prototype.fromJSON.call(this, t),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
                  )
                }),
                (((lh.prototype = Object.create(Yl.prototype)).constructor =
                  lh).prototype.isLineCurve3 = !0),
                (lh.prototype.getPoint = function (t, e) {
                  var n = e || new on()
                  return (
                    1 === t
                      ? n.copy(this.v2)
                      : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(t).add(this.v1)),
                    n
                  )
                }),
                (lh.prototype.getPointAt = function (t, e) {
                  return this.getPoint(t, e)
                }),
                (lh.prototype.copy = function (t) {
                  return (
                    Yl.prototype.copy.call(this, t),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
                  )
                }),
                (lh.prototype.toJSON = function () {
                  var t = Yl.prototype.toJSON.call(this)
                  return (
                    (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t
                  )
                }),
                (lh.prototype.fromJSON = function (t) {
                  return (
                    Yl.prototype.fromJSON.call(this, t),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
                  )
                }),
                (((hh.prototype = Object.create(Yl.prototype)).constructor =
                  hh).prototype.isQuadraticBezierCurve = !0),
                (hh.prototype.getPoint = function (t, e) {
                  var n = e || new Ye(),
                    r = this.v0,
                    i = this.v1,
                    a = this.v2
                  return n.set(ih(t, r.x, i.x, a.x), ih(t, r.y, i.y, a.y)), n
                }),
                (hh.prototype.copy = function (t) {
                  return (
                    Yl.prototype.copy.call(this, t),
                    this.v0.copy(t.v0),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
                  )
                }),
                (hh.prototype.toJSON = function () {
                  var t = Yl.prototype.toJSON.call(this)
                  return (
                    (t.v0 = this.v0.toArray()),
                    (t.v1 = this.v1.toArray()),
                    (t.v2 = this.v2.toArray()),
                    t
                  )
                }),
                (hh.prototype.fromJSON = function (t) {
                  return (
                    Yl.prototype.fromJSON.call(this, t),
                    this.v0.fromArray(t.v0),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
                  )
                }),
                (((uh.prototype = Object.create(Yl.prototype)).constructor =
                  uh).prototype.isQuadraticBezierCurve3 = !0),
                (uh.prototype.getPoint = function (t, e) {
                  var n = e || new on(),
                    r = this.v0,
                    i = this.v1,
                    a = this.v2
                  return (
                    n.set(
                      ih(t, r.x, i.x, a.x),
                      ih(t, r.y, i.y, a.y),
                      ih(t, r.z, i.z, a.z),
                    ),
                    n
                  )
                }),
                (uh.prototype.copy = function (t) {
                  return (
                    Yl.prototype.copy.call(this, t),
                    this.v0.copy(t.v0),
                    this.v1.copy(t.v1),
                    this.v2.copy(t.v2),
                    this
                  )
                }),
                (uh.prototype.toJSON = function () {
                  var t = Yl.prototype.toJSON.call(this)
                  return (
                    (t.v0 = this.v0.toArray()),
                    (t.v1 = this.v1.toArray()),
                    (t.v2 = this.v2.toArray()),
                    t
                  )
                }),
                (uh.prototype.fromJSON = function (t) {
                  return (
                    Yl.prototype.fromJSON.call(this, t),
                    this.v0.fromArray(t.v0),
                    this.v1.fromArray(t.v1),
                    this.v2.fromArray(t.v2),
                    this
                  )
                }),
                (((ph.prototype = Object.create(Yl.prototype)).constructor =
                  ph).prototype.isSplineCurve = !0),
                (ph.prototype.getPoint = function (t, e) {
                  var n = e || new Ye(),
                    r = this.points,
                    i = (r.length - 1) * t,
                    a = Math.floor(i),
                    o = i - a,
                    s = r[0 === a ? a : a - 1],
                    c = r[a],
                    l = r[a > r.length - 2 ? r.length - 1 : a + 1],
                    h = r[a > r.length - 3 ? r.length - 1 : a + 2]
                  return (
                    n.set(rh(o, s.x, c.x, l.x, h.x), rh(o, s.y, c.y, l.y, h.y)),
                    n
                  )
                }),
                (ph.prototype.copy = function (t) {
                  Yl.prototype.copy.call(this, t), (this.points = [])
                  for (var e = 0, n = t.points.length; e < n; e++) {
                    var r = t.points[e]
                    this.points.push(r.clone())
                  }
                  return this
                }),
                (ph.prototype.toJSON = function () {
                  var t = Yl.prototype.toJSON.call(this)
                  t.points = []
                  for (var e = 0, n = this.points.length; e < n; e++) {
                    var r = this.points[e]
                    t.points.push(r.toArray())
                  }
                  return t
                }),
                (ph.prototype.fromJSON = function (t) {
                  Yl.prototype.fromJSON.call(this, t), (this.points = [])
                  for (var e = 0, n = t.points.length; e < n; e++) {
                    var r = t.points[e]
                    this.points.push(new Ye().fromArray(r))
                  }
                  return this
                })
              var dh = Object.freeze({
                __proto__: null,
                ArcCurve: Jl,
                CatmullRomCurve3: nh,
                CubicBezierCurve: oh,
                CubicBezierCurve3: sh,
                EllipseCurve: Zl,
                LineCurve: ch,
                LineCurve3: lh,
                QuadraticBezierCurve: hh,
                QuadraticBezierCurve3: uh,
                SplineCurve: ph,
              })
              function fh() {
                Yl.call(this),
                  (this.type = 'CurvePath'),
                  (this.curves = []),
                  (this.autoClose = !1)
              }
              function mh(t) {
                fh.call(this),
                  (this.type = 'Path'),
                  (this.currentPoint = new Ye()),
                  t && this.setFromPoints(t)
              }
              function vh(t) {
                mh.call(this, t),
                  (this.uuid = Xe.generateUUID()),
                  (this.type = 'Shape'),
                  (this.holes = [])
              }
              function gh(t, e) {
                On.call(this),
                  (this.type = 'Light'),
                  (this.color = new Mr(t)),
                  (this.intensity = void 0 !== e ? e : 1),
                  (this.receiveShadow = void 0)
              }
              function yh(t, e, n) {
                gh.call(this, t, n),
                  (this.type = 'HemisphereLight'),
                  (this.castShadow = void 0),
                  this.position.copy(On.DefaultUp),
                  this.updateMatrix(),
                  (this.groundColor = new Mr(e))
              }
              function xh(t) {
                ;(this.camera = t),
                  (this.bias = 0),
                  (this.normalBias = 0),
                  (this.radius = 1),
                  (this.mapSize = new Ye(512, 512)),
                  (this.map = null),
                  (this.mapPass = null),
                  (this.matrix = new fn()),
                  (this.autoUpdate = !0),
                  (this.needsUpdate = !1),
                  (this._frustum = new Fi()),
                  (this._frameExtents = new Ye(1, 1)),
                  (this._viewportCount = 1),
                  (this._viewports = [new $e(0, 0, 1, 1)])
              }
              function bh() {
                xh.call(this, new Ii(50, 1, 0.5, 500))
              }
              function _h(t, e, n, r, i, a) {
                gh.call(this, t, e),
                  (this.type = 'SpotLight'),
                  this.position.copy(On.DefaultUp),
                  this.updateMatrix(),
                  (this.target = new On()),
                  Object.defineProperty(this, 'power', {
                    get: function () {
                      return this.intensity * Math.PI
                    },
                    set: function (t) {
                      this.intensity = t / Math.PI
                    },
                  }),
                  (this.distance = void 0 !== n ? n : 0),
                  (this.angle = void 0 !== r ? r : Math.PI / 3),
                  (this.penumbra = void 0 !== i ? i : 0),
                  (this.decay = void 0 !== a ? a : 1),
                  (this.shadow = new bh())
              }
              function wh() {
                xh.call(this, new Ii(90, 1, 0.5, 500)),
                  (this._frameExtents = new Ye(4, 2)),
                  (this._viewportCount = 6),
                  (this._viewports = [
                    new $e(2, 1, 1, 1),
                    new $e(0, 1, 1, 1),
                    new $e(3, 1, 1, 1),
                    new $e(1, 1, 1, 1),
                    new $e(3, 0, 1, 1),
                    new $e(1, 0, 1, 1),
                  ]),
                  (this._cubeDirections = [
                    new on(1, 0, 0),
                    new on(-1, 0, 0),
                    new on(0, 0, 1),
                    new on(0, 0, -1),
                    new on(0, 1, 0),
                    new on(0, -1, 0),
                  ]),
                  (this._cubeUps = [
                    new on(0, 1, 0),
                    new on(0, 1, 0),
                    new on(0, 1, 0),
                    new on(0, 1, 0),
                    new on(0, 0, 1),
                    new on(0, 0, -1),
                  ])
              }
              function Mh(t, e, n, r) {
                gh.call(this, t, e),
                  (this.type = 'PointLight'),
                  Object.defineProperty(this, 'power', {
                    get: function () {
                      return 4 * this.intensity * Math.PI
                    },
                    set: function (t) {
                      this.intensity = t / (4 * Math.PI)
                    },
                  }),
                  (this.distance = void 0 !== n ? n : 0),
                  (this.decay = void 0 !== r ? r : 1),
                  (this.shadow = new wh())
              }
              function Sh(t, e, n, r, i, a) {
                Oi.call(this),
                  (this.type = 'OrthographicCamera'),
                  (this.zoom = 1),
                  (this.view = null),
                  (this.left = void 0 !== t ? t : -1),
                  (this.right = void 0 !== e ? e : 1),
                  (this.top = void 0 !== n ? n : 1),
                  (this.bottom = void 0 !== r ? r : -1),
                  (this.near = void 0 !== i ? i : 0.1),
                  (this.far = void 0 !== a ? a : 2e3),
                  this.updateProjectionMatrix()
              }
              function Eh() {
                xh.call(this, new Sh(-5, 5, 5, -5, 0.5, 500))
              }
              function Th(t, e) {
                gh.call(this, t, e),
                  (this.type = 'DirectionalLight'),
                  this.position.copy(On.DefaultUp),
                  this.updateMatrix(),
                  (this.target = new On()),
                  (this.shadow = new Eh())
              }
              function Ah(t, e) {
                gh.call(this, t, e),
                  (this.type = 'AmbientLight'),
                  (this.castShadow = void 0)
              }
              function Lh(t, e, n, r) {
                gh.call(this, t, e),
                  (this.type = 'RectAreaLight'),
                  (this.width = void 0 !== n ? n : 10),
                  (this.height = void 0 !== r ? r : 10)
              }
              function Rh() {
                this.coefficients = []
                for (var t = 0; t < 9; t++) this.coefficients.push(new on())
              }
              function Ch(t, e) {
                gh.call(this, void 0, e),
                  (this.type = 'LightProbe'),
                  (this.sh = void 0 !== t ? t : new Rh())
              }
              function Ph(t) {
                Fl.call(this, t), (this.textures = {})
              }
              ;(fh.prototype = Object.assign(Object.create(Yl.prototype), {
                constructor: fh,
                add: function (t) {
                  this.curves.push(t)
                },
                closePath: function () {
                  var t = this.curves[0].getPoint(0),
                    e = this.curves[this.curves.length - 1].getPoint(1)
                  t.equals(e) || this.curves.push(new ch(e, t))
                },
                getPoint: function (t) {
                  for (
                    var e = t * this.getLength(),
                      n = this.getCurveLengths(),
                      r = 0;
                    r < n.length;

                  ) {
                    if (n[r] >= e) {
                      var i = n[r] - e,
                        a = this.curves[r],
                        o = a.getLength(),
                        s = 0 === o ? 0 : 1 - i / o
                      return a.getPointAt(s)
                    }
                    r++
                  }
                  return null
                },
                getLength: function () {
                  var t = this.getCurveLengths()
                  return t[t.length - 1]
                },
                updateArcLengths: function () {
                  ;(this.needsUpdate = !0),
                    (this.cacheLengths = null),
                    this.getCurveLengths()
                },
                getCurveLengths: function () {
                  if (
                    this.cacheLengths &&
                    this.cacheLengths.length === this.curves.length
                  )
                    return this.cacheLengths
                  for (
                    var t = [], e = 0, n = 0, r = this.curves.length;
                    n < r;
                    n++
                  )
                    (e += this.curves[n].getLength()), t.push(e)
                  return (this.cacheLengths = t)
                },
                getSpacedPoints: function (t) {
                  void 0 === t && (t = 40)
                  for (var e = [], n = 0; n <= t; n++)
                    e.push(this.getPoint(n / t))
                  return this.autoClose && e.push(e[0]), e
                },
                getPoints: function (t) {
                  t = t || 12
                  for (var e, n = [], r = 0, i = this.curves; r < i.length; r++)
                    for (
                      var a = i[r],
                        o =
                          a && a.isEllipseCurve
                            ? 2 * t
                            : a && (a.isLineCurve || a.isLineCurve3)
                              ? 1
                              : a && a.isSplineCurve
                                ? t * a.points.length
                                : t,
                        s = a.getPoints(o),
                        c = 0;
                      c < s.length;
                      c++
                    ) {
                      var l = s[c]
                      ;(e && e.equals(l)) || (n.push(l), (e = l))
                    }
                  return (
                    this.autoClose &&
                      1 < n.length &&
                      !n[n.length - 1].equals(n[0]) &&
                      n.push(n[0]),
                    n
                  )
                },
                copy: function (t) {
                  Yl.prototype.copy.call(this, t), (this.curves = [])
                  for (var e = 0, n = t.curves.length; e < n; e++) {
                    var r = t.curves[e]
                    this.curves.push(r.clone())
                  }
                  return (this.autoClose = t.autoClose), this
                },
                toJSON: function () {
                  var t = Yl.prototype.toJSON.call(this)
                  ;(t.autoClose = this.autoClose), (t.curves = [])
                  for (var e = 0, n = this.curves.length; e < n; e++) {
                    var r = this.curves[e]
                    t.curves.push(r.toJSON())
                  }
                  return t
                },
                fromJSON: function (t) {
                  Yl.prototype.fromJSON.call(this, t),
                    (this.autoClose = t.autoClose),
                    (this.curves = [])
                  for (var e = 0, n = t.curves.length; e < n; e++) {
                    var r = t.curves[e]
                    this.curves.push(new dh[r.type]().fromJSON(r))
                  }
                  return this
                },
              })),
                (mh.prototype = Object.assign(Object.create(fh.prototype), {
                  constructor: mh,
                  setFromPoints: function (t) {
                    this.moveTo(t[0].x, t[0].y)
                    for (var e = 1, n = t.length; e < n; e++)
                      this.lineTo(t[e].x, t[e].y)
                    return this
                  },
                  moveTo: function (t, e) {
                    return this.currentPoint.set(t, e), this
                  },
                  lineTo: function (t, e) {
                    var n = new ch(this.currentPoint.clone(), new Ye(t, e))
                    return (
                      this.curves.push(n), this.currentPoint.set(t, e), this
                    )
                  },
                  quadraticCurveTo: function (t, e, n, r) {
                    var i = new hh(
                      this.currentPoint.clone(),
                      new Ye(t, e),
                      new Ye(n, r),
                    )
                    return (
                      this.curves.push(i), this.currentPoint.set(n, r), this
                    )
                  },
                  bezierCurveTo: function (t, e, n, r, i, a) {
                    var o = new oh(
                      this.currentPoint.clone(),
                      new Ye(t, e),
                      new Ye(n, r),
                      new Ye(i, a),
                    )
                    return (
                      this.curves.push(o), this.currentPoint.set(i, a), this
                    )
                  },
                  splineThru: function (t) {
                    var e = new ph([this.currentPoint.clone()].concat(t))
                    return (
                      this.curves.push(e),
                      this.currentPoint.copy(t[t.length - 1]),
                      this
                    )
                  },
                  arc: function (t, e, n, r, i, a) {
                    var o = this.currentPoint.x,
                      s = this.currentPoint.y
                    return this.absarc(t + o, e + s, n, r, i, a), this
                  },
                  absarc: function (t, e, n, r, i, a) {
                    return this.absellipse(t, e, n, n, r, i, a), this
                  },
                  ellipse: function (t, e, n, r, i, a, o, s) {
                    var c = this.currentPoint.x,
                      l = this.currentPoint.y
                    return this.absellipse(t + c, e + l, n, r, i, a, o, s), this
                  },
                  absellipse: function (t, e, n, r, i, a, o, s) {
                    var c,
                      l = new Zl(t, e, n, r, i, a, o, s)
                    0 < this.curves.length &&
                      ((c = l.getPoint(0)).equals(this.currentPoint) ||
                        this.lineTo(c.x, c.y)),
                      this.curves.push(l)
                    var h = l.getPoint(1)
                    return this.currentPoint.copy(h), this
                  },
                  copy: function (t) {
                    return (
                      fh.prototype.copy.call(this, t),
                      this.currentPoint.copy(t.currentPoint),
                      this
                    )
                  },
                  toJSON: function () {
                    var t = fh.prototype.toJSON.call(this)
                    return (t.currentPoint = this.currentPoint.toArray()), t
                  },
                  fromJSON: function (t) {
                    return (
                      fh.prototype.fromJSON.call(this, t),
                      this.currentPoint.fromArray(t.currentPoint),
                      this
                    )
                  },
                })),
                (vh.prototype = Object.assign(Object.create(mh.prototype), {
                  constructor: vh,
                  getPointsHoles: function (t) {
                    for (var e = [], n = 0, r = this.holes.length; n < r; n++)
                      e[n] = this.holes[n].getPoints(t)
                    return e
                  },
                  extractPoints: function (t) {
                    return {
                      shape: this.getPoints(t),
                      holes: this.getPointsHoles(t),
                    }
                  },
                  copy: function (t) {
                    mh.prototype.copy.call(this, t), (this.holes = [])
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                      var r = t.holes[e]
                      this.holes.push(r.clone())
                    }
                    return this
                  },
                  toJSON: function () {
                    var t = mh.prototype.toJSON.call(this)
                    ;(t.uuid = this.uuid), (t.holes = [])
                    for (var e = 0, n = this.holes.length; e < n; e++) {
                      var r = this.holes[e]
                      t.holes.push(r.toJSON())
                    }
                    return t
                  },
                  fromJSON: function (t) {
                    mh.prototype.fromJSON.call(this, t),
                      (this.uuid = t.uuid),
                      (this.holes = [])
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                      var r = t.holes[e]
                      this.holes.push(new mh().fromJSON(r))
                    }
                    return this
                  },
                })),
                (gh.prototype = Object.assign(Object.create(On.prototype), {
                  constructor: gh,
                  isLight: !0,
                  copy: function (t) {
                    return (
                      On.prototype.copy.call(this, t),
                      this.color.copy(t.color),
                      (this.intensity = t.intensity),
                      this
                    )
                  },
                  toJSON: function (t) {
                    var e = On.prototype.toJSON.call(this, t)
                    return (
                      (e.object.color = this.color.getHex()),
                      (e.object.intensity = this.intensity),
                      void 0 !== this.groundColor &&
                        (e.object.groundColor = this.groundColor.getHex()),
                      void 0 !== this.distance &&
                        (e.object.distance = this.distance),
                      void 0 !== this.angle && (e.object.angle = this.angle),
                      void 0 !== this.decay && (e.object.decay = this.decay),
                      void 0 !== this.penumbra &&
                        (e.object.penumbra = this.penumbra),
                      void 0 !== this.shadow &&
                        (e.object.shadow = this.shadow.toJSON()),
                      e
                    )
                  },
                })),
                (yh.prototype = Object.assign(Object.create(gh.prototype), {
                  constructor: yh,
                  isHemisphereLight: !0,
                  copy: function (t) {
                    return (
                      gh.prototype.copy.call(this, t),
                      this.groundColor.copy(t.groundColor),
                      this
                    )
                  },
                })),
                Object.assign(xh.prototype, {
                  _projScreenMatrix: new fn(),
                  _lightPositionWorld: new on(),
                  _lookTarget: new on(),
                  getViewportCount: function () {
                    return this._viewportCount
                  },
                  getFrustum: function () {
                    return this._frustum
                  },
                  updateMatrices: function (t) {
                    var e = this.camera,
                      n = this.matrix,
                      r = this._projScreenMatrix,
                      i = this._lookTarget,
                      a = this._lightPositionWorld
                    a.setFromMatrixPosition(t.matrixWorld),
                      e.position.copy(a),
                      i.setFromMatrixPosition(t.target.matrixWorld),
                      e.lookAt(i),
                      e.updateMatrixWorld(),
                      r.multiplyMatrices(
                        e.projectionMatrix,
                        e.matrixWorldInverse,
                      ),
                      this._frustum.setFromProjectionMatrix(r),
                      n.set(
                        0.5,
                        0,
                        0,
                        0.5,
                        0,
                        0.5,
                        0,
                        0.5,
                        0,
                        0,
                        0.5,
                        0.5,
                        0,
                        0,
                        0,
                        1,
                      ),
                      n.multiply(e.projectionMatrix),
                      n.multiply(e.matrixWorldInverse)
                  },
                  getViewport: function (t) {
                    return this._viewports[t]
                  },
                  getFrameExtents: function () {
                    return this._frameExtents
                  },
                  copy: function (t) {
                    return (
                      (this.camera = t.camera.clone()),
                      (this.bias = t.bias),
                      (this.radius = t.radius),
                      this.mapSize.copy(t.mapSize),
                      this
                    )
                  },
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                  toJSON: function () {
                    var t = {}
                    return (
                      0 !== this.bias && (t.bias = this.bias),
                      0 !== this.normalBias && (t.normalBias = this.normalBias),
                      1 !== this.radius && (t.radius = this.radius),
                      (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                        (t.mapSize = this.mapSize.toArray()),
                      (t.camera = this.camera.toJSON(!1).object),
                      delete t.camera.matrix,
                      t
                    )
                  },
                }),
                (bh.prototype = Object.assign(Object.create(xh.prototype), {
                  constructor: bh,
                  isSpotLightShadow: !0,
                  updateMatrices: function (t) {
                    var e = this.camera,
                      n = 2 * Xe.RAD2DEG * t.angle,
                      r = this.mapSize.width / this.mapSize.height,
                      i = t.distance || e.far
                    ;(n === e.fov && r === e.aspect && i === e.far) ||
                      ((e.fov = n),
                      (e.aspect = r),
                      (e.far = i),
                      e.updateProjectionMatrix()),
                      xh.prototype.updateMatrices.call(this, t)
                  },
                })),
                (_h.prototype = Object.assign(Object.create(gh.prototype), {
                  constructor: _h,
                  isSpotLight: !0,
                  copy: function (t) {
                    return (
                      gh.prototype.copy.call(this, t),
                      (this.distance = t.distance),
                      (this.angle = t.angle),
                      (this.penumbra = t.penumbra),
                      (this.decay = t.decay),
                      (this.target = t.target.clone()),
                      (this.shadow = t.shadow.clone()),
                      this
                    )
                  },
                })),
                (wh.prototype = Object.assign(Object.create(xh.prototype), {
                  constructor: wh,
                  isPointLightShadow: !0,
                  updateMatrices: function (t, e) {
                    void 0 === e && (e = 0)
                    var n = this.camera,
                      r = this.matrix,
                      i = this._lightPositionWorld,
                      a = this._lookTarget,
                      o = this._projScreenMatrix
                    i.setFromMatrixPosition(t.matrixWorld),
                      n.position.copy(i),
                      a.copy(n.position),
                      a.add(this._cubeDirections[e]),
                      n.up.copy(this._cubeUps[e]),
                      n.lookAt(a),
                      n.updateMatrixWorld(),
                      r.makeTranslation(-i.x, -i.y, -i.z),
                      o.multiplyMatrices(
                        n.projectionMatrix,
                        n.matrixWorldInverse,
                      ),
                      this._frustum.setFromProjectionMatrix(o)
                  },
                })),
                (Mh.prototype = Object.assign(Object.create(gh.prototype), {
                  constructor: Mh,
                  isPointLight: !0,
                  copy: function (t) {
                    return (
                      gh.prototype.copy.call(this, t),
                      (this.distance = t.distance),
                      (this.decay = t.decay),
                      (this.shadow = t.shadow.clone()),
                      this
                    )
                  },
                })),
                (Sh.prototype = Object.assign(Object.create(Oi.prototype), {
                  constructor: Sh,
                  isOrthographicCamera: !0,
                  copy: function (t, e) {
                    return (
                      Oi.prototype.copy.call(this, t, e),
                      (this.left = t.left),
                      (this.right = t.right),
                      (this.top = t.top),
                      (this.bottom = t.bottom),
                      (this.near = t.near),
                      (this.far = t.far),
                      (this.zoom = t.zoom),
                      (this.view =
                        null === t.view ? null : Object.assign({}, t.view)),
                      this
                    )
                  },
                  setViewOffset: function (t, e, n, r, i, a) {
                    null === this.view &&
                      (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1,
                      }),
                      (this.view.enabled = !0),
                      (this.view.fullWidth = t),
                      (this.view.fullHeight = e),
                      (this.view.offsetX = n),
                      (this.view.offsetY = r),
                      (this.view.width = i),
                      (this.view.height = a),
                      this.updateProjectionMatrix()
                  },
                  clearViewOffset: function () {
                    null !== this.view && (this.view.enabled = !1),
                      this.updateProjectionMatrix()
                  },
                  updateProjectionMatrix: function () {
                    var t,
                      e,
                      n = (this.right - this.left) / (2 * this.zoom),
                      r = (this.top - this.bottom) / (2 * this.zoom),
                      i = (this.right + this.left) / 2,
                      a = (this.top + this.bottom) / 2,
                      o = i - n,
                      s = i + n,
                      c = a + r,
                      l = a - r
                    null !== this.view &&
                      this.view.enabled &&
                      ((t =
                        (this.right - this.left) /
                        this.view.fullWidth /
                        this.zoom),
                      (e =
                        (this.top - this.bottom) /
                        this.view.fullHeight /
                        this.zoom),
                      (s = (o += t * this.view.offsetX) + t * this.view.width),
                      (l =
                        (c -= e * this.view.offsetY) - e * this.view.height)),
                      this.projectionMatrix.makeOrthographic(
                        o,
                        s,
                        c,
                        l,
                        this.near,
                        this.far,
                      ),
                      this.projectionMatrixInverse.getInverse(
                        this.projectionMatrix,
                      )
                  },
                  toJSON: function (t) {
                    var e = On.prototype.toJSON.call(this, t)
                    return (
                      (e.object.zoom = this.zoom),
                      (e.object.left = this.left),
                      (e.object.right = this.right),
                      (e.object.top = this.top),
                      (e.object.bottom = this.bottom),
                      (e.object.near = this.near),
                      (e.object.far = this.far),
                      null !== this.view &&
                        (e.object.view = Object.assign({}, this.view)),
                      e
                    )
                  },
                })),
                (Eh.prototype = Object.assign(Object.create(xh.prototype), {
                  constructor: Eh,
                  isDirectionalLightShadow: !0,
                  updateMatrices: function (t) {
                    xh.prototype.updateMatrices.call(this, t)
                  },
                })),
                (Th.prototype = Object.assign(Object.create(gh.prototype), {
                  constructor: Th,
                  isDirectionalLight: !0,
                  copy: function (t) {
                    return (
                      gh.prototype.copy.call(this, t),
                      (this.target = t.target.clone()),
                      (this.shadow = t.shadow.clone()),
                      this
                    )
                  },
                })),
                (Ah.prototype = Object.assign(Object.create(gh.prototype), {
                  constructor: Ah,
                  isAmbientLight: !0,
                })),
                (Lh.prototype = Object.assign(Object.create(gh.prototype), {
                  constructor: Lh,
                  isRectAreaLight: !0,
                  copy: function (t) {
                    return (
                      gh.prototype.copy.call(this, t),
                      (this.width = t.width),
                      (this.height = t.height),
                      this
                    )
                  },
                  toJSON: function (t) {
                    var e = gh.prototype.toJSON.call(this, t)
                    return (
                      (e.object.width = this.width),
                      (e.object.height = this.height),
                      e
                    )
                  },
                })),
                Object.assign(Rh.prototype, {
                  isSphericalHarmonics3: !0,
                  set: function (t) {
                    for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e])
                    return this
                  },
                  zero: function () {
                    for (var t = 0; t < 9; t++)
                      this.coefficients[t].set(0, 0, 0)
                    return this
                  },
                  getAt: function (t, e) {
                    var n = t.x,
                      r = t.y,
                      i = t.z,
                      a = this.coefficients
                    return (
                      e.copy(a[0]).multiplyScalar(0.282095),
                      e.addScaledVector(a[1], 0.488603 * r),
                      e.addScaledVector(a[2], 0.488603 * i),
                      e.addScaledVector(a[3], 0.488603 * n),
                      e.addScaledVector(a[4], n * r * 1.092548),
                      e.addScaledVector(a[5], r * i * 1.092548),
                      e.addScaledVector(a[6], 0.315392 * (3 * i * i - 1)),
                      e.addScaledVector(a[7], n * i * 1.092548),
                      e.addScaledVector(a[8], 0.546274 * (n * n - r * r)),
                      e
                    )
                  },
                  getIrradianceAt: function (t, e) {
                    var n = t.x,
                      r = t.y,
                      i = t.z,
                      a = this.coefficients
                    return (
                      e.copy(a[0]).multiplyScalar(0.886227),
                      e.addScaledVector(a[1], 1.023328 * r),
                      e.addScaledVector(a[2], 1.023328 * i),
                      e.addScaledVector(a[3], 1.023328 * n),
                      e.addScaledVector(a[4], 0.858086 * n * r),
                      e.addScaledVector(a[5], 0.858086 * r * i),
                      e.addScaledVector(a[6], 0.743125 * i * i - 0.247708),
                      e.addScaledVector(a[7], 0.858086 * n * i),
                      e.addScaledVector(a[8], 0.429043 * (n * n - r * r)),
                      e
                    )
                  },
                  add: function (t) {
                    for (var e = 0; e < 9; e++)
                      this.coefficients[e].add(t.coefficients[e])
                    return this
                  },
                  addScaledSH: function (t, e) {
                    for (var n = 0; n < 9; n++)
                      this.coefficients[n].addScaledVector(t.coefficients[n], e)
                    return this
                  },
                  scale: function (t) {
                    for (var e = 0; e < 9; e++)
                      this.coefficients[e].multiplyScalar(t)
                    return this
                  },
                  lerp: function (t, e) {
                    for (var n = 0; n < 9; n++)
                      this.coefficients[n].lerp(t.coefficients[n], e)
                    return this
                  },
                  equals: function (t) {
                    for (var e = 0; e < 9; e++)
                      if (!this.coefficients[e].equals(t.coefficients[e]))
                        return !1
                    return !0
                  },
                  copy: function (t) {
                    return this.set(t.coefficients)
                  },
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                  fromArray: function (t, e) {
                    void 0 === e && (e = 0)
                    for (var n = this.coefficients, r = 0; r < 9; r++)
                      n[r].fromArray(t, e + 3 * r)
                    return this
                  },
                  toArray: function (t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0)
                    for (var n = this.coefficients, r = 0; r < 9; r++)
                      n[r].toArray(t, e + 3 * r)
                    return t
                  },
                }),
                Object.assign(Rh, {
                  getBasisAt: function (t, e) {
                    var n = t.x,
                      r = t.y,
                      i = t.z
                    ;(e[0] = 0.282095),
                      (e[1] = 0.488603 * r),
                      (e[2] = 0.488603 * i),
                      (e[3] = 0.488603 * n),
                      (e[4] = 1.092548 * n * r),
                      (e[5] = 1.092548 * r * i),
                      (e[6] = 0.315392 * (3 * i * i - 1)),
                      (e[7] = 1.092548 * n * i),
                      (e[8] = 0.546274 * (n * n - r * r))
                  },
                }),
                (Ch.prototype = Object.assign(Object.create(gh.prototype), {
                  constructor: Ch,
                  isLightProbe: !0,
                  copy: function (t) {
                    return (
                      gh.prototype.copy.call(this, t), this.sh.copy(t.sh), this
                    )
                  },
                  fromJSON: function (t) {
                    return (
                      (this.intensity = t.intensity),
                      this.sh.fromArray(t.sh),
                      this
                    )
                  },
                  toJSON: function (t) {
                    var e = gh.prototype.toJSON.call(this, t)
                    return (e.object.sh = this.sh.toArray()), e
                  },
                })),
                (Ph.prototype = Object.assign(Object.create(Fl.prototype), {
                  constructor: Ph,
                  load: function (e, n, t, r) {
                    var i = this,
                      a = new Gl(i.manager)
                    a.setPath(i.path),
                      a.load(
                        e,
                        function (t) {
                          try {
                            n(i.parse(JSON.parse(t)))
                          } catch (t) {
                            r ? r(t) : console.error(t), i.manager.itemError(e)
                          }
                        },
                        t,
                        r,
                      )
                  },
                  parse: function (t) {
                    var e = this.textures
                    function n(t) {
                      return (
                        void 0 === e[t] &&
                          console.warn(
                            'THREE.MaterialLoader: Undefined texture',
                            t,
                          ),
                        e[t]
                      )
                    }
                    var r,
                      i = new bl[t.type]()
                    if (
                      (void 0 !== t.uuid && (i.uuid = t.uuid),
                      void 0 !== t.name && (i.name = t.name),
                      void 0 !== t.color && i.color.setHex(t.color),
                      void 0 !== t.roughness && (i.roughness = t.roughness),
                      void 0 !== t.metalness && (i.metalness = t.metalness),
                      void 0 !== t.sheen &&
                        (i.sheen = new Mr().setHex(t.sheen)),
                      void 0 !== t.emissive && i.emissive.setHex(t.emissive),
                      void 0 !== t.specular && i.specular.setHex(t.specular),
                      void 0 !== t.shininess && (i.shininess = t.shininess),
                      void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
                      void 0 !== t.clearcoatRoughness &&
                        (i.clearcoatRoughness = t.clearcoatRoughness),
                      void 0 !== t.fog && (i.fog = t.fog),
                      void 0 !== t.flatShading &&
                        (i.flatShading = t.flatShading),
                      void 0 !== t.blending && (i.blending = t.blending),
                      void 0 !== t.combine && (i.combine = t.combine),
                      void 0 !== t.side && (i.side = t.side),
                      void 0 !== t.opacity && (i.opacity = t.opacity),
                      void 0 !== t.transparent &&
                        (i.transparent = t.transparent),
                      void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
                      void 0 !== t.depthTest && (i.depthTest = t.depthTest),
                      void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
                      void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
                      void 0 !== t.stencilWrite &&
                        (i.stencilWrite = t.stencilWrite),
                      void 0 !== t.stencilWriteMask &&
                        (i.stencilWriteMask = t.stencilWriteMask),
                      void 0 !== t.stencilFunc &&
                        (i.stencilFunc = t.stencilFunc),
                      void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
                      void 0 !== t.stencilFuncMask &&
                        (i.stencilFuncMask = t.stencilFuncMask),
                      void 0 !== t.stencilFail &&
                        (i.stencilFail = t.stencilFail),
                      void 0 !== t.stencilZFail &&
                        (i.stencilZFail = t.stencilZFail),
                      void 0 !== t.stencilZPass &&
                        (i.stencilZPass = t.stencilZPass),
                      void 0 !== t.wireframe && (i.wireframe = t.wireframe),
                      void 0 !== t.wireframeLinewidth &&
                        (i.wireframeLinewidth = t.wireframeLinewidth),
                      void 0 !== t.wireframeLinecap &&
                        (i.wireframeLinecap = t.wireframeLinecap),
                      void 0 !== t.wireframeLinejoin &&
                        (i.wireframeLinejoin = t.wireframeLinejoin),
                      void 0 !== t.rotation && (i.rotation = t.rotation),
                      1 !== t.linewidth && (i.linewidth = t.linewidth),
                      void 0 !== t.dashSize && (i.dashSize = t.dashSize),
                      void 0 !== t.gapSize && (i.gapSize = t.gapSize),
                      void 0 !== t.scale && (i.scale = t.scale),
                      void 0 !== t.polygonOffset &&
                        (i.polygonOffset = t.polygonOffset),
                      void 0 !== t.polygonOffsetFactor &&
                        (i.polygonOffsetFactor = t.polygonOffsetFactor),
                      void 0 !== t.polygonOffsetUnits &&
                        (i.polygonOffsetUnits = t.polygonOffsetUnits),
                      void 0 !== t.skinning && (i.skinning = t.skinning),
                      void 0 !== t.morphTargets &&
                        (i.morphTargets = t.morphTargets),
                      void 0 !== t.morphNormals &&
                        (i.morphNormals = t.morphNormals),
                      void 0 !== t.dithering && (i.dithering = t.dithering),
                      void 0 !== t.vertexTangents &&
                        (i.vertexTangents = t.vertexTangents),
                      void 0 !== t.visible && (i.visible = t.visible),
                      void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
                      void 0 !== t.userData && (i.userData = t.userData),
                      void 0 !== t.vertexColors &&
                        ('number' == typeof t.vertexColors
                          ? (i.vertexColors = 0 < t.vertexColors)
                          : (i.vertexColors = t.vertexColors)),
                      void 0 !== t.uniforms)
                    )
                      for (var a in t.uniforms) {
                        var o = t.uniforms[a]
                        switch (((i.uniforms[a] = {}), o.type)) {
                          case 't':
                            i.uniforms[a].value = n(o.value)
                            break
                          case 'c':
                            i.uniforms[a].value = new Mr().setHex(o.value)
                            break
                          case 'v2':
                            i.uniforms[a].value = new Ye().fromArray(o.value)
                            break
                          case 'v3':
                            i.uniforms[a].value = new on().fromArray(o.value)
                            break
                          case 'v4':
                            i.uniforms[a].value = new $e().fromArray(o.value)
                            break
                          case 'm3':
                            i.uniforms[a].value = new Ze().fromArray(o.value)
                          case 'm4':
                            i.uniforms[a].value = new fn().fromArray(o.value)
                            break
                          default:
                            i.uniforms[a].value = o.value
                        }
                      }
                    if (
                      (void 0 !== t.defines && (i.defines = t.defines),
                      void 0 !== t.vertexShader &&
                        (i.vertexShader = t.vertexShader),
                      void 0 !== t.fragmentShader &&
                        (i.fragmentShader = t.fragmentShader),
                      void 0 !== t.extensions)
                    )
                      for (var s in t.extensions)
                        i.extensions[s] = t.extensions[s]
                    return (
                      void 0 !== t.shading && (i.flatShading = 1 === t.shading),
                      void 0 !== t.size && (i.size = t.size),
                      void 0 !== t.sizeAttenuation &&
                        (i.sizeAttenuation = t.sizeAttenuation),
                      void 0 !== t.map && (i.map = n(t.map)),
                      void 0 !== t.matcap && (i.matcap = n(t.matcap)),
                      void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
                      void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
                      void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
                      void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
                      void 0 !== t.normalMapType &&
                        (i.normalMapType = t.normalMapType),
                      void 0 !== t.normalScale &&
                        ((r = t.normalScale),
                        !1 === Array.isArray(r) && (r = [r, r]),
                        (i.normalScale = new Ye().fromArray(r))),
                      void 0 !== t.displacementMap &&
                        (i.displacementMap = n(t.displacementMap)),
                      void 0 !== t.displacementScale &&
                        (i.displacementScale = t.displacementScale),
                      void 0 !== t.displacementBias &&
                        (i.displacementBias = t.displacementBias),
                      void 0 !== t.roughnessMap &&
                        (i.roughnessMap = n(t.roughnessMap)),
                      void 0 !== t.metalnessMap &&
                        (i.metalnessMap = n(t.metalnessMap)),
                      void 0 !== t.emissiveMap &&
                        (i.emissiveMap = n(t.emissiveMap)),
                      void 0 !== t.emissiveIntensity &&
                        (i.emissiveIntensity = t.emissiveIntensity),
                      void 0 !== t.specularMap &&
                        (i.specularMap = n(t.specularMap)),
                      void 0 !== t.envMap && (i.envMap = n(t.envMap)),
                      void 0 !== t.envMapIntensity &&
                        (i.envMapIntensity = t.envMapIntensity),
                      void 0 !== t.reflectivity &&
                        (i.reflectivity = t.reflectivity),
                      void 0 !== t.refractionRatio &&
                        (i.refractionRatio = t.refractionRatio),
                      void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
                      void 0 !== t.lightMapIntensity &&
                        (i.lightMapIntensity = t.lightMapIntensity),
                      void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
                      void 0 !== t.aoMapIntensity &&
                        (i.aoMapIntensity = t.aoMapIntensity),
                      void 0 !== t.gradientMap &&
                        (i.gradientMap = n(t.gradientMap)),
                      void 0 !== t.clearcoatMap &&
                        (i.clearcoatMap = n(t.clearcoatMap)),
                      void 0 !== t.clearcoatRoughnessMap &&
                        (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
                      void 0 !== t.clearcoatNormalMap &&
                        (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
                      void 0 !== t.clearcoatNormalScale &&
                        (i.clearcoatNormalScale = new Ye().fromArray(
                          t.clearcoatNormalScale,
                        )),
                      i
                    )
                  },
                  setTextures: function (t) {
                    return (this.textures = t), this
                  },
                }))
              var Oh = {
                decodeText: function (t) {
                  if ('undefined' != typeof TextDecoder)
                    return new TextDecoder().decode(t)
                  for (var e = '', n = 0, r = t.length; n < r; n++)
                    e += String.fromCharCode(t[n])
                  try {
                    return decodeURIComponent(escape(e))
                  } catch (t) {
                    return e
                  }
                },
                extractUrlBase: function (t) {
                  var e = t.lastIndexOf('/')
                  return -1 === e ? './' : t.substr(0, e + 1)
                },
              }
              function Ih() {
                Kr.call(this),
                  (this.type = 'InstancedBufferGeometry'),
                  (this.instanceCount = 1 / 0)
              }
              function Dh(t, e, n, r) {
                'number' == typeof n &&
                  ((r = n),
                  (n = !1),
                  console.error(
                    'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.',
                  )),
                  Ir.call(this, t, e, n),
                  (this.meshPerAttribute = r || 1)
              }
              function Bh(t) {
                Fl.call(this, t)
              }
              ;(Ih.prototype = Object.assign(Object.create(Kr.prototype), {
                constructor: Ih,
                isInstancedBufferGeometry: !0,
                copy: function (t) {
                  return (
                    Kr.prototype.copy.call(this, t),
                    (this.instanceCount = t.instanceCount),
                    this
                  )
                },
                clone: function () {
                  return new this.constructor().copy(this)
                },
                toJSON: function () {
                  var t = Kr.prototype.toJSON.call(this)
                  return (
                    (t.instanceCount = this.instanceCount),
                    (t.isInstancedBufferGeometry = !0),
                    t
                  )
                },
              })),
                (Dh.prototype = Object.assign(Object.create(Ir.prototype), {
                  constructor: Dh,
                  isInstancedBufferAttribute: !0,
                  copy: function (t) {
                    return (
                      Ir.prototype.copy.call(this, t),
                      (this.meshPerAttribute = t.meshPerAttribute),
                      this
                    )
                  },
                  toJSON: function () {
                    var t = Ir.prototype.toJSON.call(this)
                    return (
                      (t.meshPerAttribute = this.meshPerAttribute),
                      (t.isInstancedBufferAttribute = !0),
                      t
                    )
                  },
                })),
                (Bh.prototype = Object.assign(Object.create(Fl.prototype), {
                  constructor: Bh,
                  load: function (e, n, t, r) {
                    var i = this,
                      a = new Gl(i.manager)
                    a.setPath(i.path),
                      a.load(
                        e,
                        function (t) {
                          try {
                            n(i.parse(JSON.parse(t)))
                          } catch (t) {
                            r ? r(t) : console.error(t), i.manager.itemError(e)
                          }
                        },
                        t,
                        r,
                      )
                  },
                  parse: function (t) {
                    var a = {},
                      o = {}
                    function e(t, e) {
                      if (void 0 !== a[e]) return a[e]
                      var n = t.interleavedBuffers[e],
                        r = (function (t, e) {
                          if (void 0 !== o[e]) return o[e]
                          var n = t.arrayBuffers[e],
                            r = new Uint32Array(n).buffer
                          return (o[e] = r)
                        })(t, n.buffer),
                        i = new Qo(new Nh[n.type](r), n.stride)
                      return (i.uuid = n.uuid), (a[e] = i)
                    }
                    var n,
                      r = new (t.isInstancedBufferGeometry ? Ih : Kr)(),
                      i = t.data.index
                    void 0 !== i &&
                      ((n = new Nh[i.type](i.array)), r.setIndex(new Ir(n, 1)))
                    var s = t.data.attributes
                    for (var c in s) {
                      var l,
                        h = s[c],
                        u = void 0
                      ;(u = h.isInterleavedBufferAttribute
                        ? new ts(
                            e(t.data, h.data),
                            h.itemSize,
                            h.offset,
                            h.normalized,
                          )
                        : ((l = new Nh[h.type](h.array)),
                          new (h.isInstancedBufferAttribute ? Dh : Ir)(
                            l,
                            h.itemSize,
                            h.normalized,
                          ))),
                        void 0 !== h.name && (u.name = h.name),
                        r.setAttribute(c, u)
                    }
                    var p = t.data.morphAttributes
                    if (p)
                      for (var d in p) {
                        for (
                          var f = p[d], m = [], v = 0, g = f.length;
                          v < g;
                          v++
                        ) {
                          var y = f[v],
                            x = void 0
                          ;(x = y.isInterleavedBufferAttribute
                            ? new ts(
                                e(t.data, y.data),
                                y.itemSize,
                                y.offset,
                                y.normalized,
                              )
                            : new Ir(
                                new Nh[y.type](y.array),
                                y.itemSize,
                                y.normalized,
                              )),
                            void 0 !== y.name && (x.name = y.name),
                            m.push(x)
                        }
                        r.morphAttributes[d] = m
                      }
                    t.data.morphTargetsRelative && (r.morphTargetsRelative = !0)
                    var b = t.data.groups || t.data.drawcalls || t.data.offsets
                    if (void 0 !== b)
                      for (var _ = 0, w = b.length; _ !== w; ++_) {
                        var M = b[_]
                        r.addGroup(M.start, M.count, M.materialIndex)
                      }
                    var S,
                      E = t.data.boundingSphere
                    return (
                      void 0 !== E &&
                        ((S = new on()),
                        void 0 !== E.center && S.fromArray(E.center),
                        (r.boundingSphere = new Jn(S, E.radius))),
                      t.name && (r.name = t.name),
                      t.userData && (r.userData = t.userData),
                      r
                    )
                  },
                }))
              var Nh = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray:
                  'undefined' != typeof Uint8ClampedArray
                    ? Uint8ClampedArray
                    : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array,
              }
              function Uh(t) {
                Fl.call(this, t)
              }
              Uh.prototype = Object.assign(Object.create(Fl.prototype), {
                constructor: Uh,
                load: function (r, i, t, a) {
                  var o = this,
                    e = '' === this.path ? Oh.extractUrlBase(r) : this.path
                  this.resourcePath = this.resourcePath || e
                  var n = new Gl(o.manager)
                  n.setPath(this.path),
                    n.load(
                      r,
                      function (t) {
                        var e = null
                        try {
                          e = JSON.parse(t)
                        } catch (t) {
                          return (
                            void 0 !== a && a(t),
                            void console.error(
                              "THREE:ObjectLoader: Can't parse " + r + '.',
                              t.message,
                            )
                          )
                        }
                        var n = e.metadata
                        void 0 !== n &&
                        void 0 !== n.type &&
                        'geometry' !== n.type.toLowerCase()
                          ? o.parse(e, i)
                          : console.error("THREE.ObjectLoader: Can't load " + r)
                      },
                      t,
                      a,
                    )
                },
                parse: function (t, e) {
                  var n = this.parseShape(t.shapes),
                    r = this.parseGeometries(t.geometries, n),
                    i = this.parseImages(t.images, function () {
                      void 0 !== e && e(s)
                    }),
                    a = this.parseTextures(t.textures, i),
                    o = this.parseMaterials(t.materials, a),
                    s = this.parseObject(t.object, r, o)
                  return (
                    t.animations &&
                      (s.animations = this.parseAnimations(t.animations)),
                    (void 0 !== t.images && 0 !== t.images.length) ||
                      (void 0 !== e && e(s)),
                    s
                  )
                },
                parseShape: function (t) {
                  var e = {}
                  if (void 0 !== t)
                    for (var n = 0, r = t.length; n < r; n++) {
                      var i = new vh().fromJSON(t[n])
                      e[i.uuid] = i
                    }
                  return e
                },
                parseGeometries: function (t, e) {
                  var n,
                    r = {}
                  if (void 0 !== t)
                    for (var i = new Bh(), a = 0, o = t.length; a < o; a++) {
                      var s = void 0,
                        c = t[a]
                      switch (c.type) {
                        case 'PlaneGeometry':
                        case 'PlaneBufferGeometry':
                          s = new ll[c.type](
                            c.width,
                            c.height,
                            c.widthSegments,
                            c.heightSegments,
                          )
                          break
                        case 'BoxGeometry':
                        case 'BoxBufferGeometry':
                        case 'CubeGeometry':
                          s = new ll[c.type](
                            c.width,
                            c.height,
                            c.depth,
                            c.widthSegments,
                            c.heightSegments,
                            c.depthSegments,
                          )
                          break
                        case 'CircleGeometry':
                        case 'CircleBufferGeometry':
                          s = new ll[c.type](
                            c.radius,
                            c.segments,
                            c.thetaStart,
                            c.thetaLength,
                          )
                          break
                        case 'CylinderGeometry':
                        case 'CylinderBufferGeometry':
                          s = new ll[c.type](
                            c.radiusTop,
                            c.radiusBottom,
                            c.height,
                            c.radialSegments,
                            c.heightSegments,
                            c.openEnded,
                            c.thetaStart,
                            c.thetaLength,
                          )
                          break
                        case 'ConeGeometry':
                        case 'ConeBufferGeometry':
                          s = new ll[c.type](
                            c.radius,
                            c.height,
                            c.radialSegments,
                            c.heightSegments,
                            c.openEnded,
                            c.thetaStart,
                            c.thetaLength,
                          )
                          break
                        case 'SphereGeometry':
                        case 'SphereBufferGeometry':
                          s = new ll[c.type](
                            c.radius,
                            c.widthSegments,
                            c.heightSegments,
                            c.phiStart,
                            c.phiLength,
                            c.thetaStart,
                            c.thetaLength,
                          )
                          break
                        case 'DodecahedronGeometry':
                        case 'DodecahedronBufferGeometry':
                        case 'IcosahedronGeometry':
                        case 'IcosahedronBufferGeometry':
                        case 'OctahedronGeometry':
                        case 'OctahedronBufferGeometry':
                        case 'TetrahedronGeometry':
                        case 'TetrahedronBufferGeometry':
                          s = new ll[c.type](c.radius, c.detail)
                          break
                        case 'RingGeometry':
                        case 'RingBufferGeometry':
                          s = new ll[c.type](
                            c.innerRadius,
                            c.outerRadius,
                            c.thetaSegments,
                            c.phiSegments,
                            c.thetaStart,
                            c.thetaLength,
                          )
                          break
                        case 'TorusGeometry':
                        case 'TorusBufferGeometry':
                          s = new ll[c.type](
                            c.radius,
                            c.tube,
                            c.radialSegments,
                            c.tubularSegments,
                            c.arc,
                          )
                          break
                        case 'TorusKnotGeometry':
                        case 'TorusKnotBufferGeometry':
                          s = new ll[c.type](
                            c.radius,
                            c.tube,
                            c.tubularSegments,
                            c.radialSegments,
                            c.p,
                            c.q,
                          )
                          break
                        case 'TubeGeometry':
                        case 'TubeBufferGeometry':
                          s = new ll[c.type](
                            new dh[c.path.type]().fromJSON(c.path),
                            c.tubularSegments,
                            c.radius,
                            c.radialSegments,
                            c.closed,
                          )
                          break
                        case 'LatheGeometry':
                        case 'LatheBufferGeometry':
                          s = new ll[c.type](
                            c.points,
                            c.segments,
                            c.phiStart,
                            c.phiLength,
                          )
                          break
                        case 'PolyhedronGeometry':
                        case 'PolyhedronBufferGeometry':
                          s = new ll[c.type](
                            c.vertices,
                            c.indices,
                            c.radius,
                            c.details,
                          )
                          break
                        case 'ShapeGeometry':
                        case 'ShapeBufferGeometry':
                          n = []
                          for (var l = 0, h = c.shapes.length; l < h; l++) {
                            var u = e[c.shapes[l]]
                            n.push(u)
                          }
                          s = new ll[c.type](n, c.curveSegments)
                          break
                        case 'ExtrudeGeometry':
                        case 'ExtrudeBufferGeometry':
                          n = []
                          for (var p = 0, d = c.shapes.length; p < d; p++) {
                            var f = e[c.shapes[p]]
                            n.push(f)
                          }
                          var m = c.options.extrudePath
                          void 0 !== m &&
                            (c.options.extrudePath = new dh[m.type]().fromJSON(
                              m,
                            )),
                            (s = new ll[c.type](n, c.options))
                          break
                        case 'BufferGeometry':
                        case 'InstancedBufferGeometry':
                          s = i.parse(c)
                          break
                        case 'Geometry':
                          console.error(
                            'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.',
                          )
                          break
                        default:
                          console.warn(
                            'THREE.ObjectLoader: Unsupported geometry type "' +
                              c.type +
                              '"',
                          )
                          continue
                      }
                      ;(s.uuid = c.uuid),
                        void 0 !== c.name && (s.name = c.name),
                        !0 === s.isBufferGeometry &&
                          void 0 !== c.userData &&
                          (s.userData = c.userData),
                        (r[c.uuid] = s)
                    }
                  return r
                },
                parseMaterials: function (t, e) {
                  var n = {},
                    r = {}
                  if (void 0 !== t) {
                    var i = new Ph()
                    i.setTextures(e)
                    for (var a = 0, o = t.length; a < o; a++) {
                      var s = t[a]
                      if ('MultiMaterial' === s.type) {
                        for (var c = [], l = 0; l < s.materials.length; l++) {
                          var h = s.materials[l]
                          void 0 === n[h.uuid] && (n[h.uuid] = i.parse(h)),
                            c.push(n[h.uuid])
                        }
                        r[s.uuid] = c
                      } else
                        void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)),
                          (r[s.uuid] = n[s.uuid])
                    }
                  }
                  return r
                },
                parseAnimations: function (t) {
                  for (var e = [], n = 0; n < t.length; n++) {
                    var r = t[n],
                      i = Dl.parse(r)
                    void 0 !== r.uuid && (i.uuid = r.uuid), e.push(i)
                  }
                  return e
                },
                parseImages: function (t, e) {
                  var n = this,
                    r = {}
                  function i(t) {
                    return (
                      n.manager.itemStart(t),
                      a.load(
                        t,
                        function () {
                          n.manager.itemEnd(t)
                        },
                        void 0,
                        function () {
                          n.manager.itemError(t), n.manager.itemEnd(t)
                        },
                      )
                    )
                  }
                  if (void 0 !== t && 0 < t.length) {
                    var a,
                      o = new Ul(e)
                    ;(a = new Wl(o)).setCrossOrigin(this.crossOrigin)
                    for (var s = 0, c = t.length; s < c; s++) {
                      var l = t[s],
                        h = l.url
                      if (Array.isArray(h)) {
                        r[l.uuid] = []
                        for (var u = 0, p = h.length; u < p; u++) {
                          var d = h[u],
                            f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d)
                              ? d
                              : n.resourcePath + d
                          r[l.uuid].push(i(f))
                        }
                      } else {
                        var m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url)
                          ? l.url
                          : n.resourcePath + l.url
                        r[l.uuid] = i(m)
                      }
                    }
                  }
                  return r
                },
                parseTextures: function (t, e) {
                  function n(t, e) {
                    return 'number' == typeof t
                      ? t
                      : (console.warn(
                          'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
                          t,
                        ),
                        e[t])
                  }
                  var r = {}
                  if (void 0 !== t)
                    for (var i = 0, a = t.length; i < a; i++) {
                      var o = t[i]
                      void 0 === o.image &&
                        console.warn(
                          'THREE.ObjectLoader: No "image" specified for',
                          o.uuid,
                        ),
                        void 0 === e[o.image] &&
                          console.warn(
                            'THREE.ObjectLoader: Undefined image',
                            o.image,
                          )
                      var s = void 0
                      ;((s = new (Array.isArray(e[o.image]) ? oa : Ke)(
                        e[o.image],
                      )).needsUpdate = !0),
                        (s.uuid = o.uuid),
                        void 0 !== o.name && (s.name = o.name),
                        void 0 !== o.mapping && (s.mapping = n(o.mapping, Fh)),
                        void 0 !== o.offset && s.offset.fromArray(o.offset),
                        void 0 !== o.repeat && s.repeat.fromArray(o.repeat),
                        void 0 !== o.center && s.center.fromArray(o.center),
                        void 0 !== o.rotation && (s.rotation = o.rotation),
                        void 0 !== o.wrap &&
                          ((s.wrapS = n(o.wrap[0], Hh)),
                          (s.wrapT = n(o.wrap[1], Hh))),
                        void 0 !== o.format && (s.format = o.format),
                        void 0 !== o.type && (s.type = o.type),
                        void 0 !== o.encoding && (s.encoding = o.encoding),
                        void 0 !== o.minFilter &&
                          (s.minFilter = n(o.minFilter, Gh)),
                        void 0 !== o.magFilter &&
                          (s.magFilter = n(o.magFilter, Gh)),
                        void 0 !== o.anisotropy &&
                          (s.anisotropy = o.anisotropy),
                        void 0 !== o.flipY && (s.flipY = o.flipY),
                        void 0 !== o.premultiplyAlpha &&
                          (s.premultiplyAlpha = o.premultiplyAlpha),
                        void 0 !== o.unpackAlignment &&
                          (s.unpackAlignment = o.unpackAlignment),
                        (r[o.uuid] = s)
                    }
                  return r
                },
                parseObject: function (t, e, a) {
                  var n, r
                  function i(t) {
                    return (
                      void 0 === e[t] &&
                        console.warn(
                          'THREE.ObjectLoader: Undefined geometry',
                          t,
                        ),
                      e[t]
                    )
                  }
                  function o(t) {
                    if (void 0 !== t) {
                      if (Array.isArray(t)) {
                        for (var e = [], n = 0, r = t.length; n < r; n++) {
                          var i = t[n]
                          void 0 === a[i] &&
                            console.warn(
                              'THREE.ObjectLoader: Undefined material',
                              i,
                            ),
                            e.push(a[i])
                        }
                        return e
                      }
                      return (
                        void 0 === a[t] &&
                          console.warn(
                            'THREE.ObjectLoader: Undefined material',
                            t,
                          ),
                        a[t]
                      )
                    }
                  }
                  switch (t.type) {
                    case 'Scene':
                      ;(s = new In()),
                        void 0 !== t.background &&
                          Number.isInteger(t.background) &&
                          (s.background = new Mr(t.background)),
                        void 0 !== t.fog &&
                          ('Fog' === t.fog.type
                            ? (s.fog = new Jo(
                                t.fog.color,
                                t.fog.near,
                                t.fog.far,
                              ))
                            : 'FogExp2' === t.fog.type &&
                              (s.fog = new Zo(t.fog.color, t.fog.density)))
                      break
                    case 'PerspectiveCamera':
                      ;(s = new Ii(t.fov, t.aspect, t.near, t.far)),
                        void 0 !== t.focus && (s.focus = t.focus),
                        void 0 !== t.zoom && (s.zoom = t.zoom),
                        void 0 !== t.filmGauge && (s.filmGauge = t.filmGauge),
                        void 0 !== t.filmOffset &&
                          (s.filmOffset = t.filmOffset),
                        void 0 !== t.view &&
                          (s.view = Object.assign({}, t.view))
                      break
                    case 'OrthographicCamera':
                      ;(s = new Sh(
                        t.left,
                        t.right,
                        t.top,
                        t.bottom,
                        t.near,
                        t.far,
                      )),
                        void 0 !== t.zoom && (s.zoom = t.zoom),
                        void 0 !== t.view &&
                          (s.view = Object.assign({}, t.view))
                      break
                    case 'AmbientLight':
                      s = new Ah(t.color, t.intensity)
                      break
                    case 'DirectionalLight':
                      s = new Th(t.color, t.intensity)
                      break
                    case 'PointLight':
                      s = new Mh(t.color, t.intensity, t.distance, t.decay)
                      break
                    case 'RectAreaLight':
                      s = new Lh(t.color, t.intensity, t.width, t.height)
                      break
                    case 'SpotLight':
                      s = new _h(
                        t.color,
                        t.intensity,
                        t.distance,
                        t.angle,
                        t.penumbra,
                        t.decay,
                      )
                      break
                    case 'HemisphereLight':
                      s = new yh(t.color, t.groundColor, t.intensity)
                      break
                    case 'LightProbe':
                      s = new Ch().fromJSON(t)
                      break
                    case 'SkinnedMesh':
                      console.warn(
                        'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.',
                      )
                    case 'Mesh':
                      s = new vi((n = i(t.geometry)), (r = o(t.material)))
                      break
                    case 'InstancedMesh':
                      ;(n = i(t.geometry)), (r = o(t.material))
                      var s,
                        c = t.count,
                        l = t.instanceMatrix
                      ;(s = new Is(n, r, c)).instanceMatrix = new Ir(
                        new Float32Array(l.array),
                        16,
                      )
                      break
                    case 'LOD':
                      s = new Ms()
                      break
                    case 'Line':
                      s = new Hs(i(t.geometry), o(t.material), t.mode)
                      break
                    case 'LineLoop':
                      s = new js(i(t.geometry), o(t.material))
                      break
                    case 'LineSegments':
                      s = new Vs(i(t.geometry), o(t.material))
                      break
                    case 'PointCloud':
                    case 'Points':
                      s = new Js(i(t.geometry), o(t.material))
                      break
                    case 'Sprite':
                      s = new fs(o(t.material))
                      break
                    case 'Group':
                      s = new Vo()
                      break
                    default:
                      s = new On()
                  }
                  if (
                    ((s.uuid = t.uuid),
                    void 0 !== t.name && (s.name = t.name),
                    void 0 !== t.matrix
                      ? (s.matrix.fromArray(t.matrix),
                        void 0 !== t.matrixAutoUpdate &&
                          (s.matrixAutoUpdate = t.matrixAutoUpdate),
                        s.matrixAutoUpdate &&
                          s.matrix.decompose(s.position, s.quaternion, s.scale))
                      : (void 0 !== t.position &&
                          s.position.fromArray(t.position),
                        void 0 !== t.rotation &&
                          s.rotation.fromArray(t.rotation),
                        void 0 !== t.quaternion &&
                          s.quaternion.fromArray(t.quaternion),
                        void 0 !== t.scale && s.scale.fromArray(t.scale)),
                    void 0 !== t.castShadow && (s.castShadow = t.castShadow),
                    void 0 !== t.receiveShadow &&
                      (s.receiveShadow = t.receiveShadow),
                    t.shadow &&
                      (void 0 !== t.shadow.bias &&
                        (s.shadow.bias = t.shadow.bias),
                      void 0 !== t.shadow.normalBias &&
                        (s.shadow.normalBias = t.shadow.normalBias),
                      void 0 !== t.shadow.radius &&
                        (s.shadow.radius = t.shadow.radius),
                      void 0 !== t.shadow.mapSize &&
                        s.shadow.mapSize.fromArray(t.shadow.mapSize),
                      void 0 !== t.shadow.camera &&
                        (s.shadow.camera = this.parseObject(t.shadow.camera))),
                    void 0 !== t.visible && (s.visible = t.visible),
                    void 0 !== t.frustumCulled &&
                      (s.frustumCulled = t.frustumCulled),
                    void 0 !== t.renderOrder && (s.renderOrder = t.renderOrder),
                    void 0 !== t.userData && (s.userData = t.userData),
                    void 0 !== t.layers && (s.layers.mask = t.layers),
                    void 0 !== t.children)
                  )
                    for (var h = t.children, u = 0; u < h.length; u++)
                      s.add(this.parseObject(h[u], e, a))
                  if ('LOD' === t.type) {
                    void 0 !== t.autoUpdate && (s.autoUpdate = t.autoUpdate)
                    for (var p = t.levels, d = 0; d < p.length; d++) {
                      var f = p[d],
                        m = s.getObjectByProperty('uuid', f.object)
                      void 0 !== m && s.addLevel(m, f.distance)
                    }
                  }
                  return s
                },
              })
              var zh,
                Fh = {
                  UVMapping: 300,
                  CubeReflectionMapping: Pt,
                  CubeRefractionMapping: Ot,
                  EquirectangularReflectionMapping: It,
                  EquirectangularRefractionMapping: Dt,
                  CubeUVReflectionMapping: Bt,
                  CubeUVRefractionMapping: Nt,
                },
                Hh = {
                  RepeatWrapping: Ut,
                  ClampToEdgeWrapping: zt,
                  MirroredRepeatWrapping: Ft,
                },
                Gh = {
                  NearestFilter: Ht,
                  NearestMipmapNearestFilter: Gt,
                  NearestMipmapLinearFilter: kt,
                  LinearFilter: Vt,
                  LinearMipmapNearestFilter: jt,
                  LinearMipmapLinearFilter: Wt,
                }
              function kh(t) {
                'undefined' == typeof createImageBitmap &&
                  console.warn(
                    'THREE.ImageBitmapLoader: createImageBitmap() not supported.',
                  ),
                  'undefined' == typeof fetch &&
                    console.warn(
                      'THREE.ImageBitmapLoader: fetch() not supported.',
                    ),
                  Fl.call(this, t),
                  (this.options = { premultiplyAlpha: 'none' })
              }
              function Vh() {
                ;(this.type = 'ShapePath'),
                  (this.color = new Mr()),
                  (this.subPaths = []),
                  (this.currentPath = null)
              }
              function jh(t) {
                ;(this.type = 'Font'), (this.data = t)
              }
              function Wh(t) {
                Fl.call(this, t)
              }
              ;(kh.prototype = Object.assign(Object.create(Fl.prototype), {
                constructor: kh,
                setOptions: function (t) {
                  return (this.options = t), this
                },
                load: function (e, n, t, r) {
                  void 0 === e && (e = ''),
                    void 0 !== this.path && (e = this.path + e),
                    (e = this.manager.resolveURL(e))
                  var i = this,
                    a = Nl.get(e)
                  if (void 0 !== a)
                    return (
                      i.manager.itemStart(e),
                      setTimeout(function () {
                        n && n(a), i.manager.itemEnd(e)
                      }, 0),
                      a
                    )
                  fetch(e)
                    .then(function (t) {
                      return t.blob()
                    })
                    .then(function (t) {
                      return createImageBitmap(t, i.options)
                    })
                    .then(function (t) {
                      Nl.add(e, t), n && n(t), i.manager.itemEnd(e)
                    })
                    .catch(function (t) {
                      r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                    }),
                    i.manager.itemStart(e)
                },
              })),
                Object.assign(Vh.prototype, {
                  moveTo: function (t, e) {
                    return (
                      (this.currentPath = new mh()),
                      this.subPaths.push(this.currentPath),
                      this.currentPath.moveTo(t, e),
                      this
                    )
                  },
                  lineTo: function (t, e) {
                    return this.currentPath.lineTo(t, e), this
                  },
                  quadraticCurveTo: function (t, e, n, r) {
                    return this.currentPath.quadraticCurveTo(t, e, n, r), this
                  },
                  bezierCurveTo: function (t, e, n, r, i, a) {
                    return (
                      this.currentPath.bezierCurveTo(t, e, n, r, i, a), this
                    )
                  },
                  splineThru: function (t) {
                    return this.currentPath.splineThru(t), this
                  },
                  toShapes: function (t, e) {
                    function n(t) {
                      for (var e = [], n = 0, r = t.length; n < r; n++) {
                        var i = t[n],
                          a = new vh()
                        ;(a.curves = i.curves), e.push(a)
                      }
                      return e
                    }
                    var r = zc.isClockWise,
                      i = this.subPaths
                    if (0 === i.length) return []
                    if (!0 === e) return n(i)
                    var a,
                      o,
                      s,
                      c = []
                    if (1 === i.length)
                      return (
                        (o = i[0]),
                        ((s = new vh()).curves = o.curves),
                        c.push(s),
                        c
                      )
                    var l,
                      h = !r(i[0].getPoints()),
                      h = t ? !h : h,
                      u = [],
                      p = [],
                      d = [],
                      f = 0
                    ;(p[f] = void 0), (d[f] = [])
                    for (var m, v = 0, g = i.length; v < g; v++)
                      (a = r((l = (o = i[v]).getPoints()))),
                        (a = t ? !a : a)
                          ? (!h && p[f] && f++,
                            (p[f] = { s: new vh(), p: l }),
                            (p[f].s.curves = o.curves),
                            h && f++,
                            (d[f] = []))
                          : d[f].push({ h: o, p: l[0] })
                    if (!p[0]) return n(i)
                    if (1 < p.length) {
                      for (var y = !1, x = [], b = 0, _ = p.length; b < _; b++)
                        u[b] = []
                      for (var w = 0, M = p.length; w < M; w++)
                        for (var S = d[w], E = 0; E < S.length; E++) {
                          for (var T = S[E], A = !0, L = 0; L < p.length; L++)
                            !(function (t, e) {
                              for (
                                var n = e.length, r = !1, i = n - 1, a = 0;
                                a < n;
                                i = a++
                              ) {
                                var o = e[i],
                                  s = e[a],
                                  c = s.x - o.x,
                                  l = s.y - o.y
                                if (Math.abs(l) > Number.EPSILON) {
                                  if (
                                    (l < 0 &&
                                      ((o = e[a]),
                                      (c = -c),
                                      (s = e[i]),
                                      (l = -l)),
                                    t.y < o.y || t.y > s.y)
                                  )
                                    continue
                                  if (t.y === o.y) {
                                    if (t.x === o.x) return 1
                                  } else {
                                    var h = l * (t.x - o.x) - c * (t.y - o.y)
                                    if (0 == h) return 1
                                    if (h < 0) continue
                                    r = !r
                                  }
                                } else {
                                  if (t.y !== o.y) continue
                                  if (
                                    (s.x <= t.x && t.x <= o.x) ||
                                    (o.x <= t.x && t.x <= s.x)
                                  )
                                    return 1
                                }
                              }
                              return r
                            })(T.p, p[L].p) ||
                              (w !== L && x.push({ froms: w, tos: L, hole: E }),
                              A ? ((A = !1), u[L].push(T)) : (y = !0))
                          A && u[w].push(T)
                        }
                      0 < x.length && (y || (d = u))
                    }
                    for (var R = 0, C = p.length; R < C; R++) {
                      ;(s = p[R].s), c.push(s)
                      for (var P = 0, O = (m = d[R]).length; P < O; P++)
                        s.holes.push(m[P].h)
                    }
                    return c
                  },
                }),
                Object.assign(jh.prototype, {
                  isFont: !0,
                  generateShapes: function (t, e) {
                    void 0 === e && (e = 100)
                    for (
                      var n = [],
                        r = (function (t, e, n) {
                          for (
                            var r = Array.from
                                ? Array.from(t)
                                : String(t).split(''),
                              i = e / n.resolution,
                              a =
                                (n.boundingBox.yMax -
                                  n.boundingBox.yMin +
                                  n.underlineThickness) *
                                i,
                              o = [],
                              s = 0,
                              c = 0,
                              l = 0;
                            l < r.length;
                            l++
                          ) {
                            var h,
                              u = r[l]
                            '\n' === u
                              ? ((s = 0), (c -= a))
                              : ((h = (function (t, e, n, r, i) {
                                  var a = i.glyphs[t] || i.glyphs['?']
                                  if (!a)
                                    return void console.error(
                                      'THREE.Font: character "' +
                                        t +
                                        '" does not exists in font family ' +
                                        i.familyName +
                                        '.',
                                    )
                                  var o,
                                    s,
                                    c,
                                    l,
                                    h,
                                    u,
                                    p,
                                    d,
                                    f = new Vh()
                                  if (a.o)
                                    for (
                                      var m =
                                          a._cachedOutline ||
                                          (a._cachedOutline = a.o.split(' ')),
                                        v = 0,
                                        g = m.length;
                                      v < g;

                                    ) {
                                      switch (m[v++]) {
                                        case 'm':
                                          ;(o = m[v++] * e + n),
                                            (s = m[v++] * e + r),
                                            f.moveTo(o, s)
                                          break
                                        case 'l':
                                          ;(o = m[v++] * e + n),
                                            (s = m[v++] * e + r),
                                            f.lineTo(o, s)
                                          break
                                        case 'q':
                                          ;(c = m[v++] * e + n),
                                            (l = m[v++] * e + r),
                                            (h = m[v++] * e + n),
                                            (u = m[v++] * e + r),
                                            f.quadraticCurveTo(h, u, c, l)
                                          break
                                        case 'b':
                                          ;(c = m[v++] * e + n),
                                            (l = m[v++] * e + r),
                                            (h = m[v++] * e + n),
                                            (u = m[v++] * e + r),
                                            (p = m[v++] * e + n),
                                            (d = m[v++] * e + r),
                                            f.bezierCurveTo(h, u, p, d, c, l)
                                      }
                                    }
                                  return { offsetX: a.ha * e, path: f }
                                })(u, i, s, c, n)),
                                (s += h.offsetX),
                                o.push(h.path))
                          }
                          return o
                        })(t, e, this.data),
                        i = 0,
                        a = r.length;
                      i < a;
                      i++
                    )
                      Array.prototype.push.apply(n, r[i].toShapes())
                    return n
                  },
                }),
                (Wh.prototype = Object.assign(Object.create(Fl.prototype), {
                  constructor: Wh,
                  load: function (t, r, e, n) {
                    var i = this,
                      a = new Gl(this.manager)
                    a.setPath(this.path),
                      a.load(
                        t,
                        function (e) {
                          var n
                          try {
                            n = JSON.parse(e)
                          } catch (t) {
                            console.warn(
                              'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.',
                            ),
                              (n = JSON.parse(e.substring(65, e.length - 2)))
                          }
                          var t = i.parse(n)
                          r && r(t)
                        },
                        e,
                        n,
                      )
                  },
                  parse: function (t) {
                    return new jh(t)
                  },
                }))
              var qh = {
                getContext: function () {
                  return (
                    void 0 === zh &&
                      (zh = new (window.AudioContext ||
                        window.webkitAudioContext)()),
                    zh
                  )
                },
                setContext: function (t) {
                  zh = t
                },
              }
              function Xh(t) {
                Fl.call(this, t)
              }
              function Yh(t, e, n) {
                Ch.call(this, void 0, n)
                var r = new Mr().set(t),
                  i = new Mr().set(e),
                  a = new on(r.r, r.g, r.b),
                  o = new on(i.r, i.g, i.b),
                  s = Math.sqrt(Math.PI),
                  c = s * Math.sqrt(0.75)
                this.sh.coefficients[0].copy(a).add(o).multiplyScalar(s),
                  this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(c)
              }
              function Zh(t, e) {
                Ch.call(this, void 0, e)
                var n = new Mr().set(t)
                this.sh.coefficients[0]
                  .set(n.r, n.g, n.b)
                  .multiplyScalar(2 * Math.sqrt(Math.PI))
              }
              ;(Xh.prototype = Object.assign(Object.create(Fl.prototype), {
                constructor: Xh,
                load: function (n, r, t, i) {
                  var a = this,
                    e = new Gl(a.manager)
                  e.setResponseType('arraybuffer'),
                    e.setPath(a.path),
                    e.load(
                      n,
                      function (t) {
                        try {
                          var e = t.slice(0)
                          qh.getContext().decodeAudioData(e, function (t) {
                            r(t)
                          })
                        } catch (t) {
                          i ? i(t) : console.error(t), a.manager.itemError(n)
                        }
                      },
                      t,
                      i,
                    )
                },
              })),
                (Yh.prototype = Object.assign(Object.create(Ch.prototype), {
                  constructor: Yh,
                  isHemisphereLightProbe: !0,
                  copy: function (t) {
                    return Ch.prototype.copy.call(this, t), this
                  },
                  toJSON: function (t) {
                    return Ch.prototype.toJSON.call(this, t)
                  },
                })),
                (Zh.prototype = Object.assign(Object.create(Ch.prototype), {
                  constructor: Zh,
                  isAmbientLightProbe: !0,
                  copy: function (t) {
                    return Ch.prototype.copy.call(this, t), this
                  },
                  toJSON: function (t) {
                    return Ch.prototype.toJSON.call(this, t)
                  },
                }))
              var Jh = new fn(),
                Qh = new fn()
              function Kh() {
                ;(this.type = 'StereoCamera'),
                  (this.aspect = 1),
                  (this.eyeSep = 0.064),
                  (this.cameraL = new Ii()),
                  this.cameraL.layers.enable(1),
                  (this.cameraL.matrixAutoUpdate = !1),
                  (this.cameraR = new Ii()),
                  this.cameraR.layers.enable(2),
                  (this.cameraR.matrixAutoUpdate = !1),
                  (this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null,
                  })
              }
              function $h(t) {
                ;(this.autoStart = void 0 === t || t),
                  (this.startTime = 0),
                  (this.oldTime = 0),
                  (this.elapsedTime = 0),
                  (this.running = !1)
              }
              Object.assign(Kh.prototype, {
                update: function (t) {
                  var e,
                    n,
                    r,
                    i,
                    a,
                    o,
                    s = this._cache
                  ;(s.focus === t.focus &&
                    s.fov === t.fov &&
                    s.aspect === t.aspect * this.aspect &&
                    s.near === t.near &&
                    s.far === t.far &&
                    s.zoom === t.zoom &&
                    s.eyeSep === this.eyeSep) ||
                    ((s.focus = t.focus),
                    (s.fov = t.fov),
                    (s.aspect = t.aspect * this.aspect),
                    (s.near = t.near),
                    (s.far = t.far),
                    (s.zoom = t.zoom),
                    (s.eyeSep = this.eyeSep),
                    (e = t.projectionMatrix.clone()),
                    (r = ((n = s.eyeSep / 2) * s.near) / s.focus),
                    (i =
                      (s.near * Math.tan(Xe.DEG2RAD * s.fov * 0.5)) / s.zoom),
                    (Qh.elements[12] = -n),
                    (Jh.elements[12] = n),
                    (a = -i * s.aspect + r),
                    (o = i * s.aspect + r),
                    (e.elements[0] = (2 * s.near) / (o - a)),
                    (e.elements[8] = (o + a) / (o - a)),
                    this.cameraL.projectionMatrix.copy(e),
                    (a = -i * s.aspect - r),
                    (o = i * s.aspect - r),
                    (e.elements[0] = (2 * s.near) / (o - a)),
                    (e.elements[8] = (o + a) / (o - a)),
                    this.cameraR.projectionMatrix.copy(e)),
                    this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Qh),
                    this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Jh)
                },
              }),
                Object.assign($h.prototype, {
                  start: function () {
                    ;(this.startTime = (
                      'undefined' == typeof performance ? Date : performance
                    ).now()),
                      (this.oldTime = this.startTime),
                      (this.elapsedTime = 0),
                      (this.running = !0)
                  },
                  stop: function () {
                    this.getElapsedTime(),
                      (this.running = !1),
                      (this.autoStart = !1)
                  },
                  getElapsedTime: function () {
                    return this.getDelta(), this.elapsedTime
                  },
                  getDelta: function () {
                    var t,
                      e = 0
                    return this.autoStart && !this.running
                      ? (this.start(), 0)
                      : (this.running &&
                          ((e =
                            ((t = (
                              'undefined' == typeof performance
                                ? Date
                                : performance
                            ).now()) -
                              this.oldTime) /
                            1e3),
                          (this.oldTime = t),
                          (this.elapsedTime += e)),
                        e)
                  },
                })
              var tu = new on(),
                eu = new nn(),
                nu = new on(),
                ru = new on()
              function iu() {
                On.call(this),
                  (this.type = 'AudioListener'),
                  (this.context = qh.getContext()),
                  (this.gain = this.context.createGain()),
                  this.gain.connect(this.context.destination),
                  (this.filter = null),
                  (this.timeDelta = 0),
                  (this._clock = new $h())
              }
              function au(t) {
                On.call(this),
                  (this.type = 'Audio'),
                  (this.listener = t),
                  (this.context = t.context),
                  (this.gain = this.context.createGain()),
                  this.gain.connect(t.getInput()),
                  (this.autoplay = !1),
                  (this.buffer = null),
                  (this.detune = 0),
                  (this.loop = !1),
                  (this.loopStart = 0),
                  (this.loopEnd = 0),
                  (this.offset = 0),
                  (this.duration = void 0),
                  (this.playbackRate = 1),
                  (this.isPlaying = !1),
                  (this.hasPlaybackControl = !0),
                  (this.sourceType = 'empty'),
                  (this._startedAt = 0),
                  (this._progress = 0),
                  (this.filters = [])
              }
              ;(iu.prototype = Object.assign(Object.create(On.prototype), {
                constructor: iu,
                getInput: function () {
                  return this.gain
                },
                removeFilter: function () {
                  return (
                    null !== this.filter &&
                      (this.gain.disconnect(this.filter),
                      this.filter.disconnect(this.context.destination),
                      this.gain.connect(this.context.destination),
                      (this.filter = null)),
                    this
                  )
                },
                getFilter: function () {
                  return this.filter
                },
                setFilter: function (t) {
                  return (
                    null !== this.filter
                      ? (this.gain.disconnect(this.filter),
                        this.filter.disconnect(this.context.destination))
                      : this.gain.disconnect(this.context.destination),
                    (this.filter = t),
                    this.gain.connect(this.filter),
                    this.filter.connect(this.context.destination),
                    this
                  )
                },
                getMasterVolume: function () {
                  return this.gain.gain.value
                },
                setMasterVolume: function (t) {
                  return (
                    this.gain.gain.setTargetAtTime(
                      t,
                      this.context.currentTime,
                      0.01,
                    ),
                    this
                  )
                },
                updateMatrixWorld: function (t) {
                  On.prototype.updateMatrixWorld.call(this, t)
                  var e,
                    n = this.context.listener,
                    r = this.up
                  ;(this.timeDelta = this._clock.getDelta()),
                    this.matrixWorld.decompose(tu, eu, nu),
                    ru.set(0, 0, -1).applyQuaternion(eu),
                    n.positionX
                      ? ((e = this.context.currentTime + this.timeDelta),
                        n.positionX.linearRampToValueAtTime(tu.x, e),
                        n.positionY.linearRampToValueAtTime(tu.y, e),
                        n.positionZ.linearRampToValueAtTime(tu.z, e),
                        n.forwardX.linearRampToValueAtTime(ru.x, e),
                        n.forwardY.linearRampToValueAtTime(ru.y, e),
                        n.forwardZ.linearRampToValueAtTime(ru.z, e),
                        n.upX.linearRampToValueAtTime(r.x, e),
                        n.upY.linearRampToValueAtTime(r.y, e),
                        n.upZ.linearRampToValueAtTime(r.z, e))
                      : (n.setPosition(tu.x, tu.y, tu.z),
                        n.setOrientation(ru.x, ru.y, ru.z, r.x, r.y, r.z))
                },
              })),
                (au.prototype = Object.assign(Object.create(On.prototype), {
                  constructor: au,
                  getOutput: function () {
                    return this.gain
                  },
                  setNodeSource: function (t) {
                    return (
                      (this.hasPlaybackControl = !1),
                      (this.sourceType = 'audioNode'),
                      (this.source = t),
                      this.connect(),
                      this
                    )
                  },
                  setMediaElementSource: function (t) {
                    return (
                      (this.hasPlaybackControl = !1),
                      (this.sourceType = 'mediaNode'),
                      (this.source = this.context.createMediaElementSource(t)),
                      this.connect(),
                      this
                    )
                  },
                  setMediaStreamSource: function (t) {
                    return (
                      (this.hasPlaybackControl = !1),
                      (this.sourceType = 'mediaStreamNode'),
                      (this.source = this.context.createMediaStreamSource(t)),
                      this.connect(),
                      this
                    )
                  },
                  setBuffer: function (t) {
                    return (
                      (this.buffer = t),
                      (this.sourceType = 'buffer'),
                      this.autoplay && this.play(),
                      this
                    )
                  },
                  play: function (t) {
                    if ((void 0 === t && (t = 0), !0 !== this.isPlaying)) {
                      if (!1 !== this.hasPlaybackControl) {
                        this._startedAt = this.context.currentTime + t
                        var e = this.context.createBufferSource()
                        return (
                          (e.buffer = this.buffer),
                          (e.loop = this.loop),
                          (e.loopStart = this.loopStart),
                          (e.loopEnd = this.loopEnd),
                          (e.onended = this.onEnded.bind(this)),
                          e.start(
                            this._startedAt,
                            this._progress + this.offset,
                            this.duration,
                          ),
                          (this.isPlaying = !0),
                          (this.source = e),
                          this.setDetune(this.detune),
                          this.setPlaybackRate(this.playbackRate),
                          this.connect()
                        )
                      }
                      console.warn(
                        'THREE.Audio: this Audio has no playback control.',
                      )
                    } else
                      console.warn('THREE.Audio: Audio is already playing.')
                  },
                  pause: function () {
                    if (!1 !== this.hasPlaybackControl)
                      return (
                        !0 === this.isPlaying &&
                          ((this._progress +=
                            Math.max(
                              this.context.currentTime - this._startedAt,
                              0,
                            ) * this.playbackRate),
                          !0 === this.loop &&
                            (this._progress =
                              this._progress %
                              (this.duration || this.buffer.duration)),
                          this.source.stop(),
                          (this.source.onended = null),
                          (this.isPlaying = !1)),
                        this
                      )
                    console.warn(
                      'THREE.Audio: this Audio has no playback control.',
                    )
                  },
                  stop: function () {
                    if (!1 !== this.hasPlaybackControl)
                      return (
                        (this._progress = 0),
                        this.source.stop(),
                        (this.source.onended = null),
                        (this.isPlaying = !1),
                        this
                      )
                    console.warn(
                      'THREE.Audio: this Audio has no playback control.',
                    )
                  },
                  connect: function () {
                    if (0 < this.filters.length) {
                      this.source.connect(this.filters[0])
                      for (var t = 1, e = this.filters.length; t < e; t++)
                        this.filters[t - 1].connect(this.filters[t])
                      this.filters[this.filters.length - 1].connect(
                        this.getOutput(),
                      )
                    } else this.source.connect(this.getOutput())
                    return this
                  },
                  disconnect: function () {
                    if (0 < this.filters.length) {
                      this.source.disconnect(this.filters[0])
                      for (var t = 1, e = this.filters.length; t < e; t++)
                        this.filters[t - 1].disconnect(this.filters[t])
                      this.filters[this.filters.length - 1].disconnect(
                        this.getOutput(),
                      )
                    } else this.source.disconnect(this.getOutput())
                    return this
                  },
                  getFilters: function () {
                    return this.filters
                  },
                  setFilters: function (t) {
                    return (
                      (t = t || []),
                      !0 === this.isPlaying
                        ? (this.disconnect(),
                          (this.filters = t),
                          this.connect())
                        : (this.filters = t),
                      this
                    )
                  },
                  setDetune: function (t) {
                    if (((this.detune = t), void 0 !== this.source.detune))
                      return (
                        !0 === this.isPlaying &&
                          this.source.detune.setTargetAtTime(
                            this.detune,
                            this.context.currentTime,
                            0.01,
                          ),
                        this
                      )
                  },
                  getDetune: function () {
                    return this.detune
                  },
                  getFilter: function () {
                    return this.getFilters()[0]
                  },
                  setFilter: function (t) {
                    return this.setFilters(t ? [t] : [])
                  },
                  setPlaybackRate: function (t) {
                    if (!1 !== this.hasPlaybackControl)
                      return (
                        (this.playbackRate = t),
                        !0 === this.isPlaying &&
                          this.source.playbackRate.setTargetAtTime(
                            this.playbackRate,
                            this.context.currentTime,
                            0.01,
                          ),
                        this
                      )
                    console.warn(
                      'THREE.Audio: this Audio has no playback control.',
                    )
                  },
                  getPlaybackRate: function () {
                    return this.playbackRate
                  },
                  onEnded: function () {
                    this.isPlaying = !1
                  },
                  getLoop: function () {
                    return !1 === this.hasPlaybackControl
                      ? (console.warn(
                          'THREE.Audio: this Audio has no playback control.',
                        ),
                        !1)
                      : this.loop
                  },
                  setLoop: function (t) {
                    if (!1 !== this.hasPlaybackControl)
                      return (
                        (this.loop = t),
                        !0 === this.isPlaying && (this.source.loop = this.loop),
                        this
                      )
                    console.warn(
                      'THREE.Audio: this Audio has no playback control.',
                    )
                  },
                  setLoopStart: function (t) {
                    return (this.loopStart = t), this
                  },
                  setLoopEnd: function (t) {
                    return (this.loopEnd = t), this
                  },
                  getVolume: function () {
                    return this.gain.gain.value
                  },
                  setVolume: function (t) {
                    return (
                      this.gain.gain.setTargetAtTime(
                        t,
                        this.context.currentTime,
                        0.01,
                      ),
                      this
                    )
                  },
                }))
              var ou = new on(),
                su = new nn(),
                cu = new on(),
                lu = new on()
              function hu(t) {
                au.call(this, t),
                  (this.panner = this.context.createPanner()),
                  (this.panner.panningModel = 'HRTF'),
                  this.panner.connect(this.gain)
              }
              function uu(t, e) {
                ;(this.analyser = t.context.createAnalyser()),
                  (this.analyser.fftSize = void 0 !== e ? e : 2048),
                  (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
                  t.getOutput().connect(this.analyser)
              }
              function pu(t, e, n) {
                var r, i, a
                switch (((this.binding = t), (this.valueSize = n), e)) {
                  case 'quaternion':
                    ;(r = this._slerp),
                      (i = this._slerpAdditive),
                      (a = this._setAdditiveIdentityQuaternion),
                      (this.buffer = new Float64Array(6 * n)),
                      (this._workIndex = 5)
                    break
                  case 'string':
                  case 'bool':
                    ;(r = this._select),
                      (i = this._select),
                      (a = this._setAdditiveIdentityOther),
                      (this.buffer = new Array(5 * n))
                    break
                  default:
                    ;(r = this._lerp),
                      (i = this._lerpAdditive),
                      (a = this._setAdditiveIdentityNumeric),
                      (this.buffer = new Float64Array(5 * n))
                }
                ;(this._mixBufferRegion = r),
                  (this._mixBufferRegionAdditive = i),
                  (this._setIdentity = a),
                  (this._origIndex = 3),
                  (this._addIndex = 4),
                  (this.cumulativeWeight = 0),
                  (this.cumulativeWeightAdditive = 0),
                  (this.useCount = 0),
                  (this.referenceCount = 0)
              }
              ;(hu.prototype = Object.assign(Object.create(au.prototype), {
                constructor: hu,
                getOutput: function () {
                  return this.panner
                },
                getRefDistance: function () {
                  return this.panner.refDistance
                },
                setRefDistance: function (t) {
                  return (this.panner.refDistance = t), this
                },
                getRolloffFactor: function () {
                  return this.panner.rolloffFactor
                },
                setRolloffFactor: function (t) {
                  return (this.panner.rolloffFactor = t), this
                },
                getDistanceModel: function () {
                  return this.panner.distanceModel
                },
                setDistanceModel: function (t) {
                  return (this.panner.distanceModel = t), this
                },
                getMaxDistance: function () {
                  return this.panner.maxDistance
                },
                setMaxDistance: function (t) {
                  return (this.panner.maxDistance = t), this
                },
                setDirectionalCone: function (t, e, n) {
                  return (
                    (this.panner.coneInnerAngle = t),
                    (this.panner.coneOuterAngle = e),
                    (this.panner.coneOuterGain = n),
                    this
                  )
                },
                updateMatrixWorld: function (t) {
                  var e, n
                  On.prototype.updateMatrixWorld.call(this, t),
                    (!0 === this.hasPlaybackControl && !1 === this.isPlaying) ||
                      (this.matrixWorld.decompose(ou, su, cu),
                      lu.set(0, 0, 1).applyQuaternion(su),
                      (e = this.panner).positionX
                        ? ((n =
                            this.context.currentTime + this.listener.timeDelta),
                          e.positionX.linearRampToValueAtTime(ou.x, n),
                          e.positionY.linearRampToValueAtTime(ou.y, n),
                          e.positionZ.linearRampToValueAtTime(ou.z, n),
                          e.orientationX.linearRampToValueAtTime(lu.x, n),
                          e.orientationY.linearRampToValueAtTime(lu.y, n),
                          e.orientationZ.linearRampToValueAtTime(lu.z, n))
                        : (e.setPosition(ou.x, ou.y, ou.z),
                          e.setOrientation(lu.x, lu.y, lu.z)))
                },
              })),
                Object.assign(uu.prototype, {
                  getFrequencyData: function () {
                    return (
                      this.analyser.getByteFrequencyData(this.data), this.data
                    )
                  },
                  getAverageFrequency: function () {
                    for (
                      var t = 0, e = this.getFrequencyData(), n = 0;
                      n < e.length;
                      n++
                    )
                      t += e[n]
                    return t / e.length
                  },
                }),
                Object.assign(pu.prototype, {
                  accumulate: function (t, e) {
                    var n = this.buffer,
                      r = this.valueSize,
                      i = t * r + r,
                      a = this.cumulativeWeight
                    if (0 === a) {
                      for (var o = 0; o !== r; ++o) n[i + o] = n[o]
                      a = e
                    } else {
                      var s = e / (a += e)
                      this._mixBufferRegion(n, i, 0, s, r)
                    }
                    this.cumulativeWeight = a
                  },
                  accumulateAdditive: function (t) {
                    var e = this.buffer,
                      n = this.valueSize,
                      r = n * this._addIndex
                    0 === this.cumulativeWeightAdditive && this._setIdentity(),
                      this._mixBufferRegionAdditive(e, r, 0, t, n),
                      (this.cumulativeWeightAdditive += t)
                  },
                  apply: function (t) {
                    var e,
                      n = this.valueSize,
                      r = this.buffer,
                      i = t * n + n,
                      a = this.cumulativeWeight,
                      o = this.cumulativeWeightAdditive,
                      s = this.binding
                    ;(this.cumulativeWeight = 0),
                      (this.cumulativeWeightAdditive = 0),
                      a < 1 &&
                        ((e = n * this._origIndex),
                        this._mixBufferRegion(r, i, e, 1 - a, n)),
                      0 < o &&
                        this._mixBufferRegionAdditive(
                          r,
                          i,
                          this._addIndex * n,
                          1,
                          n,
                        )
                    for (var c = n, l = n + n; c !== l; ++c)
                      if (r[c] !== r[c + n]) {
                        s.setValue(r, i)
                        break
                      }
                  },
                  saveOriginalState: function () {
                    var t = this.binding,
                      e = this.buffer,
                      n = this.valueSize,
                      r = n * this._origIndex
                    t.getValue(e, r)
                    for (var i = n, a = r; i !== a; ++i) e[i] = e[r + (i % n)]
                    this._setIdentity(),
                      (this.cumulativeWeight = 0),
                      (this.cumulativeWeightAdditive = 0)
                  },
                  restoreOriginalState: function () {
                    var t = 3 * this.valueSize
                    this.binding.setValue(this.buffer, t)
                  },
                  _setAdditiveIdentityNumeric: function () {
                    for (
                      var t = this._addIndex * this.valueSize,
                        e = t + this.valueSize,
                        n = t;
                      n < e;
                      n++
                    )
                      this.buffer[n] = 0
                  },
                  _setAdditiveIdentityQuaternion: function () {
                    this._setAdditiveIdentityNumeric(),
                      (this.buffer[4 * this._addIndex + 3] = 1)
                  },
                  _setAdditiveIdentityOther: function () {
                    for (
                      var t = this._origIndex * this.valueSize,
                        e = this._addIndex * this.valueSize,
                        n = 0;
                      n < this.valueSize;
                      n++
                    )
                      this.buffer[e + n] = this.buffer[t + n]
                  },
                  _select: function (t, e, n, r, i) {
                    if (0.5 <= r)
                      for (var a = 0; a !== i; ++a) t[e + a] = t[n + a]
                  },
                  _slerp: function (t, e, n, r) {
                    nn.slerpFlat(t, e, t, e, t, n, r)
                  },
                  _slerpAdditive: function (t, e, n, r, i) {
                    var a = this._workIndex * i
                    nn.multiplyQuaternionsFlat(t, a, t, e, t, n),
                      nn.slerpFlat(t, e, t, e, t, a, r)
                  },
                  _lerp: function (t, e, n, r, i) {
                    for (var a = 1 - r, o = 0; o !== i; ++o) {
                      var s = e + o
                      t[s] = t[s] * a + t[n + o] * r
                    }
                  },
                  _lerpAdditive: function (t, e, n, r, i) {
                    for (var a = 0; a !== i; ++a) {
                      var o = e + a
                      t[o] = t[o] + t[n + a] * r
                    }
                  },
                })
              var du = '\\[\\]\\.:\\/',
                fu = new RegExp('[' + du + ']', 'g'),
                mu = '[^' + du + ']',
                vu = '[^' + du.replace('\\.', '') + ']',
                gu = /((?:WC+[\/:])*)/.source.replace('WC', mu),
                yu = /(WCOD+)?/.source.replace('WCOD', vu),
                xu = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', mu),
                bu = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', mu),
                _u = new RegExp('^' + gu + yu + xu + bu + '$'),
                wu = ['material', 'materials', 'bones']
              function Mu(t, e, n) {
                var r = n || Su.parseTrackName(e)
                ;(this._targetGroup = t), (this._bindings = t.subscribe_(e, r))
              }
              function Su(t, e, n) {
                ;(this.path = e),
                  (this.parsedPath = n || Su.parseTrackName(e)),
                  (this.node = Su.findNode(t, this.parsedPath.nodeName) || t),
                  (this.rootNode = t)
              }
              function Eu() {
                ;(this.uuid = Xe.generateUUID()),
                  (this._objects = Array.prototype.slice.call(arguments)),
                  (this.nCachedObjects_ = 0)
                var t = {}
                this._indicesByUUID = t
                for (var e = 0, n = arguments.length; e !== n; ++e)
                  t[arguments[e].uuid] = e
                ;(this._paths = []),
                  (this._parsedPaths = []),
                  (this._bindings = []),
                  (this._bindingsIndicesByPath = {})
                var r = this
                this.stats = {
                  objects: {
                    get total() {
                      return r._objects.length
                    },
                    get inUse() {
                      return this.total - r.nCachedObjects_
                    },
                  },
                  get bindingsPerObject() {
                    return r._bindings.length
                  },
                }
              }
              function Tu(t, e, n, r) {
                ;(this._mixer = t),
                  (this._clip = e),
                  (this._localRoot = n || null),
                  (this.blendMode = r || e.blendMode)
                for (
                  var i = e.tracks,
                    a = i.length,
                    o = new Array(a),
                    s = { endingStart: Te, endingEnd: Te },
                    c = 0;
                  c !== a;
                  ++c
                ) {
                  var l = i[c].createInterpolant(null)
                  ;(o[c] = l).settings = s
                }
                ;(this._interpolantSettings = s),
                  (this._interpolants = o),
                  (this._propertyBindings = new Array(a)),
                  (this._cacheIndex = null),
                  (this._byClipCacheIndex = null),
                  (this._timeScaleInterpolant = null),
                  (this._weightInterpolant = null),
                  (this.loop = 2201),
                  (this._loopCount = -1),
                  (this._startTime = null),
                  (this.time = 0),
                  (this.timeScale = 1),
                  (this._effectiveTimeScale = 1),
                  (this.weight = 1),
                  (this._effectiveWeight = 1),
                  (this.repetitions = 1 / 0),
                  (this.paused = !1),
                  (this.enabled = !0),
                  (this.clampWhenFinished = !1),
                  (this.zeroSlopeAtStart = !0),
                  (this.zeroSlopeAtEnd = !0)
              }
              function Au(t) {
                ;(this._root = t),
                  this._initMemoryManager(),
                  (this._accuIndex = 0),
                  (this.time = 0),
                  (this.timeScale = 1)
              }
              function Lu(t) {
                'string' == typeof t &&
                  (console.warn(
                    'THREE.Uniform: Type parameter is no longer needed.',
                  ),
                  (t = arguments[1])),
                  (this.value = t)
              }
              function Ru(t, e, n) {
                Qo.call(this, t, e), (this.meshPerAttribute = n || 1)
              }
              function Cu(t, e, n, r) {
                ;(this.ray = new ir(t, e)),
                  (this.near = n || 0),
                  (this.far = r || 1 / 0),
                  (this.camera = null),
                  (this.layers = new yn()),
                  (this.params = {
                    Mesh: {},
                    Line: { threshold: 1 },
                    LOD: {},
                    Points: { threshold: 1 },
                    Sprite: {},
                  }),
                  Object.defineProperties(this.params, {
                    PointCloud: {
                      get: function () {
                        return (
                          console.warn(
                            'THREE.Raycaster: params.PointCloud has been renamed to params.Points.',
                          ),
                          this.Points
                        )
                      },
                    },
                  })
              }
              function Pu(t, e) {
                return t.distance - e.distance
              }
              function Ou(t, e, n, r) {
                if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === r))
                  for (var i = t.children, a = 0, o = i.length; a < o; a++)
                    Ou(i[a], e, n, !0)
              }
              function Iu(t, e, n) {
                return (
                  (this.radius = void 0 !== t ? t : 1),
                  (this.phi = void 0 !== e ? e : 0),
                  (this.theta = void 0 !== n ? n : 0),
                  this
                )
              }
              function Du(t, e, n) {
                return (
                  (this.radius = void 0 !== t ? t : 1),
                  (this.theta = void 0 !== e ? e : 0),
                  (this.y = void 0 !== n ? n : 0),
                  this
                )
              }
              Object.assign(Mu.prototype, {
                getValue: function (t, e) {
                  this.bind()
                  var n = this._targetGroup.nCachedObjects_,
                    r = this._bindings[n]
                  void 0 !== r && r.getValue(t, e)
                },
                setValue: function (t, e) {
                  for (
                    var n = this._bindings,
                      r = this._targetGroup.nCachedObjects_,
                      i = n.length;
                    r !== i;
                    ++r
                  )
                    n[r].setValue(t, e)
                },
                bind: function () {
                  for (
                    var t = this._bindings,
                      e = this._targetGroup.nCachedObjects_,
                      n = t.length;
                    e !== n;
                    ++e
                  )
                    t[e].bind()
                },
                unbind: function () {
                  for (
                    var t = this._bindings,
                      e = this._targetGroup.nCachedObjects_,
                      n = t.length;
                    e !== n;
                    ++e
                  )
                    t[e].unbind()
                },
              }),
                Object.assign(Su, {
                  Composite: Mu,
                  create: function (t, e, n) {
                    return t && t.isAnimationObjectGroup
                      ? new Su.Composite(t, e, n)
                      : new Su(t, e, n)
                  },
                  sanitizeNodeName: function (t) {
                    return t.replace(/\s/g, '_').replace(fu, '')
                  },
                  parseTrackName: function (t) {
                    var e = _u.exec(t)
                    if (!e)
                      throw new Error(
                        'PropertyBinding: Cannot parse trackName: ' + t,
                      )
                    var n,
                      r = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6],
                      },
                      i = r.nodeName && r.nodeName.lastIndexOf('.')
                    if (
                      (void 0 !== i &&
                        -1 !== i &&
                        ((n = r.nodeName.substring(i + 1)),
                        -1 !== wu.indexOf(n) &&
                          ((r.nodeName = r.nodeName.substring(0, i)),
                          (r.objectName = n))),
                      null === r.propertyName || 0 === r.propertyName.length)
                    )
                      throw new Error(
                        'PropertyBinding: can not parse propertyName from trackName: ' +
                          t,
                      )
                    return r
                  },
                  findNode: function (t, i) {
                    if (
                      !i ||
                      '' === i ||
                      '.' === i ||
                      -1 === i ||
                      i === t.name ||
                      i === t.uuid
                    )
                      return t
                    if (t.skeleton) {
                      var e = t.skeleton.getBoneByName(i)
                      if (void 0 !== e) return e
                    }
                    if (t.children) {
                      var a = function (t) {
                          for (var e = 0; e < t.length; e++) {
                            var n = t[e]
                            if (n.name === i || n.uuid === i) return n
                            var r = a(n.children)
                            if (r) return r
                          }
                          return null
                        },
                        n = a(t.children)
                      if (n) return n
                    }
                    return null
                  },
                }),
                Object.assign(Su.prototype, {
                  _getValue_unavailable: function () {},
                  _setValue_unavailable: function () {},
                  BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3,
                  },
                  Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2,
                  },
                  GetterByBindingType: [
                    function (t, e) {
                      t[e] = this.node[this.propertyName]
                    },
                    function (t, e) {
                      for (
                        var n = this.resolvedProperty, r = 0, i = n.length;
                        r !== i;
                        ++r
                      )
                        t[e++] = n[r]
                    },
                    function (t, e) {
                      t[e] = this.resolvedProperty[this.propertyIndex]
                    },
                    function (t, e) {
                      this.resolvedProperty.toArray(t, e)
                    },
                  ],
                  SetterByBindingTypeAndVersioning: [
                    [
                      function (t, e) {
                        this.targetObject[this.propertyName] = t[e]
                      },
                      function (t, e) {
                        ;(this.targetObject[this.propertyName] = t[e]),
                          (this.targetObject.needsUpdate = !0)
                      },
                      function (t, e) {
                        ;(this.targetObject[this.propertyName] = t[e]),
                          (this.targetObject.matrixWorldNeedsUpdate = !0)
                      },
                    ],
                    [
                      function (t, e) {
                        for (
                          var n = this.resolvedProperty, r = 0, i = n.length;
                          r !== i;
                          ++r
                        )
                          n[r] = t[e++]
                      },
                      function (t, e) {
                        for (
                          var n = this.resolvedProperty, r = 0, i = n.length;
                          r !== i;
                          ++r
                        )
                          n[r] = t[e++]
                        this.targetObject.needsUpdate = !0
                      },
                      function (t, e) {
                        for (
                          var n = this.resolvedProperty, r = 0, i = n.length;
                          r !== i;
                          ++r
                        )
                          n[r] = t[e++]
                        this.targetObject.matrixWorldNeedsUpdate = !0
                      },
                    ],
                    [
                      function (t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                      },
                      function (t, e) {
                        ;(this.resolvedProperty[this.propertyIndex] = t[e]),
                          (this.targetObject.needsUpdate = !0)
                      },
                      function (t, e) {
                        ;(this.resolvedProperty[this.propertyIndex] = t[e]),
                          (this.targetObject.matrixWorldNeedsUpdate = !0)
                      },
                    ],
                    [
                      function (t, e) {
                        this.resolvedProperty.fromArray(t, e)
                      },
                      function (t, e) {
                        this.resolvedProperty.fromArray(t, e),
                          (this.targetObject.needsUpdate = !0)
                      },
                      function (t, e) {
                        this.resolvedProperty.fromArray(t, e),
                          (this.targetObject.matrixWorldNeedsUpdate = !0)
                      },
                    ],
                  ],
                  getValue: function (t, e) {
                    this.bind(), this.getValue(t, e)
                  },
                  setValue: function (t, e) {
                    this.bind(), this.setValue(t, e)
                  },
                  bind: function () {
                    var t = this.node,
                      e = this.parsedPath,
                      n = e.objectName,
                      r = e.propertyName,
                      i = e.propertyIndex
                    if (
                      (t ||
                        ((t =
                          Su.findNode(this.rootNode, e.nodeName) ||
                          this.rootNode),
                        (this.node = t)),
                      (this.getValue = this._getValue_unavailable),
                      (this.setValue = this._setValue_unavailable),
                      t)
                    ) {
                      if (n) {
                        var a = e.objectIndex
                        switch (n) {
                          case 'materials':
                            if (!t.material)
                              return void console.error(
                                'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                                this,
                              )
                            if (!t.material.materials)
                              return void console.error(
                                'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                                this,
                              )
                            t = t.material.materials
                            break
                          case 'bones':
                            if (!t.skeleton)
                              return void console.error(
                                'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                                this,
                              )
                            t = t.skeleton.bones
                            for (var o = 0; o < t.length; o++)
                              if (t[o].name === a) {
                                a = o
                                break
                              }
                            break
                          default:
                            if (void 0 === t[n])
                              return void console.error(
                                'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                                this,
                              )
                            t = t[n]
                        }
                        if (void 0 !== a) {
                          if (void 0 === t[a])
                            return void console.error(
                              'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                              this,
                              t,
                            )
                          t = t[a]
                        }
                      }
                      var s = t[r]
                      if (void 0 !== s) {
                        var c = this.Versioning.None
                        void 0 !== (this.targetObject = t).needsUpdate
                          ? (c = this.Versioning.NeedsUpdate)
                          : void 0 !== t.matrixWorldNeedsUpdate &&
                            (c = this.Versioning.MatrixWorldNeedsUpdate)
                        var l = this.BindingType.Direct
                        if (void 0 !== i) {
                          if ('morphTargetInfluences' === r) {
                            if (!t.geometry)
                              return void console.error(
                                'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                                this,
                              )
                            if (!t.geometry.isBufferGeometry)
                              return void console.error(
                                'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.',
                                this,
                              )
                            if (!t.geometry.morphAttributes)
                              return void console.error(
                                'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                                this,
                              )
                            void 0 !== t.morphTargetDictionary[i] &&
                              (i = t.morphTargetDictionary[i])
                          }
                          ;(l = this.BindingType.ArrayElement),
                            (this.resolvedProperty = s),
                            (this.propertyIndex = i)
                        } else
                          void 0 !== s.fromArray && void 0 !== s.toArray
                            ? ((l = this.BindingType.HasFromToArray),
                              (this.resolvedProperty = s))
                            : Array.isArray(s)
                              ? ((l = this.BindingType.EntireArray),
                                (this.resolvedProperty = s))
                              : (this.propertyName = r)
                        ;(this.getValue = this.GetterByBindingType[l]),
                          (this.setValue =
                            this.SetterByBindingTypeAndVersioning[l][c])
                      } else {
                        var h = e.nodeName
                        console.error(
                          'THREE.PropertyBinding: Trying to update property for track: ' +
                            h +
                            '.' +
                            r +
                            " but it wasn't found.",
                          t,
                        )
                      }
                    } else
                      console.error(
                        'THREE.PropertyBinding: Trying to update node for track: ' +
                          this.path +
                          " but it wasn't found.",
                      )
                  },
                  unbind: function () {
                    ;(this.node = null),
                      (this.getValue = this._getValue_unbound),
                      (this.setValue = this._setValue_unbound)
                  },
                }),
                Object.assign(Su.prototype, {
                  _getValue_unbound: Su.prototype.getValue,
                  _setValue_unbound: Su.prototype.setValue,
                }),
                Object.assign(Eu.prototype, {
                  isAnimationObjectGroup: !0,
                  add: function () {
                    for (
                      var t = this._objects,
                        e = this._indicesByUUID,
                        n = this._paths,
                        r = this._parsedPaths,
                        i = this._bindings,
                        a = i.length,
                        o = void 0,
                        s = t.length,
                        c = this.nCachedObjects_,
                        l = 0,
                        h = arguments.length;
                      l !== h;
                      ++l
                    ) {
                      var u = arguments[l],
                        p = u.uuid,
                        d = e[p]
                      if (void 0 === d) {
                        ;(d = s++), (e[p] = d), t.push(u)
                        for (var f = 0, m = a; f !== m; ++f)
                          i[f].push(new Su(u, n[f], r[f]))
                      } else if (d < c) {
                        o = t[d]
                        var v = --c,
                          g = t[v]
                        ;(t[(e[g.uuid] = d)] = g), (t[(e[p] = v)] = u)
                        for (var y = 0, x = a; y !== x; ++y) {
                          var b = i[y],
                            _ = b[v],
                            w = b[d]
                          ;(b[d] = _),
                            void 0 === w && (w = new Su(u, n[y], r[y])),
                            (b[v] = w)
                        }
                      } else
                        t[d] !== o &&
                          console.error(
                            'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.',
                          )
                    }
                    this.nCachedObjects_ = c
                  },
                  remove: function () {
                    for (
                      var t = this._objects,
                        e = this._indicesByUUID,
                        n = this._bindings,
                        r = n.length,
                        i = this.nCachedObjects_,
                        a = 0,
                        o = arguments.length;
                      a !== o;
                      ++a
                    ) {
                      var s = arguments[a],
                        c = s.uuid,
                        l = e[c]
                      if (void 0 !== l && i <= l) {
                        var h = i++,
                          u = t[h]
                        ;(t[(e[u.uuid] = l)] = u), (t[(e[c] = h)] = s)
                        for (var p = 0, d = r; p !== d; ++p) {
                          var f = n[p],
                            m = f[h],
                            v = f[l]
                          ;(f[l] = m), (f[h] = v)
                        }
                      }
                    }
                    this.nCachedObjects_ = i
                  },
                  uncache: function () {
                    for (
                      var t = this._objects,
                        e = this._indicesByUUID,
                        n = this._bindings,
                        r = n.length,
                        i = this.nCachedObjects_,
                        a = t.length,
                        o = 0,
                        s = arguments.length;
                      o !== s;
                      ++o
                    ) {
                      var c = arguments[o].uuid,
                        l = e[c]
                      if (void 0 !== l)
                        if ((delete e[c], l < i)) {
                          var h = --i,
                            u = t[h],
                            p = --a,
                            d = t[p]
                          ;(t[(e[u.uuid] = l)] = u),
                            (t[(e[d.uuid] = h)] = d),
                            t.pop()
                          for (var f = 0, m = r; f !== m; ++f) {
                            var v = n[f],
                              g = v[h],
                              y = v[p]
                            ;(v[l] = g), (v[h] = y), v.pop()
                          }
                        } else {
                          var x = --a,
                            b = t[x]
                          ;(t[(e[b.uuid] = l)] = b), t.pop()
                          for (var _ = 0, w = r; _ !== w; ++_) {
                            var M = n[_]
                            ;(M[l] = M[x]), M.pop()
                          }
                        }
                    }
                    this.nCachedObjects_ = i
                  },
                  subscribe_: function (t, e) {
                    var n = this._bindingsIndicesByPath,
                      r = n[t],
                      i = this._bindings
                    if (void 0 !== r) return i[r]
                    var a = this._paths,
                      o = this._parsedPaths,
                      s = this._objects,
                      c = s.length,
                      l = this.nCachedObjects_,
                      h = new Array(c),
                      r = i.length
                    ;(n[t] = r), a.push(t), o.push(e), i.push(h)
                    for (var u = l, p = s.length; u !== p; ++u) {
                      var d = s[u]
                      h[u] = new Su(d, t, e)
                    }
                    return h
                  },
                  unsubscribe_: function (t) {
                    var e,
                      n,
                      r,
                      i,
                      a,
                      o = this._bindingsIndicesByPath,
                      s = o[t]
                    void 0 !== s &&
                      ((e = this._paths),
                      (n = this._parsedPaths),
                      (a = (r = this._bindings)[(i = r.length - 1)]),
                      (r[(o[t[i]] = s)] = a),
                      r.pop(),
                      (n[s] = n[i]),
                      n.pop(),
                      (e[s] = e[i]),
                      e.pop())
                  },
                }),
                Object.assign(Tu.prototype, {
                  play: function () {
                    return this._mixer._activateAction(this), this
                  },
                  stop: function () {
                    return this._mixer._deactivateAction(this), this.reset()
                  },
                  reset: function () {
                    return (
                      (this.paused = !1),
                      (this.enabled = !0),
                      (this.time = 0),
                      (this._loopCount = -1),
                      (this._startTime = null),
                      this.stopFading().stopWarping()
                    )
                  },
                  isRunning: function () {
                    return (
                      this.enabled &&
                      !this.paused &&
                      0 !== this.timeScale &&
                      null === this._startTime &&
                      this._mixer._isActiveAction(this)
                    )
                  },
                  isScheduled: function () {
                    return this._mixer._isActiveAction(this)
                  },
                  startAt: function (t) {
                    return (this._startTime = t), this
                  },
                  setLoop: function (t, e) {
                    return (this.loop = t), (this.repetitions = e), this
                  },
                  setEffectiveWeight: function (t) {
                    return (
                      (this.weight = t),
                      (this._effectiveWeight = this.enabled ? t : 0),
                      this.stopFading()
                    )
                  },
                  getEffectiveWeight: function () {
                    return this._effectiveWeight
                  },
                  fadeIn: function (t) {
                    return this._scheduleFading(t, 0, 1)
                  },
                  fadeOut: function (t) {
                    return this._scheduleFading(t, 1, 0)
                  },
                  crossFadeFrom: function (t, e, n) {
                    var r, i, a, o
                    return (
                      t.fadeOut(e),
                      this.fadeIn(e),
                      n &&
                        ((r = this._clip.duration),
                        (a = (i = t._clip.duration) / r),
                        (o = r / i),
                        t.warp(1, a, e),
                        this.warp(o, 1, e)),
                      this
                    )
                  },
                  crossFadeTo: function (t, e, n) {
                    return t.crossFadeFrom(this, e, n)
                  },
                  stopFading: function () {
                    var t = this._weightInterpolant
                    return (
                      null !== t &&
                        ((this._weightInterpolant = null),
                        this._mixer._takeBackControlInterpolant(t)),
                      this
                    )
                  },
                  setEffectiveTimeScale: function (t) {
                    return (
                      (this.timeScale = t),
                      (this._effectiveTimeScale = this.paused ? 0 : t),
                      this.stopWarping()
                    )
                  },
                  getEffectiveTimeScale: function () {
                    return this._effectiveTimeScale
                  },
                  setDuration: function (t) {
                    return (
                      (this.timeScale = this._clip.duration / t),
                      this.stopWarping()
                    )
                  },
                  syncWith: function (t) {
                    return (
                      (this.time = t.time),
                      (this.timeScale = t.timeScale),
                      this.stopWarping()
                    )
                  },
                  halt: function (t) {
                    return this.warp(this._effectiveTimeScale, 0, t)
                  },
                  warp: function (t, e, n) {
                    var r = this._mixer,
                      i = r.time,
                      a = this.timeScale,
                      o = this._timeScaleInterpolant
                    null === o &&
                      ((o = r._lendControlInterpolant()),
                      (this._timeScaleInterpolant = o))
                    var s = o.parameterPositions,
                      c = o.sampleValues
                    return (
                      (s[0] = i),
                      (s[1] = i + n),
                      (c[0] = t / a),
                      (c[1] = e / a),
                      this
                    )
                  },
                  stopWarping: function () {
                    var t = this._timeScaleInterpolant
                    return (
                      null !== t &&
                        ((this._timeScaleInterpolant = null),
                        this._mixer._takeBackControlInterpolant(t)),
                      this
                    )
                  },
                  getMixer: function () {
                    return this._mixer
                  },
                  getClip: function () {
                    return this._clip
                  },
                  getRoot: function () {
                    return this._localRoot || this._mixer._root
                  },
                  _update: function (t, e, n, r) {
                    if (this.enabled) {
                      var i = this._startTime
                      if (null !== i) {
                        var a = (t - i) * n
                        if (a < 0 || 0 === n) return
                        ;(this._startTime = null), (e = n * a)
                      }
                      e *= this._updateTimeScale(t)
                      var o = this._updateTime(e),
                        s = this._updateWeight(t)
                      if (0 < s) {
                        var c = this._interpolants,
                          l = this._propertyBindings
                        switch (this.blendMode) {
                          case 2501:
                            for (var h = 0, u = c.length; h !== u; ++h)
                              c[h].evaluate(o), l[h].accumulateAdditive(s)
                            break
                          case 2500:
                          default:
                            for (var p = 0, d = c.length; p !== d; ++p)
                              c[p].evaluate(o), l[p].accumulate(r, s)
                        }
                      }
                    } else this._updateWeight(t)
                  },
                  _updateWeight: function (t) {
                    var e,
                      n,
                      r = 0
                    return (
                      this.enabled &&
                        ((r = this.weight),
                        null !== (e = this._weightInterpolant) &&
                          ((r *= n = e.evaluate(t)[0]),
                          t > e.parameterPositions[1] &&
                            (this.stopFading(),
                            0 === n && (this.enabled = !1)))),
                      (this._effectiveWeight = r)
                    )
                  },
                  _updateTimeScale: function (t) {
                    var e,
                      n = 0
                    return (
                      this.paused ||
                        ((n = this.timeScale),
                        null !== (e = this._timeScaleInterpolant) &&
                          ((n *= e.evaluate(t)[0]),
                          t > e.parameterPositions[1] &&
                            (this.stopWarping(),
                            0 === n
                              ? (this.paused = !0)
                              : (this.timeScale = n)))),
                      (this._effectiveTimeScale = n)
                    )
                  },
                  _updateTime: function (t) {
                    var e,
                      n,
                      r,
                      i = this._clip.duration,
                      a = this.loop,
                      o = this.time + t,
                      s = this._loopCount,
                      c = 2202 === a
                    if (0 === t)
                      return -1 !== s && c && 1 == (1 & s) ? i - o : o
                    if (2200 === a) {
                      ;-1 === s &&
                        ((this._loopCount = 0), this._setEndings(!0, !0, !1))
                      t: {
                        if (i <= o) o = i
                        else {
                          if (!(o < 0)) {
                            this.time = o
                            break t
                          }
                          o = 0
                        }
                        this.clampWhenFinished
                          ? (this.paused = !0)
                          : (this.enabled = !1),
                          (this.time = o),
                          this._mixer.dispatchEvent({
                            type: 'finished',
                            action: this,
                            direction: t < 0 ? -1 : 1,
                          })
                      }
                    } else {
                      if (
                        (-1 === s &&
                          (0 <= t
                            ? ((s = 0),
                              this._setEndings(!0, 0 === this.repetitions, c))
                            : this._setEndings(0 === this.repetitions, !0, c)),
                        i <= o || o < 0
                          ? ((o -= i * (e = Math.floor(o / i))),
                            (s += Math.abs(e)),
                            (n = this.repetitions - s) <= 0
                              ? (this.clampWhenFinished
                                  ? (this.paused = !0)
                                  : (this.enabled = !1),
                                (o = 0 < t ? i : 0),
                                (this.time = o),
                                this._mixer.dispatchEvent({
                                  type: 'finished',
                                  action: this,
                                  direction: 0 < t ? 1 : -1,
                                }))
                              : (1 == n
                                  ? ((r = t < 0), this._setEndings(r, !r, c))
                                  : this._setEndings(!1, !1, c),
                                (this._loopCount = s),
                                (this.time = o),
                                this._mixer.dispatchEvent({
                                  type: 'loop',
                                  action: this,
                                  loopDelta: e,
                                })))
                          : (this.time = o),
                        c && 1 == (1 & s))
                      )
                        return i - o
                    }
                    return o
                  },
                  _setEndings: function (t, e, n) {
                    var r = this._interpolantSettings
                    n
                      ? ((r.endingStart = Ae), (r.endingEnd = Ae))
                      : ((r.endingStart = t
                          ? this.zeroSlopeAtStart
                            ? Ae
                            : Te
                          : Le),
                        (r.endingEnd = e
                          ? this.zeroSlopeAtEnd
                            ? Ae
                            : Te
                          : Le))
                  },
                  _scheduleFading: function (t, e, n) {
                    var r = this._mixer,
                      i = r.time,
                      a = this._weightInterpolant
                    null === a &&
                      ((a = r._lendControlInterpolant()),
                      (this._weightInterpolant = a))
                    var o = a.parameterPositions,
                      s = a.sampleValues
                    return (
                      (o[0] = i), (s[0] = e), (o[1] = i + t), (s[1] = n), this
                    )
                  },
                }),
                (Au.prototype = Object.assign(Object.create(Ve.prototype), {
                  constructor: Au,
                  _bindAction: function (t, e) {
                    var n = t._localRoot || this._root,
                      r = t._clip.tracks,
                      i = r.length,
                      a = t._propertyBindings,
                      o = t._interpolants,
                      s = n.uuid,
                      c = this._bindingsByRootAndName,
                      l = c[s]
                    void 0 === l && ((l = {}), (c[s] = l))
                    for (var h = 0; h !== i; ++h) {
                      var u = r[h],
                        p = u.name
                      if (void 0 !== (d = l[p])) a[h] = d
                      else {
                        if (void 0 !== (d = a[h])) {
                          null === d._cacheIndex &&
                            (++d.referenceCount,
                            this._addInactiveBinding(d, s, p))
                          continue
                        }
                        var d,
                          f = e && e._propertyBindings[h].binding.parsedPath
                        ++(d = new pu(
                          Su.create(n, p, f),
                          u.ValueTypeName,
                          u.getValueSize(),
                        )).referenceCount,
                          this._addInactiveBinding(d, s, p),
                          (a[h] = d)
                      }
                      o[h].resultBuffer = d.buffer
                    }
                  },
                  _activateAction: function (t) {
                    if (!this._isActiveAction(t)) {
                      var e, n, r
                      null === t._cacheIndex &&
                        ((e = (t._localRoot || this._root).uuid),
                        (n = t._clip.uuid),
                        (r = this._actionsByClip[n]),
                        this._bindAction(t, r && r.knownActions[0]),
                        this._addInactiveAction(t, n, e))
                      for (
                        var i = t._propertyBindings, a = 0, o = i.length;
                        a !== o;
                        ++a
                      ) {
                        var s = i[a]
                        0 == s.useCount++ &&
                          (this._lendBinding(s), s.saveOriginalState())
                      }
                      this._lendAction(t)
                    }
                  },
                  _deactivateAction: function (t) {
                    if (this._isActiveAction(t)) {
                      for (
                        var e = t._propertyBindings, n = 0, r = e.length;
                        n !== r;
                        ++n
                      ) {
                        var i = e[n]
                        0 == --i.useCount &&
                          (i.restoreOriginalState(), this._takeBackBinding(i))
                      }
                      this._takeBackAction(t)
                    }
                  },
                  _initMemoryManager: function () {
                    ;(this._actions = []),
                      (this._nActiveActions = 0),
                      (this._actionsByClip = {}),
                      (this._bindings = []),
                      (this._nActiveBindings = 0),
                      (this._bindingsByRootAndName = {}),
                      (this._controlInterpolants = []),
                      (this._nActiveControlInterpolants = 0)
                    var t = this
                    this.stats = {
                      actions: {
                        get total() {
                          return t._actions.length
                        },
                        get inUse() {
                          return t._nActiveActions
                        },
                      },
                      bindings: {
                        get total() {
                          return t._bindings.length
                        },
                        get inUse() {
                          return t._nActiveBindings
                        },
                      },
                      controlInterpolants: {
                        get total() {
                          return t._controlInterpolants.length
                        },
                        get inUse() {
                          return t._nActiveControlInterpolants
                        },
                      },
                    }
                  },
                  _isActiveAction: function (t) {
                    var e = t._cacheIndex
                    return null !== e && e < this._nActiveActions
                  },
                  _addInactiveAction: function (t, e, n) {
                    var r,
                      i = this._actions,
                      a = this._actionsByClip,
                      o = a[e]
                    void 0 === o
                      ? ((o = { knownActions: [t], actionByRoot: {} }),
                        (t._byClipCacheIndex = 0),
                        (a[e] = o))
                      : ((r = o.knownActions),
                        (t._byClipCacheIndex = r.length),
                        r.push(t)),
                      (t._cacheIndex = i.length),
                      i.push(t),
                      (o.actionByRoot[n] = t)
                  },
                  _removeInactiveAction: function (t) {
                    var e = this._actions,
                      n = e[e.length - 1],
                      r = t._cacheIndex
                    ;(e[(n._cacheIndex = r)] = n),
                      e.pop(),
                      (t._cacheIndex = null)
                    var i = t._clip.uuid,
                      a = this._actionsByClip,
                      o = a[i],
                      s = o.knownActions,
                      c = s[s.length - 1],
                      l = t._byClipCacheIndex
                    ;(s[(c._byClipCacheIndex = l)] = c),
                      s.pop(),
                      (t._byClipCacheIndex = null),
                      delete o.actionByRoot[(t._localRoot || this._root).uuid],
                      0 === s.length && delete a[i],
                      this._removeInactiveBindingsForAction(t)
                  },
                  _removeInactiveBindingsForAction: function (t) {
                    for (
                      var e = t._propertyBindings, n = 0, r = e.length;
                      n !== r;
                      ++n
                    ) {
                      var i = e[n]
                      0 == --i.referenceCount && this._removeInactiveBinding(i)
                    }
                  },
                  _lendAction: function (t) {
                    var e = this._actions,
                      n = t._cacheIndex,
                      r = this._nActiveActions++,
                      i = e[r]
                    ;(e[(t._cacheIndex = r)] = t), (e[(i._cacheIndex = n)] = i)
                  },
                  _takeBackAction: function (t) {
                    var e = this._actions,
                      n = t._cacheIndex,
                      r = --this._nActiveActions,
                      i = e[r]
                    ;(e[(t._cacheIndex = r)] = t), (e[(i._cacheIndex = n)] = i)
                  },
                  _addInactiveBinding: function (t, e, n) {
                    var r = this._bindingsByRootAndName,
                      i = this._bindings,
                      a = r[e]
                    void 0 === a && ((a = {}), (r[e] = a)),
                      ((a[n] = t)._cacheIndex = i.length),
                      i.push(t)
                  },
                  _removeInactiveBinding: function (t) {
                    var e = this._bindings,
                      n = t.binding,
                      r = n.rootNode.uuid,
                      i = n.path,
                      a = this._bindingsByRootAndName,
                      o = a[r],
                      s = e[e.length - 1],
                      c = t._cacheIndex
                    ;(e[(s._cacheIndex = c)] = s),
                      e.pop(),
                      delete o[i],
                      0 === Object.keys(o).length && delete a[r]
                  },
                  _lendBinding: function (t) {
                    var e = this._bindings,
                      n = t._cacheIndex,
                      r = this._nActiveBindings++,
                      i = e[r]
                    ;(e[(t._cacheIndex = r)] = t), (e[(i._cacheIndex = n)] = i)
                  },
                  _takeBackBinding: function (t) {
                    var e = this._bindings,
                      n = t._cacheIndex,
                      r = --this._nActiveBindings,
                      i = e[r]
                    ;(e[(t._cacheIndex = r)] = t), (e[(i._cacheIndex = n)] = i)
                  },
                  _lendControlInterpolant: function () {
                    var t = this._controlInterpolants,
                      e = this._nActiveControlInterpolants++,
                      n = t[e]
                    return (
                      void 0 === n &&
                        (t[
                          ((n = new Sl(
                            new Float32Array(2),
                            new Float32Array(2),
                            1,
                            this._controlInterpolantsResultBuffer,
                          )).__cacheIndex = e)
                        ] = n),
                      n
                    )
                  },
                  _takeBackControlInterpolant: function (t) {
                    var e = this._controlInterpolants,
                      n = t.__cacheIndex,
                      r = --this._nActiveControlInterpolants,
                      i = e[r]
                    ;(e[(t.__cacheIndex = r)] = t),
                      (e[(i.__cacheIndex = n)] = i)
                  },
                  _controlInterpolantsResultBuffer: new Float32Array(1),
                  clipAction: function (t, e, n) {
                    var r = e || this._root,
                      i = r.uuid,
                      a = 'string' == typeof t ? Dl.findByName(r, t) : t,
                      o = null !== a ? a.uuid : t,
                      s = this._actionsByClip[o],
                      c = null
                    if (
                      (void 0 === n && (n = null !== a ? a.blendMode : 2500),
                      void 0 !== s)
                    ) {
                      var l = s.actionByRoot[i]
                      if (void 0 !== l && l.blendMode === n) return l
                      ;(c = s.knownActions[0]), null === a && (a = c._clip)
                    }
                    if (null === a) return null
                    var h = new Tu(this, a, e, n)
                    return (
                      this._bindAction(h, c),
                      this._addInactiveAction(h, o, i),
                      h
                    )
                  },
                  existingAction: function (t, e) {
                    var n = e || this._root,
                      r = n.uuid,
                      i = 'string' == typeof t ? Dl.findByName(n, t) : t,
                      a = i ? i.uuid : t,
                      o = this._actionsByClip[a]
                    return (void 0 !== o && o.actionByRoot[r]) || null
                  },
                  stopAllAction: function () {
                    for (
                      var t = this._actions, e = this._nActiveActions - 1;
                      0 <= e;
                      --e
                    )
                      t[e].stop()
                    return this
                  },
                  update: function (t) {
                    t *= this.timeScale
                    for (
                      var e = this._actions,
                        n = this._nActiveActions,
                        r = (this.time += t),
                        i = Math.sign(t),
                        a = (this._accuIndex ^= 1),
                        o = 0;
                      o !== n;
                      ++o
                    ) {
                      e[o]._update(r, t, i, a)
                    }
                    for (
                      var s = this._bindings, c = this._nActiveBindings, l = 0;
                      l !== c;
                      ++l
                    )
                      s[l].apply(a)
                    return this
                  },
                  setTime: function (t) {
                    for (var e = (this.time = 0); e < this._actions.length; e++)
                      this._actions[e].time = 0
                    return this.update(t)
                  },
                  getRoot: function () {
                    return this._root
                  },
                  uncacheClip: function (t) {
                    var e = this._actions,
                      n = t.uuid,
                      r = this._actionsByClip,
                      i = r[n]
                    if (void 0 !== i) {
                      for (
                        var a = i.knownActions, o = 0, s = a.length;
                        o !== s;
                        ++o
                      ) {
                        var c = a[o]
                        this._deactivateAction(c)
                        var l = c._cacheIndex,
                          h = e[e.length - 1]
                        ;(c._cacheIndex = null),
                          (c._byClipCacheIndex = null),
                          (e[(h._cacheIndex = l)] = h),
                          e.pop(),
                          this._removeInactiveBindingsForAction(c)
                      }
                      delete r[n]
                    }
                  },
                  uncacheRoot: function (t) {
                    var e = t.uuid,
                      n = this._actionsByClip
                    for (var r in n) {
                      var i = n[r].actionByRoot[e]
                      void 0 !== i &&
                        (this._deactivateAction(i),
                        this._removeInactiveAction(i))
                    }
                    var a = this._bindingsByRootAndName[e]
                    if (void 0 !== a)
                      for (var o in a) {
                        var s = a[o]
                        s.restoreOriginalState(), this._removeInactiveBinding(s)
                      }
                  },
                  uncacheAction: function (t, e) {
                    var n = this.existingAction(t, e)
                    null !== n &&
                      (this._deactivateAction(n), this._removeInactiveAction(n))
                  },
                })),
                (Lu.prototype.clone = function () {
                  return new Lu(
                    void 0 === this.value.clone
                      ? this.value
                      : this.value.clone(),
                  )
                }),
                (Ru.prototype = Object.assign(Object.create(Qo.prototype), {
                  constructor: Ru,
                  isInstancedInterleavedBuffer: !0,
                  copy: function (t) {
                    return (
                      Qo.prototype.copy.call(this, t),
                      (this.meshPerAttribute = t.meshPerAttribute),
                      this
                    )
                  },
                  clone: function (t) {
                    var e = Qo.prototype.clone.call(this, t)
                    return (e.meshPerAttribute = this.meshPerAttribute), e
                  },
                  toJSON: function (t) {
                    var e = Qo.prototype.toJSON.call(this, t)
                    return (
                      (e.isInstancedInterleavedBuffer = !0),
                      (e.meshPerAttribute = this.meshPerAttribute),
                      e
                    )
                  },
                })),
                Object.assign(Cu.prototype, {
                  set: function (t, e) {
                    this.ray.set(t, e)
                  },
                  setFromCamera: function (t, e) {
                    e && e.isPerspectiveCamera
                      ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                        this.ray.direction
                          .set(t.x, t.y, 0.5)
                          .unproject(e)
                          .sub(this.ray.origin)
                          .normalize(),
                        (this.camera = e))
                      : e && e.isOrthographicCamera
                        ? (this.ray.origin
                            .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                            .unproject(e),
                          this.ray.direction
                            .set(0, 0, -1)
                            .transformDirection(e.matrixWorld),
                          (this.camera = e))
                        : console.error(
                            'THREE.Raycaster: Unsupported camera type.',
                          )
                  },
                  intersectObject: function (t, e, n) {
                    var r = n || []
                    return Ou(t, this, r, e), r.sort(Pu), r
                  },
                  intersectObjects: function (t, e, n) {
                    var r = n || []
                    if (!1 === Array.isArray(t))
                      return (
                        console.warn(
                          'THREE.Raycaster.intersectObjects: objects is not an Array.',
                        ),
                        r
                      )
                    for (var i = 0, a = t.length; i < a; i++)
                      Ou(t[i], this, r, e)
                    return r.sort(Pu), r
                  },
                }),
                Object.assign(Iu.prototype, {
                  set: function (t, e, n) {
                    return (
                      (this.radius = t), (this.phi = e), (this.theta = n), this
                    )
                  },
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                  copy: function (t) {
                    return (
                      (this.radius = t.radius),
                      (this.phi = t.phi),
                      (this.theta = t.theta),
                      this
                    )
                  },
                  makeSafe: function () {
                    return (
                      (this.phi = Math.max(
                        1e-6,
                        Math.min(Math.PI - 1e-6, this.phi),
                      )),
                      this
                    )
                  },
                  setFromVector3: function (t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z)
                  },
                  setFromCartesianCoords: function (t, e, n) {
                    return (
                      (this.radius = Math.sqrt(t * t + e * e + n * n)),
                      0 === this.radius
                        ? ((this.theta = 0), (this.phi = 0))
                        : ((this.theta = Math.atan2(t, n)),
                          (this.phi = Math.acos(
                            Xe.clamp(e / this.radius, -1, 1),
                          ))),
                      this
                    )
                  },
                }),
                Object.assign(Du.prototype, {
                  set: function (t, e, n) {
                    return (
                      (this.radius = t), (this.theta = e), (this.y = n), this
                    )
                  },
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                  copy: function (t) {
                    return (
                      (this.radius = t.radius),
                      (this.theta = t.theta),
                      (this.y = t.y),
                      this
                    )
                  },
                  setFromVector3: function (t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z)
                  },
                  setFromCartesianCoords: function (t, e, n) {
                    return (
                      (this.radius = Math.sqrt(t * t + n * n)),
                      (this.theta = Math.atan2(t, n)),
                      (this.y = e),
                      this
                    )
                  },
                })
              var Bu = new Ye()
              function Nu(t, e) {
                ;(this.min = void 0 !== t ? t : new Ye(1 / 0, 1 / 0)),
                  (this.max = void 0 !== e ? e : new Ye(-1 / 0, -1 / 0))
              }
              Object.assign(Nu.prototype, {
                set: function (t, e) {
                  return this.min.copy(t), this.max.copy(e), this
                },
                setFromPoints: function (t) {
                  this.makeEmpty()
                  for (var e = 0, n = t.length; e < n; e++)
                    this.expandByPoint(t[e])
                  return this
                },
                setFromCenterAndSize: function (t, e) {
                  var n = Bu.copy(e).multiplyScalar(0.5)
                  return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                },
                clone: function () {
                  return new this.constructor().copy(this)
                },
                copy: function (t) {
                  return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function () {
                  return (
                    (this.min.x = this.min.y = 1 / 0),
                    (this.max.x = this.max.y = -1 / 0),
                    this
                  )
                },
                isEmpty: function () {
                  return this.max.x < this.min.x || this.max.y < this.min.y
                },
                getCenter: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        'THREE.Box2: .getCenter() target is now required',
                      ),
                      (t = new Ye())),
                    this.isEmpty()
                      ? t.set(0, 0)
                      : t.addVectors(this.min, this.max).multiplyScalar(0.5)
                  )
                },
                getSize: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        'THREE.Box2: .getSize() target is now required',
                      ),
                      (t = new Ye())),
                    this.isEmpty()
                      ? t.set(0, 0)
                      : t.subVectors(this.max, this.min)
                  )
                },
                expandByPoint: function (t) {
                  return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function (t) {
                  return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function (t) {
                  return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                containsPoint: function (t) {
                  return !(
                    t.x < this.min.x ||
                    t.x > this.max.x ||
                    t.y < this.min.y ||
                    t.y > this.max.y
                  )
                },
                containsBox: function (t) {
                  return (
                    this.min.x <= t.min.x &&
                    t.max.x <= this.max.x &&
                    this.min.y <= t.min.y &&
                    t.max.y <= this.max.y
                  )
                },
                getParameter: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        'THREE.Box2: .getParameter() target is now required',
                      ),
                      (e = new Ye())),
                    e.set(
                      (t.x - this.min.x) / (this.max.x - this.min.x),
                      (t.y - this.min.y) / (this.max.y - this.min.y),
                    )
                  )
                },
                intersectsBox: function (t) {
                  return !(
                    t.max.x < this.min.x ||
                    t.min.x > this.max.x ||
                    t.max.y < this.min.y ||
                    t.min.y > this.max.y
                  )
                },
                clampPoint: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        'THREE.Box2: .clampPoint() target is now required',
                      ),
                      (e = new Ye())),
                    e.copy(t).clamp(this.min, this.max)
                  )
                },
                distanceToPoint: function (t) {
                  return Bu.copy(t).clamp(this.min, this.max).sub(t).length()
                },
                intersect: function (t) {
                  return this.min.max(t.min), this.max.min(t.max), this
                },
                union: function (t) {
                  return this.min.min(t.min), this.max.max(t.max), this
                },
                translate: function (t) {
                  return this.min.add(t), this.max.add(t), this
                },
                equals: function (t) {
                  return t.min.equals(this.min) && t.max.equals(this.max)
                },
              })
              var Uu = new on(),
                zu = new on()
              function Fu(t, e) {
                ;(this.start = void 0 !== t ? t : new on()),
                  (this.end = void 0 !== e ? e : new on())
              }
              function Hu(t) {
                On.call(this),
                  (this.material = t),
                  (this.render = function () {}),
                  (this.hasPositions = !1),
                  (this.hasNormals = !1),
                  (this.hasColors = !1),
                  (this.hasUvs = !1),
                  (this.positionArray = null),
                  (this.normalArray = null),
                  (this.colorArray = null),
                  (this.uvArray = null),
                  (this.count = 0)
              }
              Object.assign(Fu.prototype, {
                set: function (t, e) {
                  return this.start.copy(t), this.end.copy(e), this
                },
                clone: function () {
                  return new this.constructor().copy(this)
                },
                copy: function (t) {
                  return this.start.copy(t.start), this.end.copy(t.end), this
                },
                getCenter: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        'THREE.Line3: .getCenter() target is now required',
                      ),
                      (t = new on())),
                    t.addVectors(this.start, this.end).multiplyScalar(0.5)
                  )
                },
                delta: function (t) {
                  return (
                    void 0 === t &&
                      (console.warn(
                        'THREE.Line3: .delta() target is now required',
                      ),
                      (t = new on())),
                    t.subVectors(this.end, this.start)
                  )
                },
                distanceSq: function () {
                  return this.start.distanceToSquared(this.end)
                },
                distance: function () {
                  return this.start.distanceTo(this.end)
                },
                at: function (t, e) {
                  return (
                    void 0 === e &&
                      (console.warn(
                        'THREE.Line3: .at() target is now required',
                      ),
                      (e = new on())),
                    this.delta(e).multiplyScalar(t).add(this.start)
                  )
                },
                closestPointToPointParameter: function (t, e) {
                  Uu.subVectors(t, this.start),
                    zu.subVectors(this.end, this.start)
                  var n = zu.dot(zu),
                    r = zu.dot(Uu) / n
                  return e && (r = Xe.clamp(r, 0, 1)), r
                },
                closestPointToPoint: function (t, e, n) {
                  var r = this.closestPointToPointParameter(t, e)
                  return (
                    void 0 === n &&
                      (console.warn(
                        'THREE.Line3: .closestPointToPoint() target is now required',
                      ),
                      (n = new on())),
                    this.delta(n).multiplyScalar(r).add(this.start)
                  )
                },
                applyMatrix4: function (t) {
                  return (
                    this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                  )
                },
                equals: function (t) {
                  return t.start.equals(this.start) && t.end.equals(this.end)
                },
              }),
                (((Hu.prototype = Object.create(On.prototype)).constructor =
                  Hu).prototype.isImmediateRenderObject = !0)
              var Gu = new on()
              function ku(t, e) {
                On.call(this),
                  (this.light = t),
                  this.light.updateMatrixWorld(),
                  (this.matrix = t.matrixWorld),
                  (this.matrixAutoUpdate = !1),
                  (this.color = e)
                for (
                  var n = new Kr(),
                    r = [
                      0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0,
                      0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1,
                    ],
                    i = 0,
                    a = 1;
                  i < 32;
                  i++, a++
                ) {
                  var o = (i / 32) * Math.PI * 2,
                    s = (a / 32) * Math.PI * 2
                  r.push(
                    Math.cos(o),
                    Math.sin(o),
                    1,
                    Math.cos(s),
                    Math.sin(s),
                    1,
                  )
                }
                n.setAttribute('position', new Gr(r, 3))
                var c = new Ds({ fog: !1, toneMapped: !1 })
                ;(this.cone = new Vs(n, c)), this.add(this.cone), this.update()
              }
              ;(((ku.prototype = Object.create(On.prototype)).constructor =
                ku).prototype.dispose = function () {
                this.cone.geometry.dispose(), this.cone.material.dispose()
              }),
                (ku.prototype.update = function () {
                  this.light.updateMatrixWorld()
                  var t = this.light.distance ? this.light.distance : 1e3,
                    e = t * Math.tan(this.light.angle)
                  this.cone.scale.set(e, e, t),
                    Gu.setFromMatrixPosition(this.light.target.matrixWorld),
                    this.cone.lookAt(Gu),
                    void 0 !== this.color
                      ? this.cone.material.color.set(this.color)
                      : this.cone.material.color.copy(this.light.color)
                })
              var Vu = new on(),
                ju = new fn(),
                Wu = new fn()
              function qu(t) {
                for (
                  var e = (function t(e) {
                      var n = []
                      e && e.isBone && n.push(e)
                      for (var r = 0; r < e.children.length; r++)
                        n.push.apply(n, t(e.children[r]))
                      return n
                    })(t),
                    n = new Kr(),
                    r = [],
                    i = [],
                    a = new Mr(0, 0, 1),
                    o = new Mr(0, 1, 0),
                    s = 0;
                  s < e.length;
                  s++
                ) {
                  var c = e[s]
                  c.parent &&
                    c.parent.isBone &&
                    (r.push(0, 0, 0),
                    r.push(0, 0, 0),
                    i.push(a.r, a.g, a.b),
                    i.push(o.r, o.g, o.b))
                }
                n.setAttribute('position', new Gr(r, 3)),
                  n.setAttribute('color', new Gr(i, 3))
                var l = new Ds({
                  vertexColors: !0,
                  depthTest: !1,
                  depthWrite: !1,
                  toneMapped: !1,
                  transparent: !0,
                })
                Vs.call(this, n, l),
                  (this.type = 'SkeletonHelper'),
                  (this.root = t),
                  (this.bones = e),
                  (this.matrix = t.matrixWorld),
                  (this.matrixAutoUpdate = !1)
              }
              function Xu(t, e, n) {
                ;(this.light = t),
                  this.light.updateMatrixWorld(),
                  (this.color = n)
                var r = new Yc(e, 4, 2),
                  i = new Cr({ wireframe: !0, fog: !1, toneMapped: !1 })
                vi.call(this, r, i),
                  (this.type = 'PointLightHelper'),
                  (this.matrix = this.light.matrixWorld),
                  (this.matrixAutoUpdate = !1),
                  this.update()
              }
              ;(((qu.prototype = Object.create(Vs.prototype)).constructor =
                qu).prototype.isSkeletonHelper = !0),
                (qu.prototype.updateMatrixWorld = function (t) {
                  var e = this.bones,
                    n = this.geometry,
                    r = n.getAttribute('position')
                  Wu.getInverse(this.root.matrixWorld)
                  for (var i = 0, a = 0; i < e.length; i++) {
                    var o = e[i]
                    o.parent &&
                      o.parent.isBone &&
                      (ju.multiplyMatrices(Wu, o.matrixWorld),
                      Vu.setFromMatrixPosition(ju),
                      r.setXYZ(a, Vu.x, Vu.y, Vu.z),
                      ju.multiplyMatrices(Wu, o.parent.matrixWorld),
                      Vu.setFromMatrixPosition(ju),
                      r.setXYZ(a + 1, Vu.x, Vu.y, Vu.z),
                      (a += 2))
                  }
                  ;(n.getAttribute('position').needsUpdate = !0),
                    On.prototype.updateMatrixWorld.call(this, t)
                }),
                (((Xu.prototype = Object.create(vi.prototype)).constructor =
                  Xu).prototype.dispose = function () {
                  this.geometry.dispose(), this.material.dispose()
                }),
                (Xu.prototype.update = function () {
                  void 0 !== this.color
                    ? this.material.color.set(this.color)
                    : this.material.color.copy(this.light.color)
                })
              var Yu = new on(),
                Zu = new Mr(),
                Ju = new Mr()
              function Qu(t, e, n) {
                On.call(this),
                  (this.light = t),
                  this.light.updateMatrixWorld(),
                  (this.matrix = t.matrixWorld),
                  (this.matrixAutoUpdate = !1),
                  (this.color = n)
                var r = new hc(e)
                r.rotateY(0.5 * Math.PI),
                  (this.material = new Cr({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1,
                  })),
                  void 0 === this.color && (this.material.vertexColors = !0)
                var i = r.getAttribute('position'),
                  a = new Float32Array(3 * i.count)
                r.setAttribute('color', new Ir(a, 3)),
                  this.add(new vi(r, this.material)),
                  this.update()
              }
              function Ku(t, e, n, r) {
                ;(t = t || 10),
                  (e = e || 10),
                  (n = new Mr(void 0 !== n ? n : 4473924)),
                  (r = new Mr(void 0 !== r ? r : 8947848))
                for (
                  var i = e / 2,
                    a = t / e,
                    o = t / 2,
                    s = [],
                    c = [],
                    l = 0,
                    h = 0,
                    u = -o;
                  l <= e;
                  l++, u += a
                ) {
                  s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o)
                  var p = l === i ? n : r
                  p.toArray(c, h),
                    (h += 3),
                    p.toArray(c, h),
                    (h += 3),
                    p.toArray(c, h),
                    (h += 3),
                    p.toArray(c, h),
                    (h += 3)
                }
                var d = new Kr()
                d.setAttribute('position', new Gr(s, 3)),
                  d.setAttribute('color', new Gr(c, 3))
                var f = new Ds({ vertexColors: !0, toneMapped: !1 })
                Vs.call(this, d, f), (this.type = 'GridHelper')
              }
              function $u(t, e, n, r, i, a) {
                ;(t = t || 10),
                  (e = e || 16),
                  (n = n || 8),
                  (r = r || 64),
                  (i = new Mr(void 0 !== i ? i : 4473924)),
                  (a = new Mr(void 0 !== a ? a : 8947848))
                for (var o = [], s = [], c = 0; c <= e; c++) {
                  var l = (c / e) * (2 * Math.PI),
                    h = Math.sin(l) * t,
                    u = Math.cos(l) * t
                  o.push(0, 0, 0), o.push(h, 0, u)
                  var p = 1 & c ? i : a
                  s.push(p.r, p.g, p.b), s.push(p.r, p.g, p.b)
                }
                for (var d = 0; d <= n; d++)
                  for (
                    var f = 1 & d ? i : a, m = t - (t / n) * d, v = 0;
                    v < r;
                    v++
                  ) {
                    var g = (v / r) * (2 * Math.PI),
                      y = Math.sin(g) * m,
                      x = Math.cos(g) * m
                    o.push(y, 0, x),
                      s.push(f.r, f.g, f.b),
                      (g = ((v + 1) / r) * (2 * Math.PI)),
                      (y = Math.sin(g) * m),
                      (x = Math.cos(g) * m),
                      o.push(y, 0, x),
                      s.push(f.r, f.g, f.b)
                  }
                var b = new Kr()
                b.setAttribute('position', new Gr(o, 3)),
                  b.setAttribute('color', new Gr(s, 3))
                var _ = new Ds({ vertexColors: !0, toneMapped: !1 })
                Vs.call(this, b, _), (this.type = 'PolarGridHelper')
              }
              ;(((Qu.prototype = Object.create(On.prototype)).constructor =
                Qu).prototype.dispose = function () {
                this.children[0].geometry.dispose(),
                  this.children[0].material.dispose()
              }),
                (Qu.prototype.update = function () {
                  var t = this.children[0]
                  if (void 0 !== this.color) this.material.color.set(this.color)
                  else {
                    var e = t.geometry.getAttribute('color')
                    Zu.copy(this.light.color), Ju.copy(this.light.groundColor)
                    for (var n = 0, r = e.count; n < r; n++) {
                      var i = n < r / 2 ? Zu : Ju
                      e.setXYZ(n, i.r, i.g, i.b)
                    }
                    e.needsUpdate = !0
                  }
                  t.lookAt(
                    Yu.setFromMatrixPosition(this.light.matrixWorld).negate(),
                  )
                }),
                (Ku.prototype = Object.assign(Object.create(Vs.prototype), {
                  constructor: Ku,
                  copy: function (t) {
                    return (
                      Vs.prototype.copy.call(this, t),
                      this.geometry.copy(t.geometry),
                      this.material.copy(t.material),
                      this
                    )
                  },
                  clone: function () {
                    return new this.constructor().copy(this)
                  },
                })),
                (($u.prototype = Object.create(Vs.prototype)).constructor = $u)
              var tp = new on(),
                ep = new on(),
                np = new on()
              function rp(t, e, n) {
                On.call(this),
                  (this.light = t),
                  this.light.updateMatrixWorld(),
                  (this.matrix = t.matrixWorld),
                  (this.matrixAutoUpdate = !1),
                  (this.color = n),
                  void 0 === e && (e = 1)
                var r = new Kr()
                r.setAttribute(
                  'position',
                  new Gr([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3),
                )
                var i = new Ds({ fog: !1, toneMapped: !1 })
                ;(this.lightPlane = new Hs(r, i)),
                  this.add(this.lightPlane),
                  (r = new Kr()).setAttribute(
                    'position',
                    new Gr([0, 0, 0, 0, 0, 1], 3),
                  ),
                  (this.targetLine = new Hs(r, i)),
                  this.add(this.targetLine),
                  this.update()
              }
              ;(((rp.prototype = Object.create(On.prototype)).constructor =
                rp).prototype.dispose = function () {
                this.lightPlane.geometry.dispose(),
                  this.lightPlane.material.dispose(),
                  this.targetLine.geometry.dispose(),
                  this.targetLine.material.dispose()
              }),
                (rp.prototype.update = function () {
                  tp.setFromMatrixPosition(this.light.matrixWorld),
                    ep.setFromMatrixPosition(this.light.target.matrixWorld),
                    np.subVectors(ep, tp),
                    this.lightPlane.lookAt(ep),
                    void 0 !== this.color
                      ? (this.lightPlane.material.color.set(this.color),
                        this.targetLine.material.color.set(this.color))
                      : (this.lightPlane.material.color.copy(this.light.color),
                        this.targetLine.material.color.copy(this.light.color)),
                    this.targetLine.lookAt(ep),
                    (this.targetLine.scale.z = np.length())
                })
              var ip = new on(),
                ap = new Oi()
              function op(t) {
                var e = new Kr(),
                  n = new Ds({
                    color: 16777215,
                    vertexColors: !0,
                    toneMapped: !1,
                  }),
                  r = [],
                  i = [],
                  a = {},
                  o = new Mr(16755200),
                  s = new Mr(16711680),
                  c = new Mr(43775),
                  l = new Mr(16777215),
                  h = new Mr(3355443)
                function u(t, e, n) {
                  p(t, n), p(e, n)
                }
                function p(t, e) {
                  r.push(0, 0, 0),
                    i.push(e.r, e.g, e.b),
                    void 0 === a[t] && (a[t] = []),
                    a[t].push(r.length / 3 - 1)
                }
                u('n1', 'n2', o),
                  u('n2', 'n4', o),
                  u('n4', 'n3', o),
                  u('n3', 'n1', o),
                  u('f1', 'f2', o),
                  u('f2', 'f4', o),
                  u('f4', 'f3', o),
                  u('f3', 'f1', o),
                  u('n1', 'f1', o),
                  u('n2', 'f2', o),
                  u('n3', 'f3', o),
                  u('n4', 'f4', o),
                  u('p', 'n1', s),
                  u('p', 'n2', s),
                  u('p', 'n3', s),
                  u('p', 'n4', s),
                  u('u1', 'u2', c),
                  u('u2', 'u3', c),
                  u('u3', 'u1', c),
                  u('c', 't', l),
                  u('p', 'c', h),
                  u('cn1', 'cn2', h),
                  u('cn3', 'cn4', h),
                  u('cf1', 'cf2', h),
                  u('cf3', 'cf4', h),
                  e.setAttribute('position', new Gr(r, 3)),
                  e.setAttribute('color', new Gr(i, 3)),
                  Vs.call(this, e, n),
                  (this.type = 'CameraHelper'),
                  (this.camera = t),
                  this.camera.updateProjectionMatrix &&
                    this.camera.updateProjectionMatrix(),
                  (this.matrix = t.matrixWorld),
                  (this.matrixAutoUpdate = !1),
                  (this.pointMap = a),
                  this.update()
              }
              function sp(t, e, n, r, i, a, o) {
                ip.set(i, a, o).unproject(r)
                var s = e[t]
                if (void 0 !== s)
                  for (
                    var c = n.getAttribute('position'), l = 0, h = s.length;
                    l < h;
                    l++
                  )
                    c.setXYZ(s[l], ip.x, ip.y, ip.z)
              }
              ;((op.prototype = Object.create(Vs.prototype)).constructor =
                op).prototype.update = function () {
                var t = this.geometry,
                  e = this.pointMap
                ap.projectionMatrixInverse.copy(
                  this.camera.projectionMatrixInverse,
                ),
                  sp('c', e, t, ap, 0, 0, -1),
                  sp('t', e, t, ap, 0, 0, 1),
                  sp('n1', e, t, ap, -1, -1, -1),
                  sp('n2', e, t, ap, 1, -1, -1),
                  sp('n3', e, t, ap, -1, 1, -1),
                  sp('n4', e, t, ap, 1, 1, -1),
                  sp('f1', e, t, ap, -1, -1, 1),
                  sp('f2', e, t, ap, 1, -1, 1),
                  sp('f3', e, t, ap, -1, 1, 1),
                  sp('f4', e, t, ap, 1, 1, 1),
                  sp('u1', e, t, ap, 0.7, 1.1, -1),
                  sp('u2', e, t, ap, -0.7, 1.1, -1),
                  sp('u3', e, t, ap, 0, 2, -1),
                  sp('cf1', e, t, ap, -1, 0, 1),
                  sp('cf2', e, t, ap, 1, 0, 1),
                  sp('cf3', e, t, ap, 0, -1, 1),
                  sp('cf4', e, t, ap, 0, 1, 1),
                  sp('cn1', e, t, ap, -1, 0, -1),
                  sp('cn2', e, t, ap, 1, 0, -1),
                  sp('cn3', e, t, ap, 0, -1, -1),
                  sp('cn4', e, t, ap, 0, 1, -1),
                  (t.getAttribute('position').needsUpdate = !0)
              }
              var cp = new Xn()
              function lp(t, e) {
                ;(this.object = t), void 0 === e && (e = 16776960)
                var n = new Uint16Array([
                    0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5,
                    2, 6, 3, 7,
                  ]),
                  r = new Float32Array(24),
                  i = new Kr()
                i.setIndex(new Ir(n, 1)),
                  i.setAttribute('position', new Ir(r, 3)),
                  Vs.call(this, i, new Ds({ color: e, toneMapped: !1 })),
                  (this.type = 'BoxHelper'),
                  (this.matrixAutoUpdate = !1),
                  this.update()
              }
              function hp(t, e) {
                ;(this.type = 'Box3Helper'), (this.box = t), (e = e || 16776960)
                var n = new Uint16Array([
                    0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5,
                    2, 6, 3, 7,
                  ]),
                  r = new Kr()
                r.setIndex(new Ir(n, 1)),
                  r.setAttribute(
                    'position',
                    new Gr(
                      [
                        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1,
                        -1, -1, -1, -1, 1, -1, -1,
                      ],
                      3,
                    ),
                  ),
                  Vs.call(this, r, new Ds({ color: e, toneMapped: !1 })),
                  (this.type = 'Box3Helper'),
                  this.geometry.computeBoundingSphere()
              }
              function up(t, e, n) {
                ;(this.plane = t), (this.size = void 0 === e ? 1 : e)
                var r = void 0 !== n ? n : 16776960,
                  i = new Kr()
                i.setAttribute(
                  'position',
                  new Gr(
                    [
                      1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1,
                      1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
                    ],
                    3,
                  ),
                ),
                  i.computeBoundingSphere(),
                  Hs.call(this, i, new Ds({ color: r, toneMapped: !1 })),
                  (this.type = 'PlaneHelper')
                var a = new Kr()
                a.setAttribute(
                  'position',
                  new Gr(
                    [
                      1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1,
                      1,
                    ],
                    3,
                  ),
                ),
                  a.computeBoundingSphere(),
                  this.add(
                    new vi(
                      a,
                      new Cr({
                        color: r,
                        opacity: 0.2,
                        transparent: !0,
                        depthWrite: !1,
                        toneMapped: !1,
                      }),
                    ),
                  )
              }
              ;(((lp.prototype = Object.create(Vs.prototype)).constructor =
                lp).prototype.update = function (t) {
                var e, n, r, i
                void 0 !== t &&
                  console.warn(
                    'THREE.BoxHelper: .update() has no longer arguments.',
                  ),
                  void 0 !== this.object && cp.setFromObject(this.object),
                  cp.isEmpty() ||
                    ((e = cp.min),
                    (n = cp.max),
                    ((i = (r = this.geometry.attributes.position).array)[0] =
                      n.x),
                    (i[1] = n.y),
                    (i[2] = n.z),
                    (i[3] = e.x),
                    (i[4] = n.y),
                    (i[5] = n.z),
                    (i[6] = e.x),
                    (i[7] = e.y),
                    (i[8] = n.z),
                    (i[9] = n.x),
                    (i[10] = e.y),
                    (i[11] = n.z),
                    (i[12] = n.x),
                    (i[13] = n.y),
                    (i[14] = e.z),
                    (i[15] = e.x),
                    (i[16] = n.y),
                    (i[17] = e.z),
                    (i[18] = e.x),
                    (i[19] = e.y),
                    (i[20] = e.z),
                    (i[21] = n.x),
                    (i[22] = e.y),
                    (i[23] = e.z),
                    (r.needsUpdate = !0),
                    this.geometry.computeBoundingSphere())
              }),
                (lp.prototype.setFromObject = function (t) {
                  return (this.object = t), this.update(), this
                }),
                (lp.prototype.copy = function (t) {
                  return (
                    Vs.prototype.copy.call(this, t),
                    (this.object = t.object),
                    this
                  )
                }),
                (lp.prototype.clone = function () {
                  return new this.constructor().copy(this)
                }),
                (((hp.prototype = Object.create(Vs.prototype)).constructor =
                  hp).prototype.updateMatrixWorld = function (t) {
                  var e = this.box
                  e.isEmpty() ||
                    (e.getCenter(this.position),
                    e.getSize(this.scale),
                    this.scale.multiplyScalar(0.5),
                    On.prototype.updateMatrixWorld.call(this, t))
                }),
                (((up.prototype = Object.create(Hs.prototype)).constructor =
                  up).prototype.updateMatrixWorld = function (t) {
                  var e = -this.plane.constant
                  Math.abs(e) < 1e-8 && (e = 1e-8),
                    this.scale.set(0.5 * this.size, 0.5 * this.size, e),
                    (this.children[0].material.side = e < 0 ? q : O),
                    this.lookAt(this.plane.normal),
                    On.prototype.updateMatrixWorld.call(this, t)
                })
              var pp,
                dp,
                fp = new on()
              function mp(t, e, n, r, i, a) {
                On.call(this),
                  (this.type = 'ArrowHelper'),
                  void 0 === t && (t = new on(0, 0, 1)),
                  void 0 === e && (e = new on(0, 0, 0)),
                  void 0 === n && (n = 1),
                  void 0 === r && (r = 16776960),
                  void 0 === i && (i = 0.2 * n),
                  void 0 === a && (a = 0.2 * i),
                  void 0 === pp &&
                    ((pp = new Kr()).setAttribute(
                      'position',
                      new Gr([0, 0, 0, 0, 1, 0], 3),
                    ),
                    (dp = new il(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
                  this.position.copy(e),
                  (this.line = new Hs(
                    pp,
                    new Ds({ color: r, toneMapped: !1 }),
                  )),
                  (this.line.matrixAutoUpdate = !1),
                  this.add(this.line),
                  (this.cone = new vi(
                    dp,
                    new Cr({ color: r, toneMapped: !1 }),
                  )),
                  (this.cone.matrixAutoUpdate = !1),
                  this.add(this.cone),
                  this.setDirection(t),
                  this.setLength(n, i, a)
              }
              function vp(t) {
                var e = [
                    0,
                    0,
                    0,
                    (t = t || 1),
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    t,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    t,
                  ],
                  n = new Kr()
                n.setAttribute('position', new Gr(e, 3)),
                  n.setAttribute(
                    'color',
                    new Gr(
                      [
                        1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6,
                        1,
                      ],
                      3,
                    ),
                  )
                var r = new Ds({ vertexColors: !0, toneMapped: !1 })
                Vs.call(this, n, r), (this.type = 'AxesHelper')
              }
              ;(((mp.prototype = Object.create(On.prototype)).constructor =
                mp).prototype.setDirection = function (t) {
                var e
                0.99999 < t.y
                  ? this.quaternion.set(0, 0, 0, 1)
                  : t.y < -0.99999
                    ? this.quaternion.set(1, 0, 0, 0)
                    : (fp.set(t.z, 0, -t.x).normalize(),
                      (e = Math.acos(t.y)),
                      this.quaternion.setFromAxisAngle(fp, e))
              }),
                (mp.prototype.setLength = function (t, e, n) {
                  void 0 === e && (e = 0.2 * t),
                    void 0 === n && (n = 0.2 * e),
                    this.line.scale.set(1, Math.max(1e-4, t - e), 1),
                    this.line.updateMatrix(),
                    this.cone.scale.set(n, e, n),
                    (this.cone.position.y = t),
                    this.cone.updateMatrix()
                }),
                (mp.prototype.setColor = function (t) {
                  this.line.material.color.set(t),
                    this.cone.material.color.set(t)
                }),
                (mp.prototype.copy = function (t) {
                  return (
                    On.prototype.copy.call(this, t, !1),
                    this.line.copy(t.line),
                    this.cone.copy(t.cone),
                    this
                  )
                }),
                (mp.prototype.clone = function () {
                  return new this.constructor().copy(this)
                }),
                ((vp.prototype = Object.create(Vs.prototype)).constructor = vp)
              var gp = Math.pow(2, 8),
                yp = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
                xp = 5 + yp.length,
                bp = {}
              ;(bp[Re] = 0),
                (bp[Ce] = 1),
                (bp[Oe] = 2),
                (bp[n] = 3),
                (bp[Ie] = 4),
                (bp[De] = 5),
                (bp[Pe] = 6)
              var _p = new Sh(),
                wp = (function () {
                  for (var t = [], e = [], n = [], r = 8, i = 0; i < xp; i++) {
                    var a = Math.pow(2, r)
                    e.push(a)
                    var o = 1 / a
                    4 < i ? (o = yp[i - 8 + 4 - 1]) : 0 == i && (o = 0),
                      n.push(o)
                    for (
                      var s = 1 / (a - 1),
                        c = -s / 2,
                        l = 1 + s / 2,
                        h = [c, c, l, c, l, l, c, c, l, l, c, l],
                        u = new Float32Array(108),
                        p = new Float32Array(72),
                        d = new Float32Array(36),
                        f = 0;
                      f < 6;
                      f++
                    ) {
                      var m = ((f % 3) * 2) / 3 - 1,
                        v = 2 < f ? 0 : -1,
                        g = [
                          m,
                          v,
                          0,
                          m + 2 / 3,
                          v,
                          0,
                          m + 2 / 3,
                          1 + v,
                          0,
                          m,
                          v,
                          0,
                          m + 2 / 3,
                          1 + v,
                          0,
                          m,
                          1 + v,
                          0,
                        ]
                      u.set(g, 18 * f), p.set(h, 12 * f)
                      var y = [f, f, f, f, f, f]
                      d.set(y, 6 * f)
                    }
                    var x = new Kr()
                    x.setAttribute('position', new Ir(u, 3)),
                      x.setAttribute('uv', new Ir(p, 2)),
                      x.setAttribute('faceIndex', new Ir(d, 1)),
                      t.push(x),
                      4 < r && r--
                  }
                  return { _lodPlanes: t, _sizeLods: e, _sigmas: n }
                })(),
                Mp = wp._lodPlanes,
                Sp = wp._sizeLods,
                Ep = wp._sigmas,
                Tp = null,
                Ap = (1 + Math.sqrt(5)) / 2,
                Lp = 1 / Ap,
                Rp = [
                  new on(1, 1, 1),
                  new on(-1, 1, 1),
                  new on(1, 1, -1),
                  new on(-1, 1, -1),
                  new on(0, Ap, Lp),
                  new on(0, Ap, -Lp),
                  new on(Lp, 0, Ap),
                  new on(-Lp, 0, Ap),
                  new on(Ap, Lp, 0),
                  new on(-Ap, Lp, 0),
                ]
              function Cp(t) {
                var e, n, r
                ;(this._renderer = t),
                  (this._pingPongRenderTarget = null),
                  (this._blurMaterial =
                    ((e = 20),
                    (n = new Float32Array(e)),
                    (r = new on(0, 1, 0)),
                    new ul({
                      name: 'SphericalGaussianBlur',
                      defines: { n: e },
                      uniforms: {
                        envMap: { value: null },
                        samples: { value: 1 },
                        weights: { value: n },
                        latitudinal: { value: !1 },
                        dTheta: { value: 0 },
                        mipInt: { value: 0 },
                        poleAxis: { value: r },
                        inputEncoding: { value: bp[Re] },
                        outputEncoding: { value: bp[Re] },
                      },
                      vertexShader: Bp(),
                      fragmentShader:
                        '\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n' +
                        Np() +
                        "\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
                      blending: Y,
                      depthTest: !1,
                      depthWrite: !1,
                    }))),
                  (this._equirectShader = null),
                  (this._cubemapShader = null),
                  this._compileMaterial(this._blurMaterial)
              }
              function Pp(t) {
                var e = new tn(3 * gp, 3 * gp, t)
                return (
                  (e.texture.mapping = Bt),
                  (e.texture.name = 'PMREM.cubeUv'),
                  (e.scissorTest = !0),
                  e
                )
              }
              function Op(t, e, n, r, i) {
                t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i)
              }
              function Ip() {
                return new ul({
                  name: 'EquirectangularToCubeUV',
                  uniforms: {
                    envMap: { value: null },
                    texelSize: { value: new Ye(1, 1) },
                    inputEncoding: { value: bp[Re] },
                    outputEncoding: { value: bp[Re] },
                  },
                  vertexShader: Bp(),
                  fragmentShader:
                    '\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n' +
                    Np() +
                    '\n\n#include <common>\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv = equirectUv( outputDirection );\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t',
                  blending: Y,
                  depthTest: !1,
                  depthWrite: !1,
                })
              }
              function Dp() {
                return new ul({
                  name: 'CubemapToCubeUV',
                  uniforms: {
                    envMap: { value: null },
                    inputEncoding: { value: bp[Re] },
                    outputEncoding: { value: bp[Re] },
                  },
                  vertexShader: Bp(),
                  fragmentShader:
                    '\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n' +
                    Np() +
                    '\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t',
                  blending: Y,
                  depthTest: !1,
                  depthWrite: !1,
                })
              }
              function Bp() {
                return '\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\n\n// RH coordinate system; PMREM face-indexing convention\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\t} else if (face == 2.0) {\n\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\t} else if (face == 5.0) {\n\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\t}\n\treturn direction;\n}\n\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t'
              }
              function Np() {
                return '\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t'
              }
              Cp.prototype = {
                constructor: Cp,
                fromScene: function (t, e, n, r) {
                  void 0 === e && (e = 0),
                    void 0 === n && (n = 0.1),
                    void 0 === r && (r = 100),
                    (Tp = this._renderer.getRenderTarget())
                  var i = this._allocateTargets()
                  return (
                    this._sceneToCubeUV(t, n, r, i),
                    0 < e && this._blur(i, 0, 0, e),
                    this._applyPMREM(i),
                    this._cleanup(i),
                    i
                  )
                },
                fromEquirectangular: function (t) {
                  return this._fromTexture(t)
                },
                fromCubemap: function (t) {
                  return this._fromTexture(t)
                },
                compileCubemapShader: function () {
                  null === this._cubemapShader &&
                    ((this._cubemapShader = Dp()),
                    this._compileMaterial(this._cubemapShader))
                },
                compileEquirectangularShader: function () {
                  null === this._equirectShader &&
                    ((this._equirectShader = Ip()),
                    this._compileMaterial(this._equirectShader))
                },
                dispose: function () {
                  this._blurMaterial.dispose(),
                    null !== this._cubemapShader &&
                      this._cubemapShader.dispose(),
                    null !== this._equirectShader &&
                      this._equirectShader.dispose()
                  for (var t = 0; t < Mp.length; t++) Mp[t].dispose()
                },
                _cleanup: function (t) {
                  this._pingPongRenderTarget.dispose(),
                    this._renderer.setRenderTarget(Tp),
                    (t.scissorTest = !1),
                    Op(t, 0, 0, t.width, t.height)
                },
                _fromTexture: function (t) {
                  Tp = this._renderer.getRenderTarget()
                  var e = this._allocateTargets(t)
                  return (
                    this._textureToCubeUV(t, e),
                    this._applyPMREM(e),
                    this._cleanup(e),
                    e
                  )
                },
                _allocateTargets: function (t) {
                  var e,
                    n = {
                      magFilter: Ht,
                      minFilter: Ht,
                      generateMipmaps: !1,
                      type: qt,
                      format: d,
                      encoding:
                        void 0 === (e = t) ||
                        e.type !== qt ||
                        (e.encoding !== Re &&
                          e.encoding !== Ce &&
                          e.encoding !== Pe)
                          ? Oe
                          : t.encoding,
                      depthBuffer: !1,
                      stencilBuffer: !1,
                    },
                    r = Pp(n)
                  return (
                    (r.depthBuffer = !t),
                    (this._pingPongRenderTarget = Pp(n)),
                    r
                  )
                },
                _compileMaterial: function (t) {
                  var e = new vi(Mp[0], t)
                  this._renderer.compile(e, _p)
                },
                _sceneToCubeUV: function (t, e, n, r) {
                  var i = new Ii(90, 1, e, n),
                    a = [1, -1, 1, 1, 1, 1],
                    o = [1, 1, 1, -1, -1, -1],
                    s = this._renderer,
                    c = s.outputEncoding,
                    l = s.toneMapping,
                    h = s.getClearColor(),
                    u = s.getClearAlpha()
                  ;(s.toneMapping = Et), (s.outputEncoding = Re)
                  var p,
                    d,
                    f,
                    m = t.background
                  m &&
                    m.isColor &&
                    (m.convertSRGBToLinear(),
                    (p = Math.max(m.r, m.g, m.b)),
                    (d = Math.min(
                      Math.max(Math.ceil(Math.log2(p)), -128),
                      127,
                    )),
                    (m = m.multiplyScalar(Math.pow(2, -d))),
                    (f = (d + 128) / 255),
                    s.setClearColor(m, f),
                    (t.background = null))
                  for (var v = 0; v < 6; v++) {
                    var g = v % 3
                    0 == g
                      ? (i.up.set(0, a[v], 0), i.lookAt(o[v], 0, 0))
                      : 1 == g
                        ? (i.up.set(0, 0, a[v]), i.lookAt(0, o[v], 0))
                        : (i.up.set(0, a[v], 0), i.lookAt(0, 0, o[v])),
                      Op(r, g * gp, 2 < v ? gp : 0, gp, gp),
                      s.setRenderTarget(r),
                      s.render(t, i)
                  }
                  ;(s.toneMapping = l),
                    (s.outputEncoding = c),
                    s.setClearColor(h, u)
                },
                _textureToCubeUV: function (t, e) {
                  var n = this._renderer
                  t.isCubeTexture
                    ? null == this._cubemapShader &&
                      (this._cubemapShader = Dp())
                    : null == this._equirectShader &&
                      (this._equirectShader = Ip())
                  var r = t.isCubeTexture
                      ? this._cubemapShader
                      : this._equirectShader,
                    i = new vi(Mp[0], r),
                    a = r.uniforms
                  ;(a.envMap.value = t).isCubeTexture ||
                    a.texelSize.value.set(
                      1 / t.image.width,
                      1 / t.image.height,
                    ),
                    (a.inputEncoding.value = bp[t.encoding]),
                    (a.outputEncoding.value = bp[e.texture.encoding]),
                    Op(e, 0, 0, 3 * gp, 2 * gp),
                    n.setRenderTarget(e),
                    n.render(i, _p)
                },
                _applyPMREM: function (t) {
                  var e = this._renderer,
                    n = e.autoClear
                  e.autoClear = !1
                  for (var r = 1; r < xp; r++) {
                    var i = Math.sqrt(Ep[r] * Ep[r] - Ep[r - 1] * Ep[r - 1]),
                      a = Rp[(r - 1) % Rp.length]
                    this._blur(t, r - 1, r, i, a)
                  }
                  e.autoClear = n
                },
                _blur: function (t, e, n, r, i) {
                  var a = this._pingPongRenderTarget
                  this._halfBlur(t, a, e, n, r, 'latitudinal', i),
                    this._halfBlur(a, t, n, n, r, 'longitudinal', i)
                },
                _halfBlur: function (t, e, n, r, i, a, o) {
                  var s = this._renderer,
                    c = this._blurMaterial
                  'latitudinal' !== a &&
                    'longitudinal' !== a &&
                    console.error(
                      'blur direction must be either latitudinal or longitudinal!',
                    )
                  var l = new vi(Mp[r], c),
                    h = c.uniforms,
                    u = Sp[n] - 1,
                    p = isFinite(i) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
                    d = i / p,
                    f = isFinite(i) ? 1 + Math.floor(3 * d) : 20
                  20 < f &&
                    console.warn(
                      'sigmaRadians, ' +
                        i +
                        ', is too large and will clip, as it requested ' +
                        f +
                        ' samples when the maximum is set to 20',
                    )
                  for (var m = [], v = 0, g = 0; g < 20; ++g) {
                    var y = g / d,
                      x = Math.exp((-y * y) / 2)
                    m.push(x), 0 == g ? (v += x) : g < f && (v += 2 * x)
                  }
                  for (var b = 0; b < m.length; b++) m[b] = m[b] / v
                  ;(h.envMap.value = t.texture),
                    (h.samples.value = f),
                    (h.weights.value = m),
                    (h.latitudinal.value = 'latitudinal' === a),
                    o && (h.poleAxis.value = o),
                    (h.dTheta.value = p),
                    (h.mipInt.value = 8 - n),
                    (h.inputEncoding.value = bp[t.texture.encoding]),
                    (h.outputEncoding.value = bp[t.texture.encoding])
                  var _ = Sp[r]
                  Op(
                    e,
                    3 * Math.max(0, gp - 2 * _),
                    (0 === r ? 0 : 2 * gp) + 2 * _ * (4 < r ? r - 8 + 4 : 0),
                    3 * _,
                    2 * _,
                  ),
                    s.setRenderTarget(e),
                    s.render(l, _p)
                },
              }
              function Up(t) {
                console.warn(
                  'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.',
                ),
                  nh.call(this, t),
                  (this.type = 'catmullrom'),
                  (this.closed = !0)
              }
              function zp(t) {
                console.warn(
                  'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.',
                ),
                  nh.call(this, t),
                  (this.type = 'catmullrom')
              }
              function Fp(t) {
                console.warn(
                  'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.',
                ),
                  nh.call(this, t),
                  (this.type = 'catmullrom')
              }
              ;(Yl.create = function (t, e) {
                return (
                  console.log('THREE.Curve.create() has been deprecated'),
                  (t.prototype = Object.create(Yl.prototype)),
                  ((t.prototype.constructor = t).prototype.getPoint = e),
                  t
                )
              }),
                Object.assign(fh.prototype, {
                  createPointsGeometry: function (t) {
                    console.warn(
                      'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.',
                    )
                    var e = this.getPoints(t)
                    return this.createGeometry(e)
                  },
                  createSpacedPointsGeometry: function (t) {
                    console.warn(
                      'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.',
                    )
                    var e = this.getSpacedPoints(t)
                    return this.createGeometry(e)
                  },
                  createGeometry: function (t) {
                    console.warn(
                      'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.',
                    )
                    for (var e = new Mi(), n = 0, r = t.length; n < r; n++) {
                      var i = t[n]
                      e.vertices.push(new on(i.x, i.y, i.z || 0))
                    }
                    return e
                  },
                }),
                Object.assign(mh.prototype, {
                  fromPoints: function (t) {
                    return (
                      console.warn(
                        'THREE.Path: .fromPoints() has been renamed to .setFromPoints().',
                      ),
                      this.setFromPoints(t)
                    )
                  },
                }),
                (Up.prototype = Object.create(nh.prototype)),
                (zp.prototype = Object.create(nh.prototype)),
                (Fp.prototype = Object.create(nh.prototype)),
                Object.assign(Fp.prototype, {
                  initFromArray: function () {
                    console.error(
                      'THREE.Spline: .initFromArray() has been removed.',
                    )
                  },
                  getControlPointsArray: function () {
                    console.error(
                      'THREE.Spline: .getControlPointsArray() has been removed.',
                    )
                  },
                  reparametrizeByArcLength: function () {
                    console.error(
                      'THREE.Spline: .reparametrizeByArcLength() has been removed.',
                    )
                  },
                }),
                (Ku.prototype.setColors = function () {
                  console.error(
                    'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.',
                  )
                }),
                (qu.prototype.update = function () {
                  console.error(
                    'THREE.SkeletonHelper: update() no longer needs to be called.',
                  )
                }),
                Object.assign(Fl.prototype, {
                  extractUrlBase: function (t) {
                    return (
                      console.warn(
                        'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.',
                      ),
                      Oh.extractUrlBase(t)
                    )
                  },
                }),
                (Fl.Handlers = {
                  add: function () {
                    console.error(
                      'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.',
                    )
                  },
                  get: function () {
                    console.error(
                      'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.',
                    )
                  },
                }),
                Object.assign(Uh.prototype, {
                  setTexturePath: function (t) {
                    return (
                      console.warn(
                        'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().',
                      ),
                      this.setResourcePath(t)
                    )
                  },
                }),
                Object.assign(Nu.prototype, {
                  center: function (t) {
                    return (
                      console.warn(
                        'THREE.Box2: .center() has been renamed to .getCenter().',
                      ),
                      this.getCenter(t)
                    )
                  },
                  empty: function () {
                    return (
                      console.warn(
                        'THREE.Box2: .empty() has been renamed to .isEmpty().',
                      ),
                      this.isEmpty()
                    )
                  },
                  isIntersectionBox: function (t) {
                    return (
                      console.warn(
                        'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().',
                      ),
                      this.intersectsBox(t)
                    )
                  },
                  size: function (t) {
                    return (
                      console.warn(
                        'THREE.Box2: .size() has been renamed to .getSize().',
                      ),
                      this.getSize(t)
                    )
                  },
                }),
                Object.assign(Xn.prototype, {
                  center: function (t) {
                    return (
                      console.warn(
                        'THREE.Box3: .center() has been renamed to .getCenter().',
                      ),
                      this.getCenter(t)
                    )
                  },
                  empty: function () {
                    return (
                      console.warn(
                        'THREE.Box3: .empty() has been renamed to .isEmpty().',
                      ),
                      this.isEmpty()
                    )
                  },
                  isIntersectionBox: function (t) {
                    return (
                      console.warn(
                        'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().',
                      ),
                      this.intersectsBox(t)
                    )
                  },
                  isIntersectionSphere: function (t) {
                    return (
                      console.warn(
                        'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().',
                      ),
                      this.intersectsSphere(t)
                    )
                  },
                  size: function (t) {
                    return (
                      console.warn(
                        'THREE.Box3: .size() has been renamed to .getSize().',
                      ),
                      this.getSize(t)
                    )
                  },
                }),
                Object.assign(Jn.prototype, {
                  empty: function () {
                    return (
                      console.warn(
                        'THREE.Sphere: .empty() has been renamed to .isEmpty().',
                      ),
                      this.isEmpty()
                    )
                  },
                }),
                (Fi.prototype.setFromMatrix = function (t) {
                  return (
                    console.warn(
                      'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().',
                    ),
                    this.setFromProjectionMatrix(t)
                  )
                }),
                (Fu.prototype.center = function (t) {
                  return (
                    console.warn(
                      'THREE.Line3: .center() has been renamed to .getCenter().',
                    ),
                    this.getCenter(t)
                  )
                }),
                Object.assign(Xe, {
                  random16: function () {
                    return (
                      console.warn(
                        'THREE.Math: .random16() has been deprecated. Use Math.random() instead.',
                      ),
                      Math.random()
                    )
                  },
                  nearestPowerOfTwo: function (t) {
                    return (
                      console.warn(
                        'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().',
                      ),
                      Xe.floorPowerOfTwo(t)
                    )
                  },
                  nextPowerOfTwo: function (t) {
                    return (
                      console.warn(
                        'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().',
                      ),
                      Xe.ceilPowerOfTwo(t)
                    )
                  },
                }),
                Object.assign(Ze.prototype, {
                  flattenToArrayOffset: function (t, e) {
                    return (
                      console.warn(
                        'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
                      ),
                      this.toArray(t, e)
                    )
                  },
                  multiplyVector3: function (t) {
                    return (
                      console.warn(
                        'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.',
                      ),
                      t.applyMatrix3(this)
                    )
                  },
                  multiplyVector3Array: function () {
                    console.error(
                      'THREE.Matrix3: .multiplyVector3Array() has been removed.',
                    )
                  },
                  applyToBufferAttribute: function (t) {
                    return (
                      console.warn(
                        'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.',
                      ),
                      t.applyMatrix3(this)
                    )
                  },
                  applyToVector3Array: function () {
                    console.error(
                      'THREE.Matrix3: .applyToVector3Array() has been removed.',
                    )
                  },
                }),
                Object.assign(fn.prototype, {
                  extractPosition: function (t) {
                    return (
                      console.warn(
                        'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().',
                      ),
                      this.copyPosition(t)
                    )
                  },
                  flattenToArrayOffset: function (t, e) {
                    return (
                      console.warn(
                        'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
                      ),
                      this.toArray(t, e)
                    )
                  },
                  getPosition: function () {
                    return (
                      console.warn(
                        'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.',
                      ),
                      new on().setFromMatrixColumn(this, 3)
                    )
                  },
                  setRotationFromQuaternion: function (t) {
                    return (
                      console.warn(
                        'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().',
                      ),
                      this.makeRotationFromQuaternion(t)
                    )
                  },
                  multiplyToArray: function () {
                    console.warn(
                      'THREE.Matrix4: .multiplyToArray() has been removed.',
                    )
                  },
                  multiplyVector3: function (t) {
                    return (
                      console.warn(
                        'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.',
                      ),
                      t.applyMatrix4(this)
                    )
                  },
                  multiplyVector4: function (t) {
                    return (
                      console.warn(
                        'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.',
                      ),
                      t.applyMatrix4(this)
                    )
                  },
                  multiplyVector3Array: function () {
                    console.error(
                      'THREE.Matrix4: .multiplyVector3Array() has been removed.',
                    )
                  },
                  rotateAxis: function (t) {
                    console.warn(
                      'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.',
                    ),
                      t.transformDirection(this)
                  },
                  crossVector: function (t) {
                    return (
                      console.warn(
                        'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.',
                      ),
                      t.applyMatrix4(this)
                    )
                  },
                  translate: function () {
                    console.error(
                      'THREE.Matrix4: .translate() has been removed.',
                    )
                  },
                  rotateX: function () {
                    console.error('THREE.Matrix4: .rotateX() has been removed.')
                  },
                  rotateY: function () {
                    console.error('THREE.Matrix4: .rotateY() has been removed.')
                  },
                  rotateZ: function () {
                    console.error('THREE.Matrix4: .rotateZ() has been removed.')
                  },
                  rotateByAxis: function () {
                    console.error(
                      'THREE.Matrix4: .rotateByAxis() has been removed.',
                    )
                  },
                  applyToBufferAttribute: function (t) {
                    return (
                      console.warn(
                        'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.',
                      ),
                      t.applyMatrix4(this)
                    )
                  },
                  applyToVector3Array: function () {
                    console.error(
                      'THREE.Matrix4: .applyToVector3Array() has been removed.',
                    )
                  },
                  makeFrustum: function (t, e, n, r, i, a) {
                    return (
                      console.warn(
                        'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.',
                      ),
                      this.makePerspective(t, e, r, n, i, a)
                    )
                  },
                }),
                (cr.prototype.isIntersectionLine = function (t) {
                  return (
                    console.warn(
                      'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().',
                    ),
                    this.intersectsLine(t)
                  )
                }),
                (nn.prototype.multiplyVector3 = function (t) {
                  return (
                    console.warn(
                      'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.',
                    ),
                    t.applyQuaternion(this)
                  )
                }),
                Object.assign(ir.prototype, {
                  isIntersectionBox: function (t) {
                    return (
                      console.warn(
                        'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().',
                      ),
                      this.intersectsBox(t)
                    )
                  },
                  isIntersectionPlane: function (t) {
                    return (
                      console.warn(
                        'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().',
                      ),
                      this.intersectsPlane(t)
                    )
                  },
                  isIntersectionSphere: function (t) {
                    return (
                      console.warn(
                        'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().',
                      ),
                      this.intersectsSphere(t)
                    )
                  },
                }),
                Object.assign(xr.prototype, {
                  area: function () {
                    return (
                      console.warn(
                        'THREE.Triangle: .area() has been renamed to .getArea().',
                      ),
                      this.getArea()
                    )
                  },
                  barycoordFromPoint: function (t, e) {
                    return (
                      console.warn(
                        'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',
                      ),
                      this.getBarycoord(t, e)
                    )
                  },
                  midpoint: function (t) {
                    return (
                      console.warn(
                        'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().',
                      ),
                      this.getMidpoint(t)
                    )
                  },
                  normal: function (t) {
                    return (
                      console.warn(
                        'THREE.Triangle: .normal() has been renamed to .getNormal().',
                      ),
                      this.getNormal(t)
                    )
                  },
                  plane: function (t) {
                    return (
                      console.warn(
                        'THREE.Triangle: .plane() has been renamed to .getPlane().',
                      ),
                      this.getPlane(t)
                    )
                  },
                }),
                Object.assign(xr, {
                  barycoordFromPoint: function (t, e, n, r, i) {
                    return (
                      console.warn(
                        'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',
                      ),
                      xr.getBarycoord(t, e, n, r, i)
                    )
                  },
                  normal: function (t, e, n, r) {
                    return (
                      console.warn(
                        'THREE.Triangle: .normal() has been renamed to .getNormal().',
                      ),
                      xr.getNormal(t, e, n, r)
                    )
                  },
                }),
                Object.assign(vh.prototype, {
                  extractAllPoints: function (t) {
                    return (
                      console.warn(
                        'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.',
                      ),
                      this.extractPoints(t)
                    )
                  },
                  extrude: function (t) {
                    return (
                      console.warn(
                        'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.',
                      ),
                      new Gc(this, t)
                    )
                  },
                  makeGeometry: function (t) {
                    return (
                      console.warn(
                        'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.',
                      ),
                      new $c(this, t)
                    )
                  },
                }),
                Object.assign(Ye.prototype, {
                  fromAttribute: function (t, e, n) {
                    return (
                      console.warn(
                        'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().',
                      ),
                      this.fromBufferAttribute(t, e, n)
                    )
                  },
                  distanceToManhattan: function (t) {
                    return (
                      console.warn(
                        'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
                      ),
                      this.manhattanDistanceTo(t)
                    )
                  },
                  lengthManhattan: function () {
                    return (
                      console.warn(
                        'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().',
                      ),
                      this.manhattanLength()
                    )
                  },
                }),
                Object.assign(on.prototype, {
                  setEulerFromRotationMatrix: function () {
                    console.error(
                      'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.',
                    )
                  },
                  setEulerFromQuaternion: function () {
                    console.error(
                      'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.',
                    )
                  },
                  getPositionFromMatrix: function (t) {
                    return (
                      console.warn(
                        'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().',
                      ),
                      this.setFromMatrixPosition(t)
                    )
                  },
                  getScaleFromMatrix: function (t) {
                    return (
                      console.warn(
                        'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().',
                      ),
                      this.setFromMatrixScale(t)
                    )
                  },
                  getColumnFromMatrix: function (t, e) {
                    return (
                      console.warn(
                        'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().',
                      ),
                      this.setFromMatrixColumn(e, t)
                    )
                  },
                  applyProjection: function (t) {
                    return (
                      console.warn(
                        'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.',
                      ),
                      this.applyMatrix4(t)
                    )
                  },
                  fromAttribute: function (t, e, n) {
                    return (
                      console.warn(
                        'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().',
                      ),
                      this.fromBufferAttribute(t, e, n)
                    )
                  },
                  distanceToManhattan: function (t) {
                    return (
                      console.warn(
                        'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
                      ),
                      this.manhattanDistanceTo(t)
                    )
                  },
                  lengthManhattan: function () {
                    return (
                      console.warn(
                        'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().',
                      ),
                      this.manhattanLength()
                    )
                  },
                }),
                Object.assign($e.prototype, {
                  fromAttribute: function (t, e, n) {
                    return (
                      console.warn(
                        'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().',
                      ),
                      this.fromBufferAttribute(t, e, n)
                    )
                  },
                  lengthManhattan: function () {
                    return (
                      console.warn(
                        'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().',
                      ),
                      this.manhattanLength()
                    )
                  },
                }),
                Object.assign(Mi.prototype, {
                  computeTangents: function () {
                    console.error(
                      'THREE.Geometry: .computeTangents() has been removed.',
                    )
                  },
                  computeLineDistances: function () {
                    console.error(
                      'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.',
                    )
                  },
                  applyMatrix: function (t) {
                    return (
                      console.warn(
                        'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().',
                      ),
                      this.applyMatrix4(t)
                    )
                  },
                }),
                Object.assign(On.prototype, {
                  getChildByName: function (t) {
                    return (
                      console.warn(
                        'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().',
                      ),
                      this.getObjectByName(t)
                    )
                  },
                  renderDepth: function () {
                    console.warn(
                      'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.',
                    )
                  },
                  translate: function (t, e) {
                    return (
                      console.warn(
                        'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.',
                      ),
                      this.translateOnAxis(e, t)
                    )
                  },
                  getWorldRotation: function () {
                    console.error(
                      'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.',
                    )
                  },
                  applyMatrix: function (t) {
                    return (
                      console.warn(
                        'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().',
                      ),
                      this.applyMatrix4(t)
                    )
                  },
                }),
                Object.defineProperties(On.prototype, {
                  eulerOrder: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.Object3D: .eulerOrder is now .rotation.order.',
                        ),
                        this.rotation.order
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.Object3D: .eulerOrder is now .rotation.order.',
                      ),
                        (this.rotation.order = t)
                    },
                  },
                  useQuaternion: {
                    get: function () {
                      console.warn(
                        'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
                      )
                    },
                  },
                }),
                Object.assign(vi.prototype, {
                  setDrawMode: function () {
                    console.error(
                      'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',
                    )
                  },
                }),
                Object.defineProperties(vi.prototype, {
                  drawMode: {
                    get: function () {
                      return (
                        console.error(
                          'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.',
                        ),
                        0
                      )
                    },
                    set: function () {
                      console.error(
                        'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',
                      )
                    },
                  },
                }),
                Object.defineProperties(Ms.prototype, {
                  objects: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.LOD: .objects has been renamed to .levels.',
                        ),
                        this.levels
                      )
                    },
                  },
                }),
                Object.defineProperty(As.prototype, 'useVertexTexture', {
                  get: function () {
                    console.warn(
                      'THREE.Skeleton: useVertexTexture has been removed.',
                    )
                  },
                  set: function () {
                    console.warn(
                      'THREE.Skeleton: useVertexTexture has been removed.',
                    )
                  },
                }),
                (Ss.prototype.initBones = function () {
                  console.error(
                    'THREE.SkinnedMesh: initBones() has been removed.',
                  )
                }),
                Object.defineProperty(Yl.prototype, '__arcLengthDivisions', {
                  get: function () {
                    return (
                      console.warn(
                        'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.',
                      ),
                      this.arcLengthDivisions
                    )
                  },
                  set: function (t) {
                    console.warn(
                      'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.',
                    ),
                      (this.arcLengthDivisions = t)
                  },
                }),
                (Ii.prototype.setLens = function (t, e) {
                  console.warn(
                    'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.',
                  ),
                    void 0 !== e && (this.filmGauge = e),
                    this.setFocalLength(t)
                }),
                Object.defineProperties(gh.prototype, {
                  onlyShadow: {
                    set: function () {
                      console.warn('THREE.Light: .onlyShadow has been removed.')
                    },
                  },
                  shadowCameraFov: {
                    set: function (t) {
                      console.warn(
                        'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.',
                      ),
                        (this.shadow.camera.fov = t)
                    },
                  },
                  shadowCameraLeft: {
                    set: function (t) {
                      console.warn(
                        'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.',
                      ),
                        (this.shadow.camera.left = t)
                    },
                  },
                  shadowCameraRight: {
                    set: function (t) {
                      console.warn(
                        'THREE.Light: .shadowCameraRight is now .shadow.camera.right.',
                      ),
                        (this.shadow.camera.right = t)
                    },
                  },
                  shadowCameraTop: {
                    set: function (t) {
                      console.warn(
                        'THREE.Light: .shadowCameraTop is now .shadow.camera.top.',
                      ),
                        (this.shadow.camera.top = t)
                    },
                  },
                  shadowCameraBottom: {
                    set: function (t) {
                      console.warn(
                        'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.',
                      ),
                        (this.shadow.camera.bottom = t)
                    },
                  },
                  shadowCameraNear: {
                    set: function (t) {
                      console.warn(
                        'THREE.Light: .shadowCameraNear is now .shadow.camera.near.',
                      ),
                        (this.shadow.camera.near = t)
                    },
                  },
                  shadowCameraFar: {
                    set: function (t) {
                      console.warn(
                        'THREE.Light: .shadowCameraFar is now .shadow.camera.far.',
                      ),
                        (this.shadow.camera.far = t)
                    },
                  },
                  shadowCameraVisible: {
                    set: function () {
                      console.warn(
                        'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.',
                      )
                    },
                  },
                  shadowBias: {
                    set: function (t) {
                      console.warn(
                        'THREE.Light: .shadowBias is now .shadow.bias.',
                      ),
                        (this.shadow.bias = t)
                    },
                  },
                  shadowDarkness: {
                    set: function () {
                      console.warn(
                        'THREE.Light: .shadowDarkness has been removed.',
                      )
                    },
                  },
                  shadowMapWidth: {
                    set: function (t) {
                      console.warn(
                        'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.',
                      ),
                        (this.shadow.mapSize.width = t)
                    },
                  },
                  shadowMapHeight: {
                    set: function (t) {
                      console.warn(
                        'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.',
                      ),
                        (this.shadow.mapSize.height = t)
                    },
                  },
                }),
                Object.defineProperties(Ir.prototype, {
                  length: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.BufferAttribute: .length has been deprecated. Use .count instead.',
                        ),
                        this.array.length
                      )
                    },
                  },
                  dynamic: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',
                        ),
                        this.usage === ke
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',
                      ),
                        this.setUsage(ke)
                    },
                  },
                }),
                Object.assign(Ir.prototype, {
                  setDynamic: function (t) {
                    return (
                      console.warn(
                        'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.',
                      ),
                      this.setUsage(!0 === t ? ke : Ge),
                      this
                    )
                  },
                  copyIndicesArray: function () {
                    console.error(
                      'THREE.BufferAttribute: .copyIndicesArray() has been removed.',
                    )
                  },
                  setArray: function () {
                    console.error(
                      'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',
                    )
                  },
                }),
                Object.assign(Kr.prototype, {
                  addIndex: function (t) {
                    console.warn(
                      'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().',
                    ),
                      this.setIndex(t)
                  },
                  addAttribute: function (t, e) {
                    return (
                      console.warn(
                        'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().',
                      ),
                      (e && e.isBufferAttribute) ||
                      (e && e.isInterleavedBufferAttribute)
                        ? 'index' === t
                          ? (console.warn(
                              'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.',
                            ),
                            this.setIndex(e),
                            this)
                          : this.setAttribute(t, e)
                        : (console.warn(
                            'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).',
                          ),
                          this.setAttribute(t, new Ir(e, arguments[2])))
                    )
                  },
                  addDrawCall: function (t, e, n) {
                    void 0 !== n &&
                      console.warn(
                        'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.',
                      ),
                      console.warn(
                        'THREE.BufferGeometry: .addDrawCall() is now .addGroup().',
                      ),
                      this.addGroup(t, e)
                  },
                  clearDrawCalls: function () {
                    console.warn(
                      'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().',
                    ),
                      this.clearGroups()
                  },
                  computeTangents: function () {
                    console.warn(
                      'THREE.BufferGeometry: .computeTangents() has been removed.',
                    )
                  },
                  computeOffsets: function () {
                    console.warn(
                      'THREE.BufferGeometry: .computeOffsets() has been removed.',
                    )
                  },
                  removeAttribute: function (t) {
                    return (
                      console.warn(
                        'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().',
                      ),
                      this.deleteAttribute(t)
                    )
                  },
                  applyMatrix: function (t) {
                    return (
                      console.warn(
                        'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().',
                      ),
                      this.applyMatrix4(t)
                    )
                  },
                }),
                Object.defineProperties(Kr.prototype, {
                  drawcalls: {
                    get: function () {
                      return (
                        console.error(
                          'THREE.BufferGeometry: .drawcalls has been renamed to .groups.',
                        ),
                        this.groups
                      )
                    },
                  },
                  offsets: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.BufferGeometry: .offsets has been renamed to .groups.',
                        ),
                        this.groups
                      )
                    },
                  },
                }),
                Object.defineProperties(Ih.prototype, {
                  maxInstancedCount: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.',
                        ),
                        this.instanceCount
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.',
                      ),
                        (this.instanceCount = t)
                    },
                  },
                }),
                Object.defineProperties(Cu.prototype, {
                  linePrecision: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.',
                        ),
                        this.params.Line.threshold
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.',
                      ),
                        (this.params.Line.threshold = t)
                    },
                  },
                }),
                Object.defineProperties(Qo.prototype, {
                  dynamic: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.',
                        ),
                        this.usage === ke
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.',
                      ),
                        this.setUsage(t)
                    },
                  },
                }),
                Object.assign(Qo.prototype, {
                  setDynamic: function (t) {
                    return (
                      console.warn(
                        'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.',
                      ),
                      this.setUsage(!0 === t ? ke : Ge),
                      this
                    )
                  },
                  setArray: function () {
                    console.error(
                      'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',
                    )
                  },
                }),
                Object.assign(kc.prototype, {
                  getArrays: function () {
                    console.error(
                      'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.',
                    )
                  },
                  addShapeList: function () {
                    console.error(
                      'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.',
                    )
                  },
                  addShape: function () {
                    console.error(
                      'THREE.ExtrudeBufferGeometry: .addShape() has been removed.',
                    )
                  },
                }),
                Object.defineProperties(Lu.prototype, {
                  dynamic: {
                    set: function () {
                      console.warn(
                        'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.',
                      )
                    },
                  },
                  onUpdate: {
                    value: function () {
                      return (
                        console.warn(
                          'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.',
                        ),
                        this
                      )
                    },
                  },
                }),
                Object.defineProperties(Rr.prototype, {
                  wrapAround: {
                    get: function () {
                      console.warn(
                        'THREE.Material: .wrapAround has been removed.',
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.Material: .wrapAround has been removed.',
                      )
                    },
                  },
                  overdraw: {
                    get: function () {
                      console.warn(
                        'THREE.Material: .overdraw has been removed.',
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.Material: .overdraw has been removed.',
                      )
                    },
                  },
                  wrapRGB: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.Material: .wrapRGB has been removed.',
                        ),
                        new Mr()
                      )
                    },
                  },
                  shading: {
                    get: function () {
                      console.error(
                        'THREE.' +
                          this.type +
                          ': .shading has been removed. Use the boolean .flatShading instead.',
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.' +
                          this.type +
                          ': .shading has been removed. Use the boolean .flatShading instead.',
                      ),
                        (this.flatShading = 1 === t)
                    },
                  },
                  stencilMask: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.' +
                            this.type +
                            ': .stencilMask has been removed. Use .stencilFuncMask instead.',
                        ),
                        this.stencilFuncMask
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.' +
                          this.type +
                          ': .stencilMask has been removed. Use .stencilFuncMask instead.',
                      ),
                        (this.stencilFuncMask = t)
                    },
                  },
                }),
                Object.defineProperties(fl.prototype, {
                  metal: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.',
                        ),
                        !1
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead',
                      )
                    },
                  },
                }),
                Object.defineProperties(Pi.prototype, {
                  derivatives: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
                        ),
                        this.extensions.derivatives
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
                      ),
                        (this.extensions.derivatives = t)
                    },
                  },
                }),
                Object.assign(Xo.prototype, {
                  clearTarget: function (t, e, n, r) {
                    console.warn(
                      'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.',
                    ),
                      this.setRenderTarget(t),
                      this.clear(e, n, r)
                  },
                  animate: function (t) {
                    console.warn(
                      'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().',
                    ),
                      this.setAnimationLoop(t)
                  },
                  getCurrentRenderTarget: function () {
                    return (
                      console.warn(
                        'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().',
                      ),
                      this.getRenderTarget()
                    )
                  },
                  getMaxAnisotropy: function () {
                    return (
                      console.warn(
                        'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().',
                      ),
                      this.capabilities.getMaxAnisotropy()
                    )
                  },
                  getPrecision: function () {
                    return (
                      console.warn(
                        'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.',
                      ),
                      this.capabilities.precision
                    )
                  },
                  resetGLState: function () {
                    return (
                      console.warn(
                        'THREE.WebGLRenderer: .resetGLState() is now .state.reset().',
                      ),
                      this.state.reset()
                    )
                  },
                  supportsFloatTextures: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).",
                      ),
                      this.extensions.get('OES_texture_float')
                    )
                  },
                  supportsHalfFloatTextures: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).",
                      ),
                      this.extensions.get('OES_texture_half_float')
                    )
                  },
                  supportsStandardDerivatives: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).",
                      ),
                      this.extensions.get('OES_standard_derivatives')
                    )
                  },
                  supportsCompressedTextureS3TC: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).",
                      ),
                      this.extensions.get('WEBGL_compressed_texture_s3tc')
                    )
                  },
                  supportsCompressedTexturePVRTC: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).",
                      ),
                      this.extensions.get('WEBGL_compressed_texture_pvrtc')
                    )
                  },
                  supportsBlendMinMax: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).",
                      ),
                      this.extensions.get('EXT_blend_minmax')
                    )
                  },
                  supportsVertexTextures: function () {
                    return (
                      console.warn(
                        'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.',
                      ),
                      this.capabilities.vertexTextures
                    )
                  },
                  supportsInstancedArrays: function () {
                    return (
                      console.warn(
                        "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).",
                      ),
                      this.extensions.get('ANGLE_instanced_arrays')
                    )
                  },
                  enableScissorTest: function (t) {
                    console.warn(
                      'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().',
                    ),
                      this.setScissorTest(t)
                  },
                  initMaterial: function () {
                    console.warn(
                      'THREE.WebGLRenderer: .initMaterial() has been removed.',
                    )
                  },
                  addPrePlugin: function () {
                    console.warn(
                      'THREE.WebGLRenderer: .addPrePlugin() has been removed.',
                    )
                  },
                  addPostPlugin: function () {
                    console.warn(
                      'THREE.WebGLRenderer: .addPostPlugin() has been removed.',
                    )
                  },
                  updateShadowMap: function () {
                    console.warn(
                      'THREE.WebGLRenderer: .updateShadowMap() has been removed.',
                    )
                  },
                  setFaceCulling: function () {
                    console.warn(
                      'THREE.WebGLRenderer: .setFaceCulling() has been removed.',
                    )
                  },
                  allocTextureUnit: function () {
                    console.warn(
                      'THREE.WebGLRenderer: .allocTextureUnit() has been removed.',
                    )
                  },
                  setTexture: function () {
                    console.warn(
                      'THREE.WebGLRenderer: .setTexture() has been removed.',
                    )
                  },
                  setTexture2D: function () {
                    console.warn(
                      'THREE.WebGLRenderer: .setTexture2D() has been removed.',
                    )
                  },
                  setTextureCube: function () {
                    console.warn(
                      'THREE.WebGLRenderer: .setTextureCube() has been removed.',
                    )
                  },
                  getActiveMipMapLevel: function () {
                    return (
                      console.warn(
                        'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().',
                      ),
                      this.getActiveMipmapLevel()
                    )
                  },
                }),
                Object.defineProperties(Xo.prototype, {
                  shadowMapEnabled: {
                    get: function () {
                      return this.shadowMap.enabled
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.',
                      ),
                        (this.shadowMap.enabled = t)
                    },
                  },
                  shadowMapType: {
                    get: function () {
                      return this.shadowMap.type
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.',
                      ),
                        (this.shadowMap.type = t)
                    },
                  },
                  shadowMapCullFace: {
                    get: function () {
                      console.warn(
                        'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
                      )
                    },
                  },
                  context: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.',
                        ),
                        this.getContext()
                      )
                    },
                  },
                  vr: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderer: .vr has been renamed to .xr',
                        ),
                        this.xr
                      )
                    },
                  },
                  gammaInput: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',
                        ),
                        !1
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',
                      )
                    },
                  },
                  gammaOutput: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',
                        ),
                        !1
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',
                      ),
                        (this.outputEncoding = !0 === t ? Ce : Re)
                    },
                  },
                  toneMappingWhitePoint: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.',
                        ),
                        1
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.',
                      )
                    },
                  },
                }),
                Object.defineProperties(zo.prototype, {
                  cullFace: {
                    get: function () {
                      console.warn(
                        'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
                      )
                    },
                  },
                  renderReverseSided: {
                    get: function () {
                      console.warn(
                        'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
                      )
                    },
                  },
                  renderSingleSided: {
                    get: function () {
                      console.warn(
                        'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
                      )
                    },
                    set: function () {
                      console.warn(
                        'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
                      )
                    },
                  },
                }),
                Object.defineProperties(tn.prototype, {
                  wrapS: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.',
                        ),
                        this.texture.wrapS
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.',
                      ),
                        (this.texture.wrapS = t)
                    },
                  },
                  wrapT: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.',
                        ),
                        this.texture.wrapT
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.',
                      ),
                        (this.texture.wrapT = t)
                    },
                  },
                  magFilter: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',
                        ),
                        this.texture.magFilter
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',
                      ),
                        (this.texture.magFilter = t)
                    },
                  },
                  minFilter: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',
                        ),
                        this.texture.minFilter
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',
                      ),
                        (this.texture.minFilter = t)
                    },
                  },
                  anisotropy: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',
                        ),
                        this.texture.anisotropy
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',
                      ),
                        (this.texture.anisotropy = t)
                    },
                  },
                  offset: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderTarget: .offset is now .texture.offset.',
                        ),
                        this.texture.offset
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderTarget: .offset is now .texture.offset.',
                      ),
                        (this.texture.offset = t)
                    },
                  },
                  repeat: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.',
                        ),
                        this.texture.repeat
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.',
                      ),
                        (this.texture.repeat = t)
                    },
                  },
                  format: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderTarget: .format is now .texture.format.',
                        ),
                        this.texture.format
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderTarget: .format is now .texture.format.',
                      ),
                        (this.texture.format = t)
                    },
                  },
                  type: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderTarget: .type is now .texture.type.',
                        ),
                        this.texture.type
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderTarget: .type is now .texture.type.',
                      ),
                        (this.texture.type = t)
                    },
                  },
                  generateMipmaps: {
                    get: function () {
                      return (
                        console.warn(
                          'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
                        ),
                        this.texture.generateMipmaps
                      )
                    },
                    set: function (t) {
                      console.warn(
                        'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
                      ),
                        (this.texture.generateMipmaps = t)
                    },
                  },
                }),
                Object.defineProperties(au.prototype, {
                  load: {
                    value: function (t) {
                      console.warn(
                        'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.',
                      )
                      var e = this
                      return (
                        new Xh().load(t, function (t) {
                          e.setBuffer(t)
                        }),
                        this
                      )
                    },
                  },
                  startTime: {
                    set: function () {
                      console.warn(
                        'THREE.Audio: .startTime is now .play( delay ).',
                      )
                    },
                  },
                }),
                (uu.prototype.getData = function () {
                  return (
                    console.warn(
                      'THREE.AudioAnalyser: .getData() is now .getFrequencyData().',
                    ),
                    this.getFrequencyData()
                  )
                }),
                (Di.prototype.updateCubeMap = function (t, e) {
                  return (
                    console.warn(
                      'THREE.CubeCamera: .updateCubeMap() is now .update().',
                    ),
                    this.update(t, e)
                  )
                })
              var Hp = {
                merge: function (t, e, n) {
                  var r
                  console.warn(
                    'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.',
                  ),
                    e.isMesh &&
                      (e.matrixAutoUpdate && e.updateMatrix(),
                      (r = e.matrix),
                      (e = e.geometry)),
                    t.merge(e, r, n)
                },
                center: function (t) {
                  return (
                    console.warn(
                      'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.',
                    ),
                    t.center()
                  )
                },
              }
              ;(Je.crossOrigin = void 0),
                (Je.loadTexture = function (t, e, n, r) {
                  console.warn(
                    'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.',
                  )
                  var i = new Xl()
                  i.setCrossOrigin(this.crossOrigin)
                  var a = i.load(t, n, void 0, r)
                  return e && (a.mapping = e), a
                }),
                (Je.loadTextureCube = function (t, e, n, r) {
                  console.warn(
                    'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.',
                  )
                  var i = new ql()
                  i.setCrossOrigin(this.crossOrigin)
                  var a = i.load(t, n, void 0, r)
                  return e && (a.mapping = e), a
                }),
                (Je.loadCompressedTexture = function () {
                  console.error(
                    'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.',
                  )
                }),
                (Je.loadCompressedTextureCube = function () {
                  console.error(
                    'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.',
                  )
                })
              var Gp = {
                createMultiMaterialObject: function () {
                  console.error(
                    'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js',
                  )
                },
                detach: function () {
                  console.error(
                    'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js',
                  )
                },
                attach: function () {
                  console.error(
                    'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js',
                  )
                },
              }
              'undefined' != typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(
                  new CustomEvent('register', {
                    detail: { revision: '118dev' },
                  }),
                ),
                (t.ACESFilmicToneMapping = Rt),
                (t.AddEquation = tt),
                (t.AddOperation = St),
                (t.AdditiveAnimationBlendMode = 2501),
                (t.AdditiveBlending = J),
                (t.AlphaFormat = h),
                (t.AlwaysDepth = gt),
                (t.AlwaysStencilFunc = He),
                (t.AmbientLight = Ah),
                (t.AmbientLightProbe = Zh),
                (t.AnimationClip = Dl),
                (t.AnimationLoader = kl),
                (t.AnimationMixer = Au),
                (t.AnimationObjectGroup = Eu),
                (t.AnimationUtils = _l),
                (t.ArcCurve = Jl),
                (t.ArrayCamera = ko),
                (t.ArrowHelper = mp),
                (t.Audio = au),
                (t.AudioAnalyser = uu),
                (t.AudioContext = qh),
                (t.AudioListener = iu),
                (t.AudioLoader = Xh),
                (t.AxesHelper = vp),
                (t.AxisHelper = function (t) {
                  return (
                    console.warn(
                      'THREE.AxisHelper has been renamed to THREE.AxesHelper.',
                    ),
                    new vp(t)
                  )
                }),
                (t.BackSide = q),
                (t.BasicDepthPacking = Be),
                (t.BasicShadowMap = 0),
                (t.BinaryTextureLoader = function (t) {
                  return (
                    console.warn(
                      'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.',
                    ),
                    new jl(t)
                  )
                }),
                (t.Bone = Ls),
                (t.BooleanKeyframeTrack = Al),
                (t.BoundingBoxHelper = function (t, e) {
                  return (
                    console.warn(
                      'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.',
                    ),
                    new lp(t, e)
                  )
                }),
                (t.Box2 = Nu),
                (t.Box3 = Xn),
                (t.Box3Helper = hp),
                (t.BoxBufferGeometry = Ei),
                (t.BoxGeometry = Si),
                (t.BoxHelper = lp),
                (t.BufferAttribute = Ir),
                (t.BufferGeometry = Kr),
                (t.BufferGeometryLoader = Bh),
                (t.ByteType = i),
                (t.Cache = Nl),
                (t.Camera = Oi),
                (t.CameraHelper = op),
                (t.CanvasRenderer = function () {
                  console.error('THREE.CanvasRenderer has been removed')
                }),
                (t.CanvasTexture = tc),
                (t.CatmullRomCurve3 = nh),
                (t.CineonToneMapping = Lt),
                (t.CircleBufferGeometry = cl),
                (t.CircleGeometry = sl),
                (t.ClampToEdgeWrapping = zt),
                (t.Clock = $h),
                (t.ClosedSplineCurve3 = Up),
                (t.Color = Mr),
                (t.ColorKeyframeTrack = Ll),
                (t.CompressedTexture = $s),
                (t.CompressedTextureLoader = Vl),
                (t.ConeBufferGeometry = ol),
                (t.ConeGeometry = al),
                (t.CubeCamera = Di),
                (t.CubeGeometry = Si),
                (t.CubeReflectionMapping = Pt),
                (t.CubeRefractionMapping = Ot),
                (t.CubeTexture = oa),
                (t.CubeTextureLoader = ql),
                (t.CubeUVReflectionMapping = Bt),
                (t.CubeUVRefractionMapping = Nt),
                (t.CubicBezierCurve = oh),
                (t.CubicBezierCurve3 = sh),
                (t.CubicInterpolant = Ml),
                (t.CullFaceBack = j),
                (t.CullFaceFront = W),
                (t.CullFaceFrontBack = 3),
                (t.CullFaceNone = V),
                (t.Curve = Yl),
                (t.CurvePath = fh),
                (t.CustomBlending = $),
                (t.CustomToneMapping = Ct),
                (t.CylinderBufferGeometry = il),
                (t.CylinderGeometry = rl),
                (t.Cylindrical = Du),
                (t.DataTexture = Ni),
                (t.DataTexture2DArray = sa),
                (t.DataTexture3D = ca),
                (t.DataTextureLoader = jl),
                (t.DecrementStencilOp = 7683),
                (t.DecrementWrapStencilOp = 34056),
                (t.DefaultLoadingManager = zl),
                (t.DepthFormat = te),
                (t.DepthStencilFormat = ee),
                (t.DepthTexture = ec),
                (t.DirectionalLight = Th),
                (t.DirectionalLightHelper = rp),
                (t.DirectionalLightShadow = Eh),
                (t.DiscreteInterpolant = El),
                (t.DodecahedronBufferGeometry = fc),
                (t.DodecahedronGeometry = dc),
                (t.DoubleSide = X),
                (t.DstAlphaFactor = ut),
                (t.DstColorFactor = dt),
                (t.DynamicBufferAttribute = function (t, e) {
                  return (
                    console.warn(
                      'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.',
                    ),
                    new Ir(t, e).setUsage(ke)
                  )
                }),
                (t.DynamicCopyUsage = 35050),
                (t.DynamicDrawUsage = ke),
                (t.DynamicReadUsage = 35049),
                (t.EdgesGeometry = nl),
                (t.EdgesHelper = function (t, e) {
                  return (
                    console.warn(
                      'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.',
                    ),
                    new Vs(
                      new nl(t.geometry),
                      new Ds({ color: void 0 !== e ? e : 16777215 }),
                    )
                  )
                }),
                (t.EllipseCurve = Zl),
                (t.EqualDepth = bt),
                (t.EqualStencilFunc = 514),
                (t.EquirectangularReflectionMapping = It),
                (t.EquirectangularRefractionMapping = Dt),
                (t.Euler = gn),
                (t.EventDispatcher = Ve),
                (t.ExtrudeBufferGeometry = kc),
                (t.ExtrudeGeometry = Gc),
                (t.Face3 = Ar),
                (t.Face4 = function (t, e, n, r, i, a, o) {
                  return (
                    console.warn(
                      'THREE.Face4 has been removed. A THREE.Face3 will be created instead.',
                    ),
                    new Ar(t, e, n, i, a, o)
                  )
                }),
                (t.FaceColors = 1),
                (t.FileLoader = Gl),
                (t.FlatShading = 1),
                (t.Float32Attribute = function (t, e) {
                  return (
                    console.warn(
                      'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.',
                    ),
                    new Gr(t, e)
                  )
                }),
                (t.Float32BufferAttribute = Gr),
                (t.Float64Attribute = function (t, e) {
                  return (
                    console.warn(
                      'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.',
                    ),
                    new kr(t, e)
                  )
                }),
                (t.Float64BufferAttribute = kr),
                (t.FloatType = Zt),
                (t.Fog = Jo),
                (t.FogExp2 = Zo),
                (t.Font = jh),
                (t.FontLoader = Wh),
                (t.FrontFaceDirectionCCW = 1),
                (t.FrontFaceDirectionCW = 0),
                (t.FrontSide = O),
                (t.Frustum = Fi),
                (t.GammaEncoding = Pe),
                (t.Geometry = Mi),
                (t.GeometryUtils = Hp),
                (t.GreaterDepth = wt),
                (t.GreaterEqualDepth = _t),
                (t.GreaterEqualStencilFunc = 518),
                (t.GreaterStencilFunc = 516),
                (t.GridHelper = Ku),
                (t.Group = Vo),
                (t.HalfFloatType = Jt),
                (t.HemisphereLight = yh),
                (t.HemisphereLightHelper = Qu),
                (t.HemisphereLightProbe = Yh),
                (t.IcosahedronBufferGeometry = pc),
                (t.IcosahedronGeometry = uc),
                (t.ImageBitmapLoader = kh),
                (t.ImageLoader = Wl),
                (t.ImageUtils = Je),
                (t.ImmediateRenderObject = Hu),
                (t.IncrementStencilOp = 7682),
                (t.IncrementWrapStencilOp = 34055),
                (t.InstancedBufferAttribute = Dh),
                (t.InstancedBufferGeometry = Ih),
                (t.InstancedInterleavedBuffer = Ru),
                (t.InstancedMesh = Is),
                (t.Int16Attribute = function (t, e) {
                  return (
                    console.warn(
                      'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.',
                    ),
                    new Ur(t, e)
                  )
                }),
                (t.Int16BufferAttribute = Ur),
                (t.Int32Attribute = function (t, e) {
                  return (
                    console.warn(
                      'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.',
                    ),
                    new Fr(t, e)
                  )
                }),
                (t.Int32BufferAttribute = Fr),
                (t.Int8Attribute = function (t, e) {
                  return (
                    console.warn(
                      'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.',
                    ),
                    new Dr(t, e)
                  )
                }),
                (t.Int8BufferAttribute = Dr),
                (t.IntType = o),
                (t.InterleavedBuffer = Qo),
                (t.InterleavedBufferAttribute = ts),
                (t.Interpolant = wl),
                (t.InterpolateDiscrete = r),
                (t.InterpolateLinear = Ee),
                (t.InterpolateSmooth = 2302),
                (t.InvertStencilOp = 5386),
                (t.JSONLoader = function () {
                  console.error('THREE.JSONLoader has been removed.')
                }),
                (t.KeepStencilOp = Fe),
                (t.KeyframeTrack = Tl),
                (t.LOD = Ms),
                (t.LatheBufferGeometry = Kc),
                (t.LatheGeometry = Qc),
                (t.Layers = yn),
                (t.LensFlare = function () {
                  console.error(
                    'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js',
                  )
                }),
                (t.LessDepth = yt),
                (t.LessEqualDepth = xt),
                (t.LessEqualStencilFunc = 515),
                (t.LessStencilFunc = 513),
                (t.Light = gh),
                (t.LightProbe = Ch),
                (t.LightShadow = xh),
                (t.Line = Hs),
                (t.Line3 = Fu),
                (t.LineBasicMaterial = Ds),
                (t.LineCurve = ch),
                (t.LineCurve3 = lh),
                (t.LineDashedMaterial = xl),
                (t.LineLoop = js),
                (t.LinePieces = 1),
                (t.LineSegments = Vs),
                (t.LineStrip = 0),
                (t.LinearEncoding = Re),
                (t.LinearFilter = Vt),
                (t.LinearInterpolant = Sl),
                (t.LinearMipMapLinearFilter = 1008),
                (t.LinearMipMapNearestFilter = 1007),
                (t.LinearMipmapLinearFilter = Wt),
                (t.LinearMipmapNearestFilter = jt),
                (t.LinearToneMapping = Tt),
                (t.Loader = Fl),
                (t.LoaderUtils = Oh),
                (t.LoadingManager = Ul),
                (t.LogLuvEncoding = e),
                (t.LoopOnce = 2200),
                (t.LoopPingPong = 2202),
                (t.LoopRepeat = 2201),
                (t.LuminanceAlphaFormat = p),
                (t.LuminanceFormat = u),
                (t.MOUSE = {
                  LEFT: 0,
                  MIDDLE: 1,
                  RIGHT: 2,
                  ROTATE: 0,
                  DOLLY: 1,
                  PAN: 2,
                }),
                (t.Material = Rr),
                (t.MaterialLoader = Ph),
                (t.Math = Xe),
                (t.MathUtils = Xe),
                (t.Matrix3 = Ze),
                (t.Matrix4 = fn),
                (t.MaxEquation = it),
                (t.Mesh = vi),
                (t.MeshBasicMaterial = Cr),
                (t.MeshDepthMaterial = Do),
                (t.MeshDistanceMaterial = Bo),
                (t.MeshFaceMaterial = function (t) {
                  return (
                    console.warn(
                      'THREE.MeshFaceMaterial has been removed. Use an Array instead.',
                    ),
                    t
                  )
                }),
                (t.MeshLambertMaterial = gl),
                (t.MeshMatcapMaterial = yl),
                (t.MeshNormalMaterial = vl),
                (t.MeshPhongMaterial = fl),
                (t.MeshPhysicalMaterial = dl),
                (t.MeshStandardMaterial = pl),
                (t.MeshToonMaterial = ml),
                (t.MinEquation = rt),
                (t.MirroredRepeatWrapping = Ft),
                (t.MixOperation = k),
                (t.MultiMaterial = function (t) {
                  return (
                    void 0 === t && (t = []),
                    console.warn(
                      'THREE.MultiMaterial has been removed. Use an Array instead.',
                    ),
                    (t.isMultiMaterial = !0),
                    ((t.materials = t).clone = function () {
                      return t.slice()
                    }),
                    t
                  )
                }),
                (t.MultiplyBlending = K),
                (t.MultiplyOperation = G),
                (t.NearestFilter = Ht),
                (t.NearestMipMapLinearFilter = 1005),
                (t.NearestMipMapNearestFilter = 1004),
                (t.NearestMipmapLinearFilter = kt),
                (t.NearestMipmapNearestFilter = Gt),
                (t.NeverDepth = vt),
                (t.NeverStencilFunc = 512),
                (t.NoBlending = Y),
                (t.NoColors = 0),
                (t.NoToneMapping = Et),
                (t.NormalAnimationBlendMode = 2500),
                (t.NormalBlending = Z),
                (t.NotEqualDepth = Mt),
                (t.NotEqualStencilFunc = 517),
                (t.NumberKeyframeTrack = Rl),
                (t.Object3D = On),
                (t.ObjectLoader = Uh),
                (t.ObjectSpaceNormalMap = ze),
                (t.OctahedronBufferGeometry = hc),
                (t.OctahedronGeometry = lc),
                (t.OneFactor = ot),
                (t.OneMinusDstAlphaFactor = pt),
                (t.OneMinusDstColorFactor = ft),
                (t.OneMinusSrcAlphaFactor = ht),
                (t.OneMinusSrcColorFactor = ct),
                (t.OrthographicCamera = Sh),
                (t.PCFShadowMap = z),
                (t.PCFSoftShadowMap = F),
                (t.PMREMGenerator = Cp),
                (t.ParametricBufferGeometry = ic),
                (t.ParametricGeometry = rc),
                (t.Particle = function (t) {
                  return (
                    console.warn(
                      'THREE.Particle has been renamed to THREE.Sprite.',
                    ),
                    new fs(t)
                  )
                }),
                (t.ParticleBasicMaterial = function (t) {
                  return (
                    console.warn(
                      'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.',
                    ),
                    new Ws(t)
                  )
                }),
                (t.ParticleSystem = function (t, e) {
                  return (
                    console.warn(
                      'THREE.ParticleSystem has been renamed to THREE.Points.',
                    ),
                    new Js(t, e)
                  )
                }),
                (t.ParticleSystemMaterial = function (t) {
                  return (
                    console.warn(
                      'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.',
                    ),
                    new Ws(t)
                  )
                }),
                (t.Path = mh),
                (t.PerspectiveCamera = Ii),
                (t.Plane = cr),
                (t.PlaneBufferGeometry = ji),
                (t.PlaneGeometry = Vi),
                (t.PlaneHelper = up),
                (t.PointCloud = function (t, e) {
                  return (
                    console.warn(
                      'THREE.PointCloud has been renamed to THREE.Points.',
                    ),
                    new Js(t, e)
                  )
                }),
                (t.PointCloudMaterial = function (t) {
                  return (
                    console.warn(
                      'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.',
                    ),
                    new Ws(t)
                  )
                }),
                (t.PointLight = Mh),
                (t.PointLightHelper = Xu),
                (t.Points = Js),
                (t.PointsMaterial = Ws),
                (t.PolarGridHelper = $u),
                (t.PolyhedronBufferGeometry = oc),
                (t.PolyhedronGeometry = ac),
                (t.PositionalAudio = hu),
                (t.PropertyBinding = Su),
                (t.PropertyMixer = pu),
                (t.QuadraticBezierCurve = hh),
                (t.QuadraticBezierCurve3 = uh),
                (t.Quaternion = nn),
                (t.QuaternionKeyframeTrack = Pl),
                (t.QuaternionLinearInterpolant = Cl),
                (t.REVISION = '118dev'),
                (t.RGBADepthPacking = Ne),
                (t.RGBAFormat = $t),
                (t.RGBAIntegerFormat = x),
                (t.RGBA_ASTC_10x10_Format = se),
                (t.RGBA_ASTC_10x5_Format = ie),
                (t.RGBA_ASTC_10x6_Format = ae),
                (t.RGBA_ASTC_10x8_Format = oe),
                (t.RGBA_ASTC_12x10_Format = ce),
                (t.RGBA_ASTC_12x12_Format = le),
                (t.RGBA_ASTC_4x4_Format = P),
                (t.RGBA_ASTC_5x4_Format = I),
                (t.RGBA_ASTC_5x5_Format = D),
                (t.RGBA_ASTC_6x5_Format = B),
                (t.RGBA_ASTC_6x6_Format = N),
                (t.RGBA_ASTC_8x5_Format = U),
                (t.RGBA_ASTC_8x6_Format = ne),
                (t.RGBA_ASTC_8x8_Format = re),
                (t.RGBA_BPTC_Format = he),
                (t.RGBA_ETC2_EAC_Format = C),
                (t.RGBA_PVRTC_2BPPV1_Format = A),
                (t.RGBA_PVRTC_4BPPV1_Format = T),
                (t.RGBA_S3TC_DXT1_Format = _),
                (t.RGBA_S3TC_DXT3_Format = w),
                (t.RGBA_S3TC_DXT5_Format = M),
                (t.RGBDEncoding = De),
                (t.RGBEEncoding = Oe),
                (t.RGBEFormat = d),
                (t.RGBFormat = Kt),
                (t.RGBIntegerFormat = y),
                (t.RGBM16Encoding = Ie),
                (t.RGBM7Encoding = n),
                (t.RGB_ETC1_Format = L),
                (t.RGB_ETC2_Format = R),
                (t.RGB_PVRTC_2BPPV1_Format = E),
                (t.RGB_PVRTC_4BPPV1_Format = S),
                (t.RGB_S3TC_DXT1_Format = b),
                (t.RGFormat = v),
                (t.RGIntegerFormat = g),
                (t.RawShaderMaterial = ul),
                (t.Ray = ir),
                (t.Raycaster = Cu),
                (t.RectAreaLight = Lh),
                (t.RedFormat = f),
                (t.RedIntegerFormat = m),
                (t.ReinhardToneMapping = At),
                (t.RepeatWrapping = Ut),
                (t.ReplaceStencilOp = 7681),
                (t.ReverseSubtractEquation = nt),
                (t.RingBufferGeometry = Jc),
                (t.RingGeometry = Zc),
                (t.SRGB8_ALPHA8_ASTC_10x10_Format = we),
                (t.SRGB8_ALPHA8_ASTC_10x5_Format = xe),
                (t.SRGB8_ALPHA8_ASTC_10x6_Format = be),
                (t.SRGB8_ALPHA8_ASTC_10x8_Format = _e),
                (t.SRGB8_ALPHA8_ASTC_12x10_Format = Me),
                (t.SRGB8_ALPHA8_ASTC_12x12_Format = Se),
                (t.SRGB8_ALPHA8_ASTC_4x4_Format = ue),
                (t.SRGB8_ALPHA8_ASTC_5x4_Format = pe),
                (t.SRGB8_ALPHA8_ASTC_5x5_Format = de),
                (t.SRGB8_ALPHA8_ASTC_6x5_Format = fe),
                (t.SRGB8_ALPHA8_ASTC_6x6_Format = me),
                (t.SRGB8_ALPHA8_ASTC_8x5_Format = ve),
                (t.SRGB8_ALPHA8_ASTC_8x6_Format = ge),
                (t.SRGB8_ALPHA8_ASTC_8x8_Format = ye),
                (t.Scene = In),
                (t.SceneUtils = Gp),
                (t.ShaderChunk = Wi),
                (t.ShaderLib = qi),
                (t.ShaderMaterial = Pi),
                (t.ShadowMaterial = hl),
                (t.Shape = vh),
                (t.ShapeBufferGeometry = tl),
                (t.ShapeGeometry = $c),
                (t.ShapePath = Vh),
                (t.ShapeUtils = zc),
                (t.ShortType = a),
                (t.Skeleton = As),
                (t.SkeletonHelper = qu),
                (t.SkinnedMesh = Ss),
                (t.SmoothShading = 2),
                (t.Sphere = Jn),
                (t.SphereBufferGeometry = Yc),
                (t.SphereGeometry = Xc),
                (t.Spherical = Iu),
                (t.SphericalHarmonics3 = Rh),
                (t.Spline = Fp),
                (t.SplineCurve = ph),
                (t.SplineCurve3 = zp),
                (t.SpotLight = _h),
                (t.SpotLightHelper = ku),
                (t.SpotLightShadow = bh),
                (t.Sprite = fs),
                (t.SpriteMaterial = es),
                (t.SrcAlphaFactor = lt),
                (t.SrcAlphaSaturateFactor = mt),
                (t.SrcColorFactor = st),
                (t.StaticCopyUsage = 35046),
                (t.StaticDrawUsage = Ge),
                (t.StaticReadUsage = 35045),
                (t.StereoCamera = Kh),
                (t.StreamCopyUsage = 35042),
                (t.StreamDrawUsage = 35040),
                (t.StreamReadUsage = 35041),
                (t.StringKeyframeTrack = Ol),
                (t.SubtractEquation = et),
                (t.SubtractiveBlending = Q),
                (t.TOUCH = {
                  ROTATE: 0,
                  PAN: 1,
                  DOLLY_PAN: 2,
                  DOLLY_ROTATE: 3,
                }),
                (t.TangentSpaceNormalMap = Ue),
                (t.TetrahedronBufferGeometry = cc),
                (t.TetrahedronGeometry = sc),
                (t.TextBufferGeometry = qc),
                (t.TextGeometry = Wc),
                (t.Texture = Ke),
                (t.TextureLoader = Xl),
                (t.TorusBufferGeometry = bc),
                (t.TorusGeometry = xc),
                (t.TorusKnotBufferGeometry = yc),
                (t.TorusKnotGeometry = gc),
                (t.Triangle = xr),
                (t.TriangleFanDrawMode = 2),
                (t.TriangleStripDrawMode = 1),
                (t.TrianglesDrawMode = 0),
                (t.TubeBufferGeometry = vc),
                (t.TubeGeometry = mc),
                (t.UVMapping = 300),
                (t.Uint16Attribute = function (t, e) {
                  return (
                    console.warn(
                      'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.',
                    ),
                    new zr(t, e)
                  )
                }),
                (t.Uint16BufferAttribute = zr),
                (t.Uint32Attribute = function (t, e) {
                  return (
                    console.warn(
                      'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.',
                    ),
                    new Hr(t, e)
                  )
                }),
                (t.Uint32BufferAttribute = Hr),
                (t.Uint8Attribute = function (t, e) {
                  return (
                    console.warn(
                      'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.',
                    ),
                    new Br(t, e)
                  )
                }),
                (t.Uint8BufferAttribute = Br),
                (t.Uint8ClampedAttribute = function (t, e) {
                  return (
                    console.warn(
                      'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.',
                    ),
                    new Nr(t, e)
                  )
                }),
                (t.Uint8ClampedBufferAttribute = Nr),
                (t.Uniform = Lu),
                (t.UniformsLib = Hi),
                (t.UniformsUtils = Li),
                (t.UnsignedByteType = qt),
                (t.UnsignedInt248Type = Qt),
                (t.UnsignedIntType = Yt),
                (t.UnsignedShort4444Type = s),
                (t.UnsignedShort5551Type = c),
                (t.UnsignedShort565Type = l),
                (t.UnsignedShortType = Xt),
                (t.VSMShadowMap = H),
                (t.Vector2 = Ye),
                (t.Vector3 = on),
                (t.Vector4 = $e),
                (t.VectorKeyframeTrack = Il),
                (t.Vertex = function (t, e, n) {
                  return (
                    console.warn(
                      'THREE.Vertex has been removed. Use THREE.Vector3 instead.',
                    ),
                    new on(t, e, n)
                  )
                }),
                (t.VertexColors = 2),
                (t.VideoTexture = Ks),
                (t.WebGL1Renderer = Yo),
                (t.WebGLCubeRenderTarget = Bi),
                (t.WebGLMultisampleRenderTarget = en),
                (t.WebGLRenderTarget = tn),
                (t.WebGLRenderTargetCube = function (t, e, n) {
                  return (
                    console.warn(
                      'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).',
                    ),
                    new Bi(t, n)
                  )
                }),
                (t.WebGLRenderer = Xo),
                (t.WebGLUtils = Go),
                (t.WireframeGeometry = nc),
                (t.WireframeHelper = function (t, e) {
                  return (
                    console.warn(
                      'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.',
                    ),
                    new Vs(
                      new nc(t.geometry),
                      new Ds({ color: void 0 !== e ? e : 16777215 }),
                    )
                  )
                }),
                (t.WrapAroundEnding = Le),
                (t.XHRLoader = function (t) {
                  return (
                    console.warn(
                      'THREE.XHRLoader has been renamed to THREE.FileLoader.',
                    ),
                    new Gl(t)
                  )
                }),
                (t.ZeroCurvatureEnding = Te),
                (t.ZeroFactor = at),
                (t.ZeroSlopeEnding = Ae),
                (t.ZeroStencilOp = 0),
                (t.sRGBEncoding = Ce),
                Object.defineProperty(t, '__esModule', { value: !0 })
            }),
            'object' == typeof n && void 0 !== e
              ? i(n)
              : 'function' == typeof define && define.amd
                ? define(['exports'], i)
                : i(((r = r || self).THREE = {}))
        },
        {},
      ],
      25: [
        function (t, n, e) {
          var u = /\n/,
            r = /\s/
          function d(t) {
            return r.test(t)
          }
          function s(t, e, n, r) {
            return { start: e, end: e + Math.min(r, n - e) }
          }
          ;(n.exports = function (e, t) {
            return n.exports
              .lines(e, t)
              .map(function (t) {
                return e.substring(t.start, t.end)
              })
              .join('\n')
          }),
            (n.exports.lines = function (t, e) {
              if (0 === (e = e || {}).width && 'nowrap' !== e.mode) return []
              t = t || ''
              var n = 'number' == typeof e.width ? e.width : Number.MAX_VALUE,
                r = Math.max(0, e.start || 0),
                i = 'number' == typeof e.end ? e.end : t.length,
                a = e.mode,
                o = e.measure || s
              return 'pre' === a
                ? (function (t, e, n, r, i) {
                    for (var a = [], o = n, s = n; s < r && s < e.length; s++) {
                      var c,
                        l = e.charAt(s),
                        h = u.test(l)
                      ;(!h && s !== r - 1) ||
                        ((c = t(e, o, h ? s : s + 1, i)),
                        a.push(c),
                        (o = s + 1))
                    }
                    return a
                  })(o, t, r, i, n)
                : (function (t, e, n, r, i, a) {
                    var o = [],
                      s = i
                    'nowrap' === a && (s = Number.MAX_VALUE)
                    for (; n < r && n < e.length; ) {
                      for (
                        var c = (function (t, e, n, r) {
                          var i = t.indexOf(e, n)
                          return -1 === i || r < i ? r : i
                        })(e, '\n', n, r);
                        n < c && d(e.charAt(n));

                      )
                        n++
                      var l,
                        h = t(e, n, c, s),
                        u = n + (h.end - h.start),
                        p = u + '\n'.length
                      if (u < c) {
                        for (; n < u && !d(e.charAt(u)); ) u--
                        if (u === n) n + '\n'.length < p && p--, (u = p)
                        else
                          for (p = u; n < u && d(e.charAt(u - '\n'.length)); )
                            u--
                      }
                      n <= u && ((l = t(e, n, u, s)), o.push(l)), (n = p)
                    }
                    return o
                  })(o, t, r, i, n, a)
            })
        },
        {},
      ],
      26: [
        function (t, e, n) {
          'use strict'
          var r = t('global/window'),
            i = t('is-function'),
            g = t('parse-headers'),
            a = t('xtend')
          function o(t, e, n) {
            var r = t
            return (
              i(e)
                ? ((n = e), 'string' == typeof t && (r = { uri: t }))
                : (r = a(e, { uri: t })),
              (r.callback = n),
              r
            )
          }
          function y(t, e, n) {
            return s((e = o(t, e, n)))
          }
          function s(r) {
            if (void 0 === r.callback)
              throw new Error('callback argument missing')
            var i = !1,
              a = function (t, e, n) {
                i || ((i = !0), r.callback(t, e, n))
              }
            function o() {
              var t = void 0,
                t = l.response
                  ? l.response
                  : l.responseText ||
                    (function (t) {
                      try {
                        if ('document' === t.responseType) return t.responseXML
                        var e =
                          t.responseXML &&
                          'parsererror' ===
                            t.responseXML.documentElement.nodeName
                        if ('' === t.responseType && !e) return t.responseXML
                      } catch (t) {}
                      return null
                    })(l)
              if (m)
                try {
                  t = JSON.parse(t)
                } catch (t) {}
              return t
            }
            function e(t) {
              return (
                clearTimeout(c),
                t instanceof Error ||
                  (t = new Error('' + (t || 'Unknown XMLHttpRequest Error'))),
                (t.statusCode = 0),
                a(t, v)
              )
            }
            function t() {
              if (!s) {
                var t
                clearTimeout(c),
                  (t =
                    r.useXDR && void 0 === l.status
                      ? 200
                      : 1223 === l.status
                        ? 204
                        : l.status)
                var e = v,
                  n = null
                return (
                  0 !== t
                    ? ((e = {
                        body: o(),
                        statusCode: t,
                        method: u,
                        headers: {},
                        url: h,
                        rawRequest: l,
                      }),
                      l.getAllResponseHeaders &&
                        (e.headers = g(l.getAllResponseHeaders())))
                    : (n = new Error('Internal XMLHttpRequest Error')),
                  a(n, e, e.body)
                )
              }
            }
            var n,
              s,
              c,
              l = r.xhr || null,
              h = ((l =
                l ||
                (r.cors || r.useXDR
                  ? new y.XDomainRequest()
                  : new y.XMLHttpRequest())).url = r.uri || r.url),
              u = (l.method = r.method || 'GET'),
              p = r.body || r.data,
              d = (l.headers = r.headers || {}),
              f = !!r.sync,
              m = !1,
              v = {
                body: void 0,
                headers: {},
                statusCode: 0,
                method: u,
                url: h,
                rawRequest: l,
              }
            if (
              ('json' in r &&
                !1 !== r.json &&
                ((m = !0),
                d.accept || d.Accept || (d.Accept = 'application/json'),
                'GET' !== u &&
                  'HEAD' !== u &&
                  (d['content-type'] ||
                    d['Content-Type'] ||
                    (d['Content-Type'] = 'application/json'),
                  (p = JSON.stringify(!0 === r.json ? p : r.json)))),
              (l.onreadystatechange = function () {
                4 === l.readyState && setTimeout(t, 0)
              }),
              (l.onload = t),
              (l.onerror = e),
              (l.onprogress = function () {}),
              (l.onabort = function () {
                s = !0
              }),
              (l.ontimeout = e),
              l.open(u, h, !f, r.username, r.password),
              f || (l.withCredentials = !!r.withCredentials),
              !f &&
                0 < r.timeout &&
                (c = setTimeout(function () {
                  var t
                  s ||
                    ((s = !0),
                    l.abort('timeout'),
                    ((t = new Error('XMLHttpRequest timeout')).code =
                      'ETIMEDOUT'),
                    e(t))
                }, r.timeout)),
              l.setRequestHeader)
            )
              for (n in d) d.hasOwnProperty(n) && l.setRequestHeader(n, d[n])
            else if (
              r.headers &&
              !(function (t) {
                for (var e in t) if (t.hasOwnProperty(e)) return
                return 1
              })(r.headers)
            )
              throw new Error(
                'Headers cannot be set on an XDomainRequest object',
              )
            return (
              'responseType' in r && (l.responseType = r.responseType),
              'beforeSend' in r &&
                'function' == typeof r.beforeSend &&
                r.beforeSend(l),
              l.send(p || null),
              l
            )
          }
          ;(e.exports = y),
            ((e.exports.default = y).XMLHttpRequest =
              r.XMLHttpRequest || function () {}),
            (y.XDomainRequest =
              'withCredentials' in new y.XMLHttpRequest()
                ? y.XMLHttpRequest
                : r.XDomainRequest),
            (function (t, e) {
              for (var n = 0; n < t.length; n++) e(t[n])
            })(['get', 'put', 'post', 'patch', 'head', 'delete'], function (r) {
              y['delete' === r ? 'del' : r] = function (t, e, n) {
                return ((e = o(t, e, n)).method = r.toUpperCase()), s(e)
              }
            })
        },
        {
          'global/window': 7,
          'is-function': 11,
          'parse-headers': 19,
          'xtend': 28,
        },
      ],
      27: [
        function (t, e, n) {
          e.exports =
            void 0 !== self.DOMParser
              ? function (t) {
                  return new self.DOMParser().parseFromString(
                    t,
                    'application/xml',
                  )
                }
              : void 0 !== self.ActiveXObject &&
                  new self.ActiveXObject('Microsoft.XMLDOM')
                ? function (t) {
                    var e = new self.ActiveXObject('Microsoft.XMLDOM')
                    return (e.async = 'false'), e.loadXML(t), e
                  }
                : function (t) {
                    var e = document.createElement('div')
                    return (e.innerHTML = t), e
                  }
        },
        {},
      ],
      28: [
        function (t, e, n) {
          e.exports = function () {
            for (var t = {}, e = 0; e < arguments.length; e++) {
              var n = arguments[e]
              for (var r in n) i.call(n, r) && (t[r] = n[r])
            }
            return t
          }
          var i = Object.prototype.hasOwnProperty
        },
        {},
      ],
      29: [
        function (t, e, n) {
          'use strict'
          var r = t('three')
          ;(n.canvas = null),
            (n.gl = null),
            (n.renderer = null),
            (n.camera = null),
            (n.scene = null),
            (n.width = 0),
            (n.height = 0),
            (n.pinCanShow = !1),
            (n.instructionShowRatio = 0),
            (n.instructionHideRatio = 0),
            (n.ringShowRatio = 0),
            (n.hasInitialized = !1),
            (n.showRatio = 0),
            (n.aboutRatio = 0),
            (n.licensesRatio = 0),
            (n.unitIsInch = !1),
            (n.unitMultiplier = 1),
            (n.darkColor = new r.Color()),
            (n.brightColor = new r.Color()),
            (n.accentColor = new r.Color()),
            (n.domOverlaySupported = !0),
            (n.isPredefinedMode = !1),
            (n.isSupportWebGL = null),
            (n.isSupportWebXR = null)
        },
        { three: 24 },
      ],
      30: [
        function (t, e, n) {
          'use strict'
          ;(n.IMAGES_PATH = 'assets/images/'),
            (n.MODELS_PATH = 'assets/models/'),
            (n.VIDEOS_PATH = 'assets/videos/'),
            (n.USE_WEBGL2 = !0),
            (n.WEBGL_OPTION = {
              antialias: !0,
              alpha: !0,
              xrCompatible: !0,
              powerPreference: 'high-performance',
            }),
            (n.IS_MOBILE =
              document.documentElement.classList.contains('is-mobile')),
            (n.IS_DESKTOP = !n.IS_MOBILE),
            (n.SHOW_DURATION = 1),
            (n.ABOUT_DURATION = 0),
            (n.LICENSES_DURATION = 0),
            (n.XR_INSTRUCTION_SHOW_DURATION = 1.75),
            (n.XR_INSTRUCTION_HIDE_DURATION = 0.8),
            (n.XR_BUTTONS_SHOW_DURATION = 0.25),
            (n.COLOR_BRIGHT_HEX = '#fcfcfc'),
            (n.COLOR_DARK_HEX = '#211A1C'),
            (n.COLOR_ACCENT_HEX = '#21E240')
        },
        {},
      ],
      31: [
        function (t, e, n) {
          'use strict'
          var r = t('./core/settings'),
            a = t('./core/properties'),
            o = t('./xr/xr'),
            s = t('./ui/ui'),
            i = t('three'),
            c = t('./visuals/visuals'),
            l = void 0,
            h = void 0,
            u = void 0,
            p = 0
          function d() {
            a.darkColor.setStyle(r.COLOR_DARK_HEX),
              a.brightColor.setStyle(r.COLOR_BRIGHT_HEX),
              a.accentColor.setStyle(r.COLOR_ACCENT_HEX),
              a.isSupportWebXR &&
                ((l = a.renderer =
                  new i.WebGLRenderer({
                    canvas: a.canvas,
                    context: a.gl,
                  })).setClearColor(16777215, 0),
                l.setPixelRatio(window.devicePixelRatio),
                (l.xr.enabled = !0),
                l.xr.setFramebufferScaleFactor(1),
                (u = a.scene = new i.Scene()),
                (h = a.camera = new i.PerspectiveCamera(70, 1, 0.05, 100)),
                u.add(h),
                c.init(),
                u.add(c.container)),
              s.init(),
              window.addEventListener('resize', f),
              f(),
              a.isSupportWebXR
                ? l.setAnimationLoop(m)
                : (function t() {
                    m(), requestAnimationFrame(t)
                  })()
          }
          function f() {
            var t = (a.width = window.innerWidth),
              e = (a.height = window.innerHeight)
            document.documentElement.style.setProperty('--vh', 0.01 * e + 'px'),
              a.isSupportWebXR &&
                (o.isActive ||
                  ((h.aspect = t / e),
                  h.updateProjectionMatrix(),
                  l.setSize(t, e))),
              s.onResize(t, e)
          }
          function m(t, e) {
            var n,
              r = +new Date(),
              i = Math.min(2 / 60, (r - p) / 1e3)
            ;(p = r),
              s.update(i),
              a.isSupportWebXR &&
                (o.isActive
                  ? ((n = l.xr.getCamera(a.camera)),
                    (h.matrixAutoUpdate = !1),
                    n.matrixWorld.decompose(n.position, n.quaternion, n.scale),
                    n.updateMatrixWorld(!0),
                    o.hitTest(e, n),
                    c.update(i))
                  : (h.matrixAutoUpdate = !0),
                (a.canvas.style.visibility = o.isActive
                  ? 'visible'
                  : 'hidden')),
              a.isSupportWebXR && o.isActive && l.render(u, h)
          }
          ;(a.canvas = document.getElementById('gl-canvas')),
            (a.isSupportWebGL = (function () {
              if (r.USE_WEBGL2 && window.WebGL2RenderingContext)
                try {
                  return (
                    (a.gl = a.canvas.getContext('webgl2', r.WEBGL_OPTION)), !0
                  )
                } catch (t) {}
              if (((r.USE_WEBGL2 = !1), window.WebGLRenderingContext))
                try {
                  a.gl =
                    a.canvas.getContext('webgl', r.WEBGL_OPTION) ||
                    a.canvas.getContext('experimental-webgl', r.WEBGL_OPTION)
                  return !0
                } catch (t) {
                  return !1
                }
              return !1
            })()),
            a.isSupportWebGL
              ? o.checkCompatibility(function (t) {
                  ;(a.isSupportWebXR = t), d()
                })
              : ((a.isSupportWebXR = !1), d())
        },
        {
          './core/properties': 29,
          './core/settings': 30,
          './ui/ui': 53,
          './visuals/visuals': 66,
          './xr/xr': 67,
          'three': 24,
        },
      ],
      32: [
        function (t, e, n) {
          'use strict'
          var r = t('three'),
            i = t('../core/properties')
          function a() {
            o.constructor.call(this), (this.enabled = !1), (this.visible = !1)
          }
          var o = r.Object3D.prototype,
            s = (a.prototype = Object.create(o))
          e.exports = s.constructor = a
          ;(s.reset = function () {}),
            (s.enable = function (t) {
              ;(this.enabled = void 0 === t || !!t),
                this.enabled ? this._show() : this._hide()
            }),
            (s._getCamera = function () {
              var t = i.renderer.xr
              return t.enabled && t.isPresenting
                ? t.getCamera(i.camera).cameras[0]
                : i.camera
            }),
            (s._getCameraPosition = function () {
              var t = i.renderer.xr
              return t.enabled && t.isPresenting
                ? t.getCamera(i.camera).position
                : i.camera.position
            }),
            (s._getResolution = function (t) {
              var e = i.renderer.xr
              {
                var n
                e.enabled && e.isPresenting
                  ? ((n = e.getSession().renderState.baseLayer),
                    t.set(n.framebufferWidth, n.framebufferHeight))
                  : i.renderer.getSize(t)
              }
            }),
            (s._show = function () {
              this.visible = !0
            }),
            (s._hide = function () {
              this.visible = !1
            }),
            (s.update = function (t) {})
        },
        { '../core/properties': 29, 'three': 24 },
      ],
      33: [
        function (n, t, e) {
          'use strict'
          var r = n('../../core/properties'),
            i = n('../Component'),
            a = n('../line/Line'),
            o = n('../rect/Rect'),
            s = n('three')
          function c() {
            l.constructor.call(this),
              (this.pointerIsInsideBox = !1),
              (this.rect = new o()),
              (this.rect2 = new o({ hasText: !1 })),
              this.add(this.rect),
              this.add(this.rect2),
              (this.lineCD = new a({ isVerticalLine: !0 })),
              this.add(this.lineCD),
              (this.lineEDbis = new a({ isVerticalLine: !0, hasText: !1 })),
              this.add(this.lineEDbis),
              (this.lineFA = new a({ isVerticalLine: !0, hasText: !1 })),
              this.add(this.lineFA),
              (this.lineGB = new a({ isVerticalLine: !0, hasText: !1 })),
              this.add(this.lineGB),
              (this.rawPointC = new s.Vector3()),
              (this.rawPointD = new s.Vector3()),
              (this.raycaster = new s.Raycaster()),
              (this.pointA = new s.Vector3()),
              (this.pointB = new s.Vector3()),
              (this.pointC = new s.Vector3()),
              (this.pointD = new s.Vector3()),
              (this.pointE = new s.Vector3()),
              (this.pointF = new s.Vector3()),
              (this.pointG = new s.Vector3()),
              (this.distanceAB = null),
              (this.distanceBC = null),
              (this.distanceCD = null)
            var t = (this.geometry = new s.BoxBufferGeometry(1, 1, 1)),
              e = (this.material = new s.ShaderMaterial({
                uniforms: {
                  u_colorInner: { value: r.accentColor },
                  u_opacity: { value: 0.5 },
                },
                vertexShader: n('./box.vert'),
                fragmentShader: n('./box.frag'),
                transparent: !0,
              }))
            ;(this.mesh = new s.Mesh(t, e)), this.add(this.mesh)
          }
          var l = i.prototype,
            h = (c.prototype = Object.create(l))
          t.exports = h.constructor = c
          ;(h.reset = function () {
            ;(this.hasPointA = !1),
              (this.hasPointB = !1),
              (this.hasPointC = !1),
              (this.hasPointD = !1),
              (this.isPointDFromCamera = !1),
              d.set(0, 0, 0),
              this.rawPointC.copy(d),
              this.rawPointD.copy(d),
              this.pointA.copy(d),
              this.pointB.copy(d),
              this.pointC.copy(d),
              this.pointD.copy(d),
              this.pointE.copy(d),
              this.pointF.copy(d),
              this.pointG.copy(d),
              this.rect.reset(),
              this.rect2.reset(),
              this.lineCD.reset(),
              this.lineEDbis.reset(),
              this.lineFA.reset(),
              this.lineGB.reset(),
              (this.distanceAB = null),
              (this.distanceBC = null),
              (this.distanceCD = null),
              (this.visible = !1)
          }),
            (h.setPointA = function (t, e) {
              this.pointA.copy(t),
                this.rect.setPointA(t, e),
                this.rect2.setPointA(t, e),
                this.lineCD.setPointC(t),
                this.lineFA.setPointB(t),
                (this.hasPointA = !0)
            }),
            (h.setPointB = function (t, e) {
              this.pointB.copy(t),
                this.rect.setPointB(t, e),
                this.rect2.setPointB(t, e),
                this.lineGB.setPointB(t),
                (this.hasPointB = !0)
            }),
            (h.setPointC = function (t, e) {
              this.rawPointC.copy(t),
                this.rect.setPointC(t, e),
                this.rect2.setPointC(t, e),
                this.lineCD.setPointA(t),
                (this.hasPointC = !0)
            }),
            (h.setPointD = function (t, e) {
              ;(this.isPointDFromCamera = !1),
                this.rawPointD.copy(t),
                (this.hasPointD = !0)
            }),
            (h.setPointDFromCamera = function () {
              ;(this.isPointDFromCamera = !0),
                this.raycaster.setFromCamera(p, this._getCamera()),
                (this.hasPointD = !0)
            }),
            (h.update = function (t) {
              {
                var e, n, r
                this.rect.update(),
                  this.rect2.update(),
                  this.lineCD.update(),
                  this.lineEDbis.update(),
                  this.lineFA.update(),
                  this.lineGB.update(),
                  (this.mesh.scale.z = 0),
                  this.enabled && this.hasPointA && this.hasPointB
                    ? ((this.distanceAB =
                        this.rect.lineAB.distanceInCentimeters),
                      this.hasPointC
                        ? (this.pointC.copy(this.rect.pointC),
                          (this.distanceBC =
                            this.rect.lineBC.distanceInCentimeters),
                          this.hasPointD
                            ? (this.mesh.position.copy(this.rect.mesh.position),
                              this.mesh.quaternion.copy(
                                this.rect.mesh.quaternion,
                              ),
                              this.mesh.scale.copy(this.rect.mesh.scale),
                              (e = 0),
                              (this.pointerIsInsideBox = !1),
                              this.isPointDFromCamera
                                ? ((this.mesh.scale.z = 1e5),
                                  (n = []),
                                  (this.mesh.visible = !0),
                                  this.mesh.updateMatrix(!0),
                                  this.mesh.updateWorldMatrix(!1, !1),
                                  this.mesh.raycast(this.raycaster, n),
                                  (this.mesh.visible = !1),
                                  n.length
                                    ? ((this.pointerIsInsideBox = !0),
                                      (r = n[0].point).sub(this.pointC),
                                      (e = u
                                        .set(this.rect.normal, 0)
                                        .distanceToPoint(r)),
                                      this.pointD
                                        .copy(this.rect.normal)
                                        .multiplyScalar(e)
                                        .add(this.pointC),
                                      this.rect.isFlipped
                                        ? this.mesh.translateZ(-0.5 * e)
                                        : this.mesh.translateZ(0.5 * e),
                                      (this.mesh.scale.z = Math.abs(e)),
                                      this.lineCD.setPointA(this.pointC),
                                      this.lineCD.setPointB(this.pointD),
                                      this.lineCD.enable(!0),
                                      this.lineEDbis.enable(!0),
                                      this.lineFA.enable(!0),
                                      this.lineGB.enable(!0),
                                      (this.mesh.visible = !0),
                                      (this.rect.mesh.visible = !1),
                                      (this.rect2.mesh.visible = !1))
                                    : (this.lineCD.enable(!1),
                                      (this.mesh.visible = !1),
                                      (this.rect.mesh.visible = !0),
                                      (this.rect2.mesh.visible = !0),
                                      this.lineEDbis.enable(!1),
                                      this.lineFA.enable(!1),
                                      this.lineGB.enable(!1)))
                                : ((this.pointerIsInsideBox = !0),
                                  (e = this.rawPointC.distanceTo(
                                    this.rawPointD,
                                  )),
                                  this.pointD
                                    .copy(this.rect.normal)
                                    .negate()
                                    .multiplyScalar(e)
                                    .add(this.pointC),
                                  this.rect.isFlipped
                                    ? this.mesh.translateZ(0.5 * e)
                                    : this.mesh.translateZ(-0.5 * e),
                                  (this.mesh.scale.z = Math.abs(e)),
                                  this.lineCD.setPointA(this.pointC),
                                  this.lineCD.setPointB(this.pointD),
                                  this.lineCD.setPointC(this.pointA),
                                  this.lineCD.enable(!0),
                                  (this.mesh.visible = !0),
                                  (this.rect.mesh.visible = !1),
                                  (this.rect2.mesh.visible = !1)),
                              this.pointerIsInsideBox
                                ? ((this.distanceCD =
                                    this.lineCD.distanceInCentimeters),
                                  this.rect2.enable(!0),
                                  this.rect2.position.copy(this.rect.position),
                                  this.rect2.position
                                    .copy(this.rect.normal)
                                    .multiplyScalar(e),
                                  this.pointE.copy(this.rect.pointD),
                                  this.pointE.add(this.pointD).sub(this.pointC),
                                  this.pointF.copy(this.pointA),
                                  this.pointF
                                    .add(this.pointE)
                                    .sub(this.rect.pointD),
                                  this.pointG.copy(this.pointB),
                                  this.pointG.add(this.pointD).sub(this.pointC),
                                  this.lineEDbis.setPointA(this.pointE),
                                  this.lineEDbis.setPointB(this.rect.pointD),
                                  this.lineFA.setPointA(this.pointF),
                                  this.lineFA.setPointB(this.pointA),
                                  this.lineGB.setPointA(this.pointG),
                                  this.lineGB.setPointB(this.pointB))
                                : this.rect2.enable(!1))
                            : (this.lineCD.enable(!1),
                              (this.mesh.visible = !1),
                              this.rect2.enable(!1)))
                        : (this.lineCD.enable(!1),
                          this.lineEDbis.enable(!1),
                          this.lineFA.enable(!1),
                          this.lineGB.enable(!1),
                          (this.mesh.visible = !1)),
                      this.rect.enable(!0),
                      this._show())
                    : (this.lineEDbis.enable(!1),
                      this.lineFA.enable(!1),
                      this.lineGB.enable(!1),
                      this.lineCD.enable(!1),
                      this.rect.enable(!1),
                      this.rect2.enable(!1),
                      this._hide())
              }
            })
          var u = new s.Plane(),
            p = new s.Vector2(),
            d = new s.Vector3()
        },
        {
          '../../core/properties': 29,
          '../Component': 32,
          '../line/Line': 36,
          '../rect/Rect': 43,
          './box.frag': 34,
          './box.vert': 35,
          'three': 24,
        },
      ],
      34: [
        function (t, e, n) {
          e.exports =
            'uniform vec3 u_colorInner;\r\nuniform float u_opacity;\r\n\r\nvarying vec3 v_viewNormal;\r\n\r\nvoid main () {\r\n\tvec3 viewNormal = normalize(v_viewNormal);\r\n\t// gl_FragColor = vec4(vec3(0.26, 0.8, 1.0) + max(0.0, dot(vec3(0.577), viewNormal) * 0.25), u_opacity);\r\n\tgl_FragColor = vec4(u_colorInner, u_opacity);\r\n}'
        },
        {},
      ],
      35: [
        function (t, e, n) {
          e.exports =
            'varying vec3 v_viewNormal;\r\n\r\nvoid main () {\r\n\tv_viewNormal = normalMatrix * normal;\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}'
        },
        {},
      ],
      36: [
        function (r, t, e) {
          'use strict'
          var n = r('../Component'),
            i = r('../point/Point'),
            a = r('three'),
            o = r('../text/Text3D'),
            s = r('../../core/properties')
          function c() {
            var t =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : {}
            l.constructor.call(this),
              (this.hasText = !1),
              (this.hasPointA = !1),
              (this.hasPointB = !1),
              (this.pointA = new i()),
              (this.pointB = new i()),
              this.add(this.pointA),
              this.add(this.pointB),
              this.pointA.enable(),
              this.pointB.enable(),
              (this.isVerticalLine = t.isVerticalLine || !1),
              this.isVerticalLine && (this.pointC = new a.Vector3()),
              (this.opacity = 1),
              (this.dashOffset = 0),
              (this.distance = 0)
            var e = (this.geometry = new a.BufferGeometry())
            e.setAttribute(
              'position',
              new a.BufferAttribute(
                new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
                3,
              ),
            ),
              e.setAttribute(
                'a_offsetAngle',
                new a.BufferAttribute(
                  new Float32Array([
                    1.5 * Math.PI,
                    0.5 * Math.PI,
                    1.5 * Math.PI,
                    0.5 * Math.PI,
                  ]),
                  1,
                ),
              ),
              e.setAttribute(
                'a_side',
                new a.BufferAttribute(new Float32Array([0, 0, 1, 1]), 1),
              ),
              e.setIndex(
                new a.BufferAttribute(new Uint8Array([0, 2, 1, 1, 2, 3]), 1),
              )
            var n = (this.material = new a.ShaderMaterial({
              uniforms: {
                u_angle: { value: 0 },
                u_thickness: { value: 4 },
                u_distance: { value: 0 },
                u_dash: { value: 100 },
                u_dashGap: { value: -50 },
                u_dashOffset: { value: 0 },
                u_opacity: { value: 1 },
                u_resolution: { value: new a.Vector2() },
              },
              vertexShader: r('./line.vert'),
              fragmentShader: r('./line.frag'),
              transparent: !0,
              depthTest: !1,
              depthWrite: !1,
            }))
            ;(n.extensions.derivatives = !0),
              (this.mesh = new a.Mesh(e, n)),
              this.add(this.mesh),
              (this.mesh.renderOrder = 1e3),
              this.hasText && (this.text3D = new o(this))
          }
          var l = n.prototype,
            h = (c.prototype = Object.create(l))
          t.exports = h.constructor = c
          ;(h.reset = function () {
            ;(this.hasPointA = !1),
              (this.hasPointB = !1),
              p.set(0, 0, 0),
              this.pointA.position.copy(p),
              this.pointB.position.copy(p),
              this.pointC && this.pointC.copy(p)
            this._updatePositionAttribute(p, 0),
              this._updatePositionAttribute(p, 6),
              (this.visible = !1)
          }),
            (h.setPointA = function (t) {
              this.pointA.position.copy(t),
                this._updatePositionAttribute(t, 0),
                (this.hasPointA = !0)
            }),
            (h.setPointB = function (t) {
              this.pointB.position.copy(t),
                this._updatePositionAttribute(t, 6),
                (this.hasPointB = !0)
            }),
            (h.setPointC = function (t) {
              this.pointC.copy(t), (this.hasPointC = !0)
            }),
            (h._updatePositionAttribute = function (t, e) {
              for (
                var n = this.geometry.attributes.position,
                  r = n.array,
                  i = 0,
                  a = 0;
                i < 2;
                i++
              )
                (r[a + 0 + e] = t.x),
                  (r[a + 1 + e] = t.y),
                  (r[a + 2 + e] = t.z),
                  (a += 3)
              {
                var o
                ;(n.needsUpdate = !0),
                  (this.distance = this.pointA.position.distanceTo(
                    this.pointB.position,
                  )),
                  (this.distanceInCentimeters = 100 * this.distance),
                  this.hasText &&
                    ((o = void 0),
                    (o = s.unitIsInch
                      ? (this.distanceInCentimeters * s.unitMultiplier).toFixed(
                          1,
                        ) + 'in'
                      : this.distance < 1
                        ? this.distanceInCentimeters.toFixed(1) + 'cm'
                        : this.distance.toFixed(2) + 'm'),
                    this.text3D.setText(o))
              }
            }),
            (h.update = function (t) {
              {
                var e, n, r, i, a, o
                this.enabled && this.hasPointA && this.hasPointB
                  ? ((e = this.material.uniforms.u_resolution.value),
                    (n = this._getCamera()),
                    this._getResolution(e),
                    (this.material.uniforms.u_thickness.value =
                      (u * e.y) / s.height),
                    p.copy(this.pointA.position),
                    p.project(n),
                    (r = (0.5 * p.x + 0.5) * e.x),
                    (i = (0.5 * p.y + 0.5) * e.y),
                    p.copy(this.pointB.position),
                    p.project(n),
                    (a = (0.5 * p.x + 0.5) * e.x),
                    (o = (0.5 * p.y + 0.5) * e.y),
                    (this.material.uniforms.u_angle.value =
                      Math.atan2(o - i, a - r) || 0),
                    (this.material.uniforms.u_distance.value = Math.sqrt(
                      Math.pow(a - r, 2) + Math.pow(o - i, 2),
                    )),
                    this.hasText &&
                      (this.text3D.container.position
                        .copy(this.pointB.position)
                        .sub(this.pointA.position)
                        .normalize(),
                      this.text3D.container.quaternion.setFromUnitVectors(
                        d,
                        this.text3D.container.position,
                      ),
                      this.text3D.container.position
                        .copy(this.pointA.position)
                        .add(this.pointB.position)
                        .multiplyScalar(0.5),
                      this.text3D.update(this._getCameraPosition(), t)),
                    this.geometry.computeBoundingBox(),
                    this.geometry.computeBoundingSphere(),
                    (this.material.uniforms.u_dashOffset.value =
                      this.dashOffset),
                    (this.material.uniforms.u_opacity.value = this.opacity),
                    this.pointA.update(t),
                    this.pointB.update(t),
                    this._show())
                  : this._hide()
              }
            })
          var u = 3,
            p = new a.Vector3(),
            d = new a.Vector3(0, 0, 1)
        },
        {
          '../../core/properties': 29,
          '../Component': 32,
          '../point/Point': 40,
          '../text/Text3D': 44,
          './line.frag': 37,
          './line.vert': 38,
          'three': 24,
        },
      ],
      37: [
        function (t, e, n) {
          e.exports =
            'uniform float u_dash;\r\nuniform float u_dashGap;\r\nuniform float u_opacity;\r\n\r\nvarying float v_dist;\r\n\r\nfloat aastep (float a, float b) {\r\n\tfloat delta = b - a;\r\n\treturn clamp(delta / fwidth(delta), 0.0, 1.0);\r\n}\r\n\r\nvoid main () {\r\n\tfloat d = mod(v_dist, u_dash + u_dashGap);\r\n\tgl_FragColor = vec4(1.0, 1.0, 1.0, aastep(u_dashGap, d) * u_opacity);\r\n}'
        },
        {},
      ],
      38: [
        function (t, e, n) {
          e.exports =
            'attribute float a_offsetAngle;\r\nattribute float a_side;\r\n\r\nuniform float u_thickness;\r\nuniform float u_angle;\r\nuniform vec2 u_resolution;\r\n\r\nuniform float u_distance;\r\nuniform float u_dashOffset;\r\n\r\nvarying float v_dist;\r\n\r\nvoid main () {\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\r\n\tv_dist = a_side * u_distance + u_dashOffset;\r\n\t\r\n\tfloat angle = a_offsetAngle + u_angle;\r\n\tgl_Position.xy += vec2(\r\n\t\tcos(angle),\r\n\t\tsin(angle)\r\n\t) * u_thickness / u_resolution * gl_Position.w;\r\n\r\n\tgl_Position.xyz /= gl_Position.w;\r\n\tgl_Position.w = 1.0;\r\n\r\n}'
        },
        {},
      ],
      39: [
        function (t, e, y) {
          'use strict'
          var x = t('../core/properties'),
            n = (t('../visuals/visuals'), t('./line/Line')),
            r = t('./rect/Rect'),
            i = t('./box/Box'),
            b = t('../xr/xr'),
            a = t('../ui/xrUI'),
            o = t('three')
          ;(y.init = function () {
            ;(M = new o.Matrix4()),
              (S = new o.Vector3()),
              (E = new o.Quaternion()),
              (T = new o.Vector3()),
              (D = new o.Matrix4()),
              (B = new o.Vector3()),
              (s = new o.Vector3(1, 1, 1)),
              (c = new o.Quaternion().setFromEuler(new o.Euler(0, 0, 0))),
              (l = new o.Quaternion()),
              (N = new o.Quaternion()),
              (u = new o.Vector3(0, 1, 0)),
              (y.container = new o.Object3D()),
              (_ = new o.Object3D()),
              y.container.add(_)
            for (var t = 0; t < 4; t++)
              A.push(new o.Matrix4()),
                L.push(new o.Matrix4()),
                R.push({
                  position: new o.Vector3(),
                  quaternion: new o.Quaternion(),
                })
            ;(P = new n()),
              _.add(P),
              (O = new r()),
              _.add(O),
              (I = new i()),
              _.add(I),
              b.eventDispatcher.addEventListener('start', f),
              a.inputEventDispatcher.addEventListener('up', p),
              a.inputEventDispatcher.addEventListener('multimove', d),
              a.btnClickEventDispatcher.addEventListener('pin', g),
              a.btnClickEventDispatcher.addEventListener('undo', m),
              a.btnClickEventDispatcher.addEventListener('done', v)
          }),
            (y.update = function (t) {
              var e = x.isPredefinedMode ? L : A,
                n =
                  (x.isPredefinedMode && (!!b.isHit || C)) ||
                  !x.isPredefinedMode
              if (
                ((_.visible = n),
                (window.step = y.step),
                (window.distances = y.distances),
                (window.isEditMode = y.isEditMode),
                n)
              ) {
                x.isPredefinedMode
                  ? (C || M.copy(b.hitMatrix),
                    M.decompose(S, N, T),
                    H(E, !1),
                    M.compose(S, E, T))
                  : M.identity()
                for (
                  var r, i, a, o, s, c, l, h, u, p, d, f, m, v, g = 0;
                  g < 4;
                  g++
                )
                  D.copy(e[g]).premultiply(M),
                    D.decompose(R[g].position, R[g].quaternion, B)
                0 === y.step &&
                  ((y.distances.AB = null),
                  (y.distances.BC = null),
                  (y.distances.CD = null)),
                  'line' == w && 0 < y.step
                    ? ((r = R[0].position),
                      (i = 1 < y.step ? R[1].position : b.hitPos),
                      P.setPointA(r),
                      P.setPointB(i),
                      P.enable(!0),
                      (y.distances.AB = P.distanceInCentimeters),
                      (y.distances.BC = null),
                      (y.distances.CD = null))
                    : (P.reset(), P.enable(!1)),
                  P.update(),
                  'rect' == w && 0 < y.step
                    ? ((a = R[0].position),
                      (o = R[0].quaternion),
                      (s = 1 < y.step ? R[1].position : b.hitPos),
                      (c = 1 < y.step ? R[1].quaternion : b.hitQuat),
                      O.setPointA(a, o),
                      O.setPointB(s, c),
                      1 < y.step &&
                        ((l = 2 < y.step ? R[2].position : b.hitPos),
                        (h = 2 < y.step ? R[2].quaternion : b.hitQuat),
                        O.setPointC(l, h)),
                      O.enable(!0),
                      (y.distances.AB = O.lineAB.distanceInCentimeters),
                      (y.distances.BC = O.lineBC.distanceInCentimeters),
                      (y.distances.CD = null))
                    : (O.reset(), O.enable(!1)),
                  O.update(),
                  'box' == w && 0 < y.step
                    ? ((u = R[0].position),
                      (p = R[0].quaternion),
                      (d = 1 < y.step ? R[1].position : b.hitPos),
                      (f = 1 < y.step ? R[1].quaternion : b.hitQuat),
                      I.setPointA(u, p),
                      I.setPointB(d, f),
                      1 < y.step &&
                        ((m = 2 < y.step ? R[2].position : b.hitPos),
                        (v = 2 < y.step ? R[2].quaternion : b.hitQuat),
                        I.setPointC(m, v),
                        x.isPredefinedMode
                          ? I.setPointD(R[3].position, R[3].quaternion)
                          : (3 !== y.step && (4 !== y.step || I.hasPointD)) ||
                            I.setPointDFromCamera()),
                      I.enable(!0),
                      (y.distances.AB = I.distanceAB),
                      (y.distances.BC = I.distanceBC),
                      (y.distances.CD = I.distanceCD))
                    : (I.reset(), I.enable(!1)),
                  I.update()
              }
            }),
            (y.step = 0),
            (y.isEditMode = !0),
            (y.distances = { AB: null, BC: null, CD: null }),
            (y.container = null),
            (y.predefinedLength = 200),
            (y.predefinedWidth = 100),
            (y.predefinedHeight = 100)
          var _ = void 0,
            w = 'box',
            M = void 0,
            S = void 0,
            E = void 0,
            T = void 0,
            A = [],
            L = [],
            R = [],
            C = !1,
            P = void 0,
            O = void 0,
            I = void 0,
            D = void 0,
            B = void 0,
            s = void 0,
            c = void 0,
            l = void 0,
            h = 0,
            N = void 0,
            u = void 0
          function p(t) {
            H(l, !0)
          }
          function d(t) {
            h = t.angle - t.downAngle
          }
          function f() {
            U(),
              x.isPredefinedMode &&
                (function () {
                  y.step = 4
                  var t = 0.01 * y.predefinedLength,
                    e = 0.01 * y.predefinedWidth,
                    n = 0.01 * y.predefinedHeight,
                    r = 0
                  0 < e && r++
                  0 < n && r++
                  0 < t && r++
                  0 === r &&
                    console.error(
                      'error, at least one value is needed',
                      e,
                      n,
                      t,
                    )
                  switch ((w = 2 < r ? 'box' : 1 < r ? 'rect' : 'line')) {
                    case 'line':
                      F(L[0], 0.5 * -t, 0, 0), F(L[1], 0.5 * t, 0, 0)
                      break
                    case 'rect':
                      F(L[0], 0.5 * -e, 0, 0.5 * -t),
                        F(L[1], 0.5 * e, 0, 0.5 * -t),
                        F(L[2], 0.5 * e, 0, 0.5 * t)
                      break
                    case 'box':
                      F(L[0], 0.5 * -e, 0, 0.5 * -t),
                        F(L[1], 0.5 * e, 0, 0.5 * -t),
                        F(L[2], 0.5 * e, 0, 0.5 * t),
                        F(L[3], 0.5 * e, n, 0.5 * t)
                  }
                })()
          }
          function m() {
            ;(y.step = 0 < y.step ? y.step - 1 : 0),
              I.reset(),
              a.togglePinButton(!1)
          }
          function v() {
            if (!y.isEditMode || 3 !== y.step || !1 !== I.pointerIsInsideBox) {
              var t = y.step,
                e = z()
              if (((y.isEditMode = !1), a.togglePinButton(!0), t !== e))
                return t === e - 1
                  ? ((w = 'rect'),
                    void (y.distances.BC = O.lineBC.distanceInCentimeters))
                  : t === e - 2
                    ? ((w = 'line'),
                      void (y.distances.AB = P.distanceInCentimeters))
                    : void (1 !== t || (w = 'point'))
            }
          }
          function g() {
            var t
            ;(y.isEditMode && 3 === y.step && !1 === I.pointerIsInsideBox) ||
              ((y.isEditMode = !0),
              x.isPredefinedMode
                ? C
                  ? ((C = !1), (x.isPredefinedMode = !1), (w = 'line'), U())
                  : b.isHit &&
                    ((C = !0), M.copy(b.hitMatrix), a.togglePinButton(!0))
                : ((t = z()),
                  y.step === t
                    ? U()
                    : (y.step === t - 1
                        ? a.togglePinButton(!0)
                        : a.togglePinButton(!1),
                      'box' == w && 3 === y.step
                        ? y.step++
                        : b.isHit && (A[y.step].copy(b.hitMatrix), y.step++))))
          }
          function U() {
            ;(y.step = 0), (C = !1), P.reset(), O.reset(), I.reset()
            for (var t = 0; t < 4; t++)
              A[t].identity(),
                L[t].identity(),
                R[t].position.set(0, 0, 0),
                R[t].quaternion.set(0, 0, 0, 1)
            x.isPredefinedMode || (w = 'box'), a.togglePinButton(!1)
          }
          function z(t) {
            switch (void 0 === t ? w : t) {
              case 'line':
                return 2
              case 'rect':
                return 3
              case 'box':
                return 4
              default:
                return 2
            }
          }
          function F(t, e, n, r) {
            B.set(e, n, r), t.compose(B, c, s)
          }
          function H(t, e) {
            N.setFromAxisAngle(u, h), t.premultiply(N), e && (h = 0)
          }
        },
        {
          '../core/properties': 29,
          '../ui/xrUI': 55,
          '../visuals/visuals': 66,
          '../xr/xr': 67,
          './box/Box': 33,
          './line/Line': 36,
          './rect/Rect': 43,
          'three': 24,
        },
      ],
      40: [
        function (t, e, n) {
          'use strict'
          var r = t('../../core/properties'),
            i = t('../Component'),
            a = t('three'),
            o = void 0,
            s = void 0,
            c = new a.Vector2()
          function l() {
            h.constructor.call(this),
              o ||
                (o = new a.BufferGeometry()).setAttribute(
                  'position',
                  new a.BufferAttribute(new Float32Array([0, 0, 0]), 3),
                ),
              s ||
                ((s = new a.ShaderMaterial({
                  uniforms: {
                    u_colorInner: { value: r.darkColor },
                    u_colorOuter: { value: new a.Color(16777215) },
                    u_outerThreshold: { value: 0.5 },
                    u_pointSize: { value: 1 },
                  },
                  vertexShader: t('./point.vert'),
                  fragmentShader: t('./point.frag'),
                  transparent: !0,
                  depthTest: !1,
                  depthWrite: !1,
                })).extensions.derivatives = !0),
              (this.center = new a.Points(o, s)),
              (this.center.renderOrder = 1001),
              this.add(this.center)
          }
          var h = i.prototype,
            u = (l.prototype = Object.create(h))
          e.exports = u.constructor = l
          u.update = function (t) {
            this.enabled &&
              (this._getCamera(),
              this._getResolution(c),
              (s.uniforms.u_pointSize.value = (14 * c.y) / r.height))
          }
        },
        {
          '../../core/properties': 29,
          '../Component': 32,
          './point.frag': 41,
          './point.vert': 42,
          'three': 24,
        },
      ],
      41: [
        function (t, e, n) {
          e.exports =
            'uniform vec3 u_colorInner;\r\nuniform vec3 u_colorOuter;\r\nuniform float u_outerThreshold;\r\n\r\nvoid main () {\r\n\tfloat d = length(gl_PointCoord.xy - 0.5) * 2.0;\r\n\tfloat fd = fwidth(d);\r\n\r\n\tvec3 color = mix(u_colorInner, u_colorOuter, smoothstep(u_outerThreshold - fd, u_outerThreshold, d));\r\n\tfloat alpha = 1.0 - smoothstep(1.0 - fd, 1.0, d);\r\n\r\n\tgl_FragColor = vec4(color, alpha);\r\n}'
        },
        {},
      ],
      42: [
        function (t, e, n) {
          e.exports =
            'uniform float u_pointSize;\r\n\r\nvoid main () {\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n\tgl_PointSize = u_pointSize;\r\n}'
        },
        {},
      ],
      43: [
        function (t, e, n) {
          'use strict'
          var r = t('../Component'),
            i = t('../line/Line'),
            a = t('three')
          function o() {
            var t =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : {}
            s.constructor.call(this),
              (this.isFlipped = !1),
              (this.hasText = void 0 === t.hasText || t.hasText),
              (this.lineAB = new i({ hasText: this.hasText })),
              this.add(this.lineAB),
              (this.lineBC = new i({ hasText: this.hasText })),
              this.add(this.lineBC),
              (this.lineCD = new i({ hasText: !1 })),
              this.add(this.lineCD),
              (this.lineAD = new i({ hasText: !1 })),
              this.add(this.lineAD),
              (this.normal = new a.Vector3()),
              (this.rawPointC = new a.Vector3()),
              (this.pointA = new a.Vector3()),
              (this.pointADir = new a.Vector3()),
              (this.pointB = new a.Vector3()),
              (this.pointBDir = new a.Vector3()),
              (this.pointC = new a.Vector3()),
              (this.pointCDir = new a.Vector3()),
              (this.pointD = new a.Vector3())
            var e = (this.geometry = new a.PlaneBufferGeometry(1, 1)),
              n = (this.material = new a.MeshBasicMaterial({
                color: 16777215,
                opacity: 0.35,
                transparent: !0,
              }))
            ;(this.mesh = new a.Mesh(e, n)), this.add(this.mesh)
          }
          var s = r.prototype,
            c = (o.prototype = Object.create(s))
          e.exports = c.constructor = o
          ;(c.reset = function () {
            ;(this.hasPointA = !1),
              (this.hasPointB = !1),
              (this.hasPointC = !1),
              (this.isFlipped = !1),
              this.pointC.set(0, 0, 0),
              this.pointD.set(0, 0, 0),
              this.pointADir.set(0, 0, 0),
              this.pointBDir.set(0, 0, 0),
              this.pointCDir.set(0, 0, 0),
              this.lineAB.reset(),
              this.lineBC.reset(),
              this.lineCD.reset(),
              this.lineAD.reset(),
              (this.mesh.visible = !1)
          }),
            (c.setPointA = function (t, e) {
              this.pointA.copy(t),
                this.pointADir.set(0, 1, 0).applyQuaternion(e),
                this.lineAB.setPointA(t),
                (this.hasPointA = !0)
            }),
            (c.setPointB = function (t, e) {
              this.pointB.copy(t),
                this.pointBDir.set(0, 1, 0).applyQuaternion(e),
                this.lineAB.setPointB(t),
                this.lineBC.setPointA(t),
                (this.hasPointB = !0)
            }),
            (c.setPointC = function (t, e) {
              this.rawPointC.copy(t),
                this.pointCDir.set(0, 1, 0).applyQuaternion(e),
                (this.hasPointC = !0)
            }),
            (c.update = function (t) {
              this.enabled &&
                (this.lineAB.update(),
                this.lineBC.update(),
                this.lineCD.update(),
                this.lineAD.update(),
                this.hasPointA && this.hasPointB
                  ? (this.lineAB.enable(!0),
                    this.hasPointC
                      ? (h.copy(this.pointA).sub(this.pointB).normalize(),
                        u.copy(this.rawPointC).sub(this.pointB).normalize(),
                        p.crossVectors(h, u).normalize(),
                        l.set(h, 0),
                        l.projectPoint(
                          h.copy(this.rawPointC).sub(this.pointB),
                          u,
                        ),
                        l.set(p, 0),
                        l.projectPoint(u, this.pointC),
                        this.pointC.add(this.pointB),
                        this.lineBC.setPointB(this.pointC),
                        this.mesh.position
                          .copy(this.pointA)
                          .add(this.pointC)
                          .multiplyScalar(0.5),
                        this.mesh.scale.set(
                          this.pointA.distanceTo(this.pointB),
                          this.pointB.distanceTo(this.pointC),
                          1,
                        ),
                        h.copy(this.pointA).sub(this.pointB).normalize(),
                        u.copy(this.pointC).sub(this.pointB).normalize(),
                        this.normal.crossVectors(h, u).normalize(),
                        this.mesh.matrix.set(
                          h.x,
                          u.x,
                          this.normal.x,
                          0,
                          h.y,
                          u.y,
                          this.normal.y,
                          0,
                          h.z,
                          u.z,
                          this.normal.z,
                          0,
                          0,
                          0,
                          0,
                          1,
                        ),
                        (this.isFlipped = 0 < h.cross(this.pointCDir).dot(u)),
                        this.isFlipped && this.mesh.matrix.multiply(d),
                        this.mesh.matrix.decompose(h, this.mesh.quaternion, u),
                        this.lineBC.enable(!0),
                        (this.mesh.visible = !0),
                        this.pointD.copy(this.pointA),
                        this.pointD.add(this.pointC).sub(this.pointB),
                        this.lineCD.setPointA(this.pointC),
                        this.lineCD.setPointB(this.pointD),
                        this.lineCD.enable(!0),
                        this.lineAD.setPointA(this.pointA),
                        this.lineAD.setPointB(this.pointD),
                        this.lineAD.enable(!0))
                      : (this.lineBC.enable(!1),
                        this.lineCD.enable(!1),
                        this.lineAD.enable(!1),
                        (this.mesh.visible = !1)),
                    this._show())
                  : (this.lineAB.enable(!1),
                    this.lineBC.enable(!1),
                    this.lineCD.enable(!1),
                    this.lineAD.enable(!1),
                    this._hide()))
            })
          var l = new a.Plane(),
            h = new a.Vector3(),
            u = new a.Vector3(),
            p = new a.Vector3(),
            d = new a.Matrix4().makeRotationX(Math.PI)
        },
        { '../Component': 32, '../line/Line': 36, 'three': 24 },
      ],
      44: [
        function (s, c, t) {
          ;(function (t) {
            'use strict'
            var r = s('three')
            t.THREE = r
            var i = s('three-bmfont-text'),
              e = s('load-bmfont')
            s('../../core/properties')
            function n(t) {
              ;(this.hasInit = !1),
                (this.baseScale = 8e-4),
                (this.scale = 0),
                (this.container = new r.Object3D()),
                t.add(this.container)
              var n = this
              e('./assets/fonts/roboto-msdf.json', function (t, e) {
                ;(n.geometry = i({
                  width: 150,
                  font: e,
                  align: 'center',
                  text: '59.16cm',
                })),
                  new r.TextureLoader().load(
                    './assets/fonts/roboto-msdf.png',
                    a.bind(n),
                  )
              })
            }
            function a(t) {
              var e = new r.ShaderMaterial({
                transparent: !0,
                side: r.DoubleSide,
                depthTest: !1,
                uniforms: {
                  opacity: { value: 1 },
                  map: { value: t },
                  color: { value: new r.Color(16777215) },
                },
                vertexShader: s('./msdf.vert'),
                fragmentShader: s('./msdf.frag'),
              })
              ;(e.extensions.derivatives = !0),
                (this.mesh = new r.Mesh(this.geometry, e)),
                this.mesh.position.set(-0.02, 0, 0),
                (this.mesh.renderOrder = 1002),
                this.container.add(this.mesh),
                (this.hasInit = !0)
            }
            var o = n.prototype
            ;(c.exports = n),
              (o.setText = function (t) {
                this.geometry.update(t)
              }),
              (o._onTextureLoad = a),
              (o.update = function (t, e) {
                this.hasInit &&
                  t &&
                  (this.mesh.position.distanceTo(t),
                  (this.scale = 0.005),
                  this.mesh.scale.set(this.scale, -this.scale, this.scale))
              })
          }).call(
            this,
            'undefined' != typeof global
              ? global
              : 'undefined' != typeof self
                ? self
                : 'undefined' != typeof window
                  ? window
                  : {},
          )
        },
        {
          '../../core/properties': 29,
          './msdf.frag': 45,
          './msdf.vert': 46,
          'load-bmfont': 13,
          'three': 24,
          'three-bmfont-text': 21,
        },
      ],
      45: [
        function (t, e, n) {
          e.exports =
            '#ifdef GL_OES_standard_derivatives\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nprecision highp float;\r\nuniform float opacity;\r\nuniform vec3 color;\r\nuniform sampler2D map;\r\nvarying vec2 vUv;\r\n\r\nfloat median(float r, float g, float b) {\r\n  return max(min(r, g), min(max(r, g), b));\r\n}\r\n\r\nvoid main() {\r\n  vec3 msdfSample = 1.0 - texture2D(map, vUv).rgb;\r\n  float sigDist = median(msdfSample.r, msdfSample.g, msdfSample.b) - 0.5;\r\n  float alpha = clamp(sigDist/fwidth(sigDist) + 0.5, 0.0, 1.0);\r\n  gl_FragColor = vec4(color.xyz, alpha * opacity);\r\n  \r\n  if (gl_FragColor.a < 0.0001) discard;\r\n}'
        },
        {},
      ],
      46: [
        function (t, e, n) {
          e.exports =
            'varying vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix *  vec4(position, 1.0);\r\n}'
        },
        {},
      ],
      47: [
        function (t, e, n) {
          'use strict'
          t('../core/settings')
          var s = t('../core/properties'),
            r = (t('./landing'), t('./licenses')),
            c = t('../utils/math'),
            l = t('../utils/ease')
          ;(n.init = function () {
            ;(h = document.getElementById('about-inner')),
              (u = document.getElementById('about-btn')),
              (p = document.getElementById('about-desc')),
              (i = document.getElementById('about-licenses-btn')),
              u.addEventListener('click', a),
              i.addEventListener('click', o)
          }),
            (n.onResize = function (t, e) {}),
            (n.update = function (t) {
              s.width
              var e = s.height,
                n = void 0,
                r = void 0,
                i = void 0
              ;(h.style.pointerEvents = 0.5 < s.aboutRatio ? 'auto' : 'none'),
                (h.style.visibility =
                  0 === s.aboutRatio ? 'hidden' : 'visible'),
                (n = l.easeInOutCubic(c.crange(0, 0.8, s.showRatio))),
                (r = l.easeInOutCubic(c.crange(0, 0.75, s.aboutRatio))),
                (i = l.easeInOutCubic(c.crange(0, 0.6, s.licensesRatio)))
              var a = c.lerp((-80 / 1140) * e, 0, 1 - i)
              {
                var o
                ;(u.style.transform = 'translate3d(0,' + a + 'px,0)'),
                  (u.style.opacity = n * (1 - i)),
                  0 < s.aboutRatio &&
                    ((r = l.easeOutCubic(
                      c.crange(0.35, 1, s.aboutRatio) * (1 - i),
                    )),
                    (o = c.lerp((-80 / 1140) * e, 0, r)),
                    (p.style.transform =
                      'translate3d(-50%, -50%, 0) translate3d(0,' +
                      o +
                      'px,0)'),
                    (p.style.opacity = r))
              }
            }),
            (n.isActive = !1)
          var h = void 0,
            u = void 0,
            p = void 0,
            i = void 0
          function a() {
            ;(n.isActive = !n.isActive),
              document.documentElement.classList.toggle('is-about', n.isActive)
          }
          function o() {
            r.show()
          }
        },
        {
          '../core/properties': 29,
          '../core/settings': 30,
          '../utils/ease': 56,
          '../utils/math': 58,
          './landing': 50,
          './licenses': 51,
        },
      ],
      48: [
        function (t, e, n) {
          'use strict'
          n.init = function () {
            ;(r = document.querySelector('.cookies')),
              (i = document.querySelector('.cookies__button--ok')),
              (function (t) {
                for (
                  var e = t + '=', n = document.cookie.split(';'), r = 0;
                  r < n.length;
                  r++
                ) {
                  for (var i = n[r]; ' ' == i.charAt(0); )
                    i = i.substring(1, i.length)
                  if (0 == i.indexOf(e)) return i.substring(e.length, i.length)
                }
                return
              })('hasAcceptedCookies') ||
                (i.addEventListener('click', a), setTimeout(o, 1500))
          }
          var r = void 0,
            i = void 0
          function a() {
            !(function (t, e, n) {
              var r = ''
              {
                var i
                n &&
                  ((i = new Date()).setTime(
                    i.getTime() + 24 * n * 60 * 60 * 1e3,
                  ),
                  (r = '; expires=' + i.toUTCString()))
              }
              document.cookie = t + '=' + (e || '') + r + '; path=/'
            })('hasAcceptedCookies', !0, 30),
              o(!1)
          }
          function o() {
            var t =
              !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0]
            r.classList.toggle('is-visible', t)
          }
        },
        {},
      ],
      49: [
        function (t, e, n) {
          'use strict'
          var r = t('../core/settings'),
            i = t('../core/properties'),
            a = (t('./landing'), t('../utils/math')),
            o = t('../utils/ease')
          ;(n.init = function () {
            s = document.getElementById('footer')
          }),
            (n.show = function () {}),
            (n.onResize = function (t, e) {
              n.HEIGHT = r.IS_MOBILE ? 40 : 78
            }),
            (n.update = function (t) {
              var e = void 0
              ;(e = o.easeInOutCubic(a.crange(0, 0.4, i.showRatio))),
                (s.style.transform =
                  'translate3d(0,' + (1 - e) * n.HEIGHT + 'px,0)')
            }),
            (n.HEIGHT = 100)
          var s = void 0
        },
        {
          '../core/properties': 29,
          '../core/settings': 30,
          '../utils/ease': 56,
          '../utils/math': 58,
          './landing': 50,
        },
      ],
      50: [
        function (t, e, n) {
          'use strict'
          t('../core/settings')
          var f = t('../core/properties'),
            r = (t('./uiBG'), t('./prompt')),
            i = t('../xr/xr'),
            m = t('../utils/math'),
            v = t('../utils/ease')
          ;(n.init = function () {
            document.getElementById('landing'),
              (g = document.getElementById('landing-title')),
              (y = document.getElementById('landing-desc')),
              (x = document.getElementById('landing-ar-btn')),
              (b = document.getElementById('landing-bottom-text')),
              (o = document.getElementById('xr-ui')),
              (a.domOverlay.root = o),
              x.addEventListener('click', s),
              i.eventDispatcher.addEventListener('start', c),
              i.eventDispatcher.addEventListener('end', l)
          }),
            (n.onResize = function (t, e) {}),
            (n.update = function (t) {
              f.width
              var e = f.height,
                n = void 0,
                r = void 0,
                i = void 0,
                a = void 0
              ;(n = v.easeInOutCubic(m.crange(0, 0.8, f.showRatio))),
                (i = v.easeInOutCubic(m.crange(0.15, 0.75, f.aboutRatio))),
                (a = v.easeInOutCubic(m.crange(0.15, 0.75, f.licensesRatio))),
                (r = Math.max(i, a))
              var o = m.lerp(0.95, 1, v.easeOutBack(n)),
                s = m.lerp(0, (80 / 1140) * e, i)
              ;(g.style.transform =
                'translate3d(0,' + s + 'px,0) scale(' + o + ',' + o + ')'),
                (g.style.opacity = Math.min(m.cfit(n, 0, 0.75, 0, 1), 1 - r)),
                (n = v.easeInOutCubic(m.crange(0.1, 0.9, f.showRatio))),
                (i = v.easeInOutCubic(m.crange(0.075, 0.7, f.aboutRatio))),
                (a = v.easeInOutCubic(m.crange(0.075, 0.7, f.licensesRatio))),
                (r = Math.max(i, a))
              var c = m.lerp(0.95, 1, v.easeOutBack(n)),
                l = m.lerp(0, (80 / 1140) * e, i)
              ;(y.style.transform =
                'translate3d(0,' + l + 'px,0) scale(' + c + ',' + c + ')'),
                (y.style.opacity = Math.min(m.cfit(n, 0, 0.75, 0, 1), 1 - r)),
                (n = v.easeInOutCubic(m.crange(0.2, 1, f.showRatio))),
                (i = v.easeInOutCubic(m.crange(0, 0.65, f.aboutRatio))),
                (a = v.easeInOutCubic(m.crange(0, 0.65, f.licensesRatio))),
                (r = Math.max(i, a))
              var h = m.lerp(0.95, 1, v.easeOutBack(n)),
                u = m.lerp(0, (80 / 1140) * e, i)
              ;(x.style.transform =
                'translate3d(0,' + u + 'px,0) scale(' + h + ',' + h + ')'),
                (x.style.opacity = Math.min(m.cfit(n, 0, 0.75, 0, 1), 1 - r)),
                (n = v.easeInOutCubic(m.crange(0.2, 1, f.showRatio))),
                (i = v.easeInOutCubic(m.crange(0, 0.65, f.aboutRatio))),
                (a = v.easeInOutCubic(m.crange(0, 0.65, f.licensesRatio))),
                (r = Math.max(i, a))
              var p = m.lerp(0.95, 1, v.easeOutBack(n)),
                d = m.lerp(0, (80 / 1140) * e, i)
              ;(b.style.transform =
                'translate3d(0,' + d + 'px,0) scale(' + p + ',' + p + ')'),
                (b.style.opacity = Math.min(m.cfit(n, 0, 0.75, 0, 1), 1 - r))
            })
          var a = {
              requiredFeatures: ['hit-test', 'dom-overlay'],
              domOverlay: { root: null },
            },
            g = void 0,
            y = void 0,
            x = void 0,
            o = void 0,
            b = void 0
          function s(t) {
            t.preventDefault(), f.isSupportWebXR ? i.start(a) : r.show()
          }
          function c() {
            document.body.classList.add('is-webxr')
          }
          function l() {
            document.body.classList.remove('is-webxr')
          }
        },
        {
          '../core/properties': 29,
          '../core/settings': 30,
          '../utils/ease': 56,
          '../utils/math': 58,
          '../xr/xr': 67,
          './prompt': 52,
          './uiBG': 54,
        },
      ],
      51: [
        function (t, e, n) {
          'use strict'
          t('../core/settings')
          var o = t('../core/properties'),
            s = t('../utils/math'),
            c = t('../utils/ease')
          ;(n.init = function () {
            ;(l = document.getElementById('licenses')),
              (h = document.getElementById('licenses-title')),
              (u = document.getElementById('licenses-content-inner')),
              (p = document.getElementById('licenses-btn')).addEventListener(
                'click',
                r,
              )
          }),
            (n.show = function () {
              n.isActive = !0
            }),
            (n.onResize = function (t, e) {}),
            (n.update = function (t) {
              o.width
              var e = o.height,
                n = void 0
              {
                var r, i, a
                ;(l.style.display = 0 < o.licensesRatio ? 'block' : 'none'),
                  0 < o.licensesRatio &&
                    ((n = c.easeOutCubic(s.crange(0.55, 1, o.licensesRatio))),
                    (r = s.lerp((40 / 1140) * e, 0, n)),
                    (h.style.transform = 'translate3d(0,' + r + 'px,0)'),
                    (h.style.opacity = n),
                    (n = c.easeOutCubic(s.crange(0.5, 1, o.licensesRatio))),
                    (i = s.lerp((80 / 1140) * e, 0, n)),
                    (u.style.transform = 'translate3d(0,' + i + 'px,0)'),
                    (u.style.opacity = n),
                    (n = c.easeOutCubic(s.crange(0.4, 1, o.licensesRatio))),
                    (a = s.lerp((80 / 1140) * e, 0, n)),
                    (p.style.transform = 'translate3d(0,' + a + 'px,0)'),
                    (p.style.opacity = n))
              }
            }),
            (n.isActive = !1)
          var l = void 0,
            h = void 0,
            u = void 0,
            p = void 0
          function r() {
            ;(n.isActive = !n.isActive),
              document.documentElement.classList.toggle(
                'is-licenses',
                n.isActive,
              )
          }
        },
        {
          '../core/properties': 29,
          '../core/settings': 30,
          '../utils/ease': 56,
          '../utils/math': 58,
        },
      ],
      52: [
        function (t, e, n) {
          'use strict'
          t('../xr/xr')
          ;(n.init = function () {
            document.getElementById('prompt-btn').addEventListener('click', r),
              document.documentElement.classList.contains('is-android-chrome')
                ? (document.querySelector(
                    '.prompt-msg.is-browser',
                  ).style.display = 'block')
                : (document.querySelector(
                    '.prompt-msg.is-device',
                  ).style.display = 'block')
          }),
            (n.show = function () {
              document.documentElement.classList.add('is-prompt')
            }),
            (n.hide = i)
          function r() {
            i()
          }
          function i() {
            document.documentElement.classList.remove('is-prompt')
          }
        },
        { '../xr/xr': 67 },
      ],
      53: [
        function (t, e, n) {
          'use strict'
          var r = t('../core/settings'),
            i = t('../core/properties'),
            a = t('../utils/math'),
            o = t('./uiBG'),
            s = t('./xrUI'),
            c = t('./footer'),
            l = t('./landing'),
            h = t('./about'),
            u = t('./licenses'),
            p = t('./prompt'),
            d = t('./cookies')
          ;(n.init = function () {
            c.init(),
              l.init(),
              h.init(),
              u.init(),
              p.init(),
              d.init(),
              i.isSupportWebXR && s.init()
            o.init()
          }),
            (n.onResize = function (t, e) {
              c.onResize(t, e),
                l.onResize(t, e),
                h.onResize(t, e),
                u.onResize(t, e),
                o.onResize(t, e)
            }),
            (n.update = function (t) {
              ;(i.showRatio = a.saturate(
                i.showRatio + 1 / r.SHOW_DURATION / 60,
              )),
                document.documentElement.classList.toggle(
                  'is-ready',
                  1 === i.showRatio,
                ),
                (i.aboutRatio = a.saturate(
                  i.aboutRatio + (h.isActive ? 1 : -1) / r.ABOUT_DURATION / 60,
                )),
                (i.licensesRatio = a.saturate(
                  i.licensesRatio +
                    (u.isActive ? 1 : -1.3) / r.LICENSES_DURATION / 60,
                )),
                i.isSupportWebXR && s.update(t)
              c.update(t), l.update(t), h.update(t), u.update(t), o.update(t)
            })
        },
        {
          '../core/properties': 29,
          '../core/settings': 30,
          '../utils/math': 58,
          './about': 47,
          './cookies': 48,
          './footer': 49,
          './landing': 50,
          './licenses': 51,
          './prompt': 52,
          './uiBG': 54,
          './xrUI': 55,
        },
      ],
      54: [
        function (t, e, x) {
          'use strict'
          var i = t('../core/settings'),
            b = t('../core/properties'),
            _ = t('../utils/math'),
            w = t('../utils/ease'),
            M = t('./footer'),
            S = t('../xr/xr'),
            n = t('three')
          ;(x.init = function () {
            ;(r = document.getElementById('bg-canvas')),
              (A = r.getContext('2d')),
              (B = new n.Color()),
              (N = new n.Color()),
              (U = new n.Color(i.COLOR_ACCENT_HEX)),
              (function () {
                var t = document.createElement('canvas'),
                  e = t.getContext('2d')
                ;(t.width = 35 * L),
                  (t.height = 16 * L),
                  (e.fillStyle = i.COLOR_DARK_HEX),
                  e.scale(L, L)
                for (var n = 4, r = 0; r < 5; r++)
                  e.fillRect(n, 0, 1, 2 == r ? 15 : 7), (n += 7)
                D = A.createPattern(t, 'repeat')
              })(),
              (function () {
                for (var t = 0; t < 8; t++) z[t] = new n.Vector2()
              })(),
              (R = new n.Vector3()),
              (C = new n.Vector3()),
              (P = new n.Vector3()),
              (O = new n.Vector3()),
              (I = new n.Vector3())
          }),
            (x.onResize = function (t, e) {
              ;(r.width = t * L), (r.height = e * L)
            }),
            (x.update = function (t) {
              if (S.isActive) return
              var e = void 0
              e = w.easeInOutCubic(_.crange(0.35, 0.85, b.showRatio))
              var n = b.width,
                r = b.height
              B.copy(b.darkColor).lerp(
                b.brightColor,
                Math.max(b.licensesRatio, b.aboutRatio),
              ),
                N.copy(b.brightColor).lerp(
                  b.darkColor,
                  Math.max(b.licensesRatio, b.aboutRatio),
                ),
                A.clearRect(0, 0, n * L, r * L),
                A.save(),
                (A.fillStyle = D),
                A.save(),
                A.translate(20 * L, -15 * (1 - e) * L),
                A.fillRect(0, 0, (n - 40) * L, 15 * L),
                A.restore(),
                A.save(),
                A.translate(20 * L, (r - M.HEIGHT * e + 15 * (1 - e)) * L),
                A.scale(1, -1),
                A.fillRect(0, 0, (n - 40) * L, 15 * L),
                A.restore(),
                A.save(),
                A.translate(n * L + 15 * (1 - e) * L, 0),
                A.rotate(0.5 * Math.PI),
                A.fillRect(0, 0, (r - M.HEIGHT) * L, 15 * L),
                A.restore(),
                A.save(),
                A.translate(-15 * (1 - e) * L, 0),
                A.scale(-1, 1),
                A.rotate(0.5 * Math.PI),
                A.fillRect(0, 0, (r - M.HEIGHT) * L, 15 * L),
                A.restore(),
                (A.globalCompositeOperation = 'source-in'),
                (A.fillStyle = B.getStyle()),
                A.fillRect(0, 0, n * L, r * L),
                A.restore(),
                A.save(),
                A.scale(L, L),
                A.save(),
                (A.fillStyle = N.getStyle()),
                (A.globalCompositeOperation = 'destination-over'),
                A.fillRect(0, 0, n, r),
                A.restore()
              var i = 1 - Math.max(b.licensesRatio, b.aboutRatio)
              {
                var a, o, s, c, l, h, u, p, d, f, m, v, g, y
                0 < i &&
                  ((a =
                    'rgba(' +
                    Math.round(255 * U.r) +
                    ',' +
                    Math.round(255 * U.g) +
                    ',' +
                    Math.round(255 * U.b) +
                    ',' +
                    i +
                    ')'),
                  (o = ((G += t) / H) % 10),
                  (s = void 0),
                  E.set(0.6, 1, 0.2),
                  (x.depthAngle = 1),
                  3 < o &&
                    ((s = _.saturate(1.5 * (Math.min(1, o - 3) - 0.5) + 0.5)),
                    (s = w.easeInOutCubic(s)),
                    I.set(1, 0.5, 0.2),
                    E.lerp(I, s),
                    (x.depthAngle = _.lerp(x.depthAngle, -1, s))),
                  4 < o &&
                    ((s = _.saturate(1.5 * (Math.min(1, o - 4) - 0.5) + 0.5)),
                    (s = w.easeInOutCubic(s)),
                    I.set(0.5, 0.5, 0.2),
                    E.lerp(I, s),
                    (x.depthAngle = _.lerp(x.depthAngle, -1, s))),
                  5 < o &&
                    ((s = _.saturate(1.5 * (Math.min(1, o - 5) - 0.5) + 0.5)),
                    (s = w.easeInOutCubic(s)),
                    I.set(0.6, 0.7, 0.8),
                    E.lerp(I, s),
                    (x.depthAngle = _.lerp(x.depthAngle, -0.5, s))),
                  T.set(-1, 1, 1),
                  (s = _.saturate(1.5 * (Math.min(1, o) - 0.5) + 0.5)),
                  (s = w.easeInOutCubic(s)),
                  (T.x = s - 1),
                  1 < o &&
                    ((s = _.saturate(1.5 * (Math.min(1, o - 1) - 0.5) + 0.5)),
                    (s = w.easeInOutCubic(s)),
                    (T.y = 1 - s)),
                  2 < o &&
                    ((s = _.saturate(1.5 * (Math.min(1, o - 2) - 0.5) + 0.5)),
                    (s = w.easeInOutCubic(s)),
                    (T.z = 1 - s)),
                  6 < o &&
                    ((s = _.saturate(1.5 * (Math.min(1, o - 6) - 0.5) + 0.5)),
                    (s = w.easeInOutCubic(s)),
                    (T.z = -s)),
                  7 < o &&
                    ((s = _.saturate(1.5 * (Math.min(1, o - 7) - 0.5) + 0.5)),
                    (s = w.easeInOutCubic(s)),
                    (T.y = -s)),
                  8 < o &&
                    ((s = _.saturate(1.5 * (Math.min(1, o - 8) - 0.5) + 0.5)),
                    (s = w.easeInOutCubic(s)),
                    (T.x = s)),
                  A.translate(0.5 * n, 0.4 * r),
                  (c = 0.6 * Math.min(850, Math.min(n, r))),
                  (R.x = T.x < 0 ? 0 : 1),
                  (R.y = T.y < 0 ? 0 : 1),
                  (R.z = T.z < 0 ? 0 : 1),
                  (l = Math.PI * (0.25 * x.depthAngle)),
                  O.set(1, 1, 1 / Math.cos(l)).multiplyScalar(0.8 * c),
                  P.copy(O).multiply(E),
                  C.set(
                    1 - Math.abs(T.x),
                    1 - Math.abs(T.y),
                    1 - Math.abs(T.z),
                  ).multiply(P),
                  (h = Math.sin(l) * C.z),
                  (u = Math.cos(-l) * C.z),
                  (p = Math.sin(l) * P.z),
                  (d = Math.cos(-l) * P.z),
                  (f = 0.5 * -p),
                  3 < o &&
                    ((s = _.saturate(1.5 * (Math.min(1, o - 3) - 0.5) + 0.5)),
                    (f = (1 - w.easeInOutCubic(s)) * -p * 0.5)),
                  A.translate(f, 0),
                  A.translate(
                    P.x * (-0.5 + R.x) + p * (-0.5 + R.z),
                    P.y * (-0.5 + R.y) + d * (-0.5 + R.z),
                  ),
                  z[0].set(0, C.y * (1 - 2 * R.y)),
                  z[1].set(C.x * (1 - 2 * R.x), C.y * (1 - 2 * R.y)),
                  z[2].set(0, 0),
                  z[3].set(C.x * (1 - 2 * R.x), 0),
                  z[4].set(
                    h * (1 - 2 * R.z),
                    C.y * (1 - 2 * R.y) + u * (1 - 2 * R.z),
                  ),
                  z[5].set(
                    C.x * (1 - 2 * R.x) + h * (1 - 2 * R.z),
                    C.y * (1 - 2 * R.y) + u * (1 - 2 * R.z),
                  ),
                  z[6].set(h * (1 - 2 * R.z), u * (1 - 2 * R.z)),
                  z[7].set(
                    C.x * (1 - 2 * R.x) + h * (1 - 2 * R.z),
                    u * (1 - 2 * R.z),
                  ),
                  (m = 1),
                  o < 0.15
                    ? (m = o / 0.15)
                    : 8.85 < o && (m = Math.max(0, (9 - o) / 0.15)),
                  (A.fillStyle = a),
                  k(z[0], m),
                  (v = Math.abs(T.x) < 1),
                  (g = Math.abs(T.y) < 1),
                  (y = Math.abs(T.z) < 1),
                  v && k(z[1], m),
                  g && (k(z[2], m), v && k(z[3], m)),
                  y &&
                    (k(z[4], m),
                    v && k(z[5], m),
                    g && (k(z[6], m), v && k(z[7], m))),
                  (A.strokeStyle = a),
                  (A.lineWidth = F),
                  V(z[0], z[1]),
                  V(z[2], z[3]),
                  V(z[0], z[2]),
                  V(z[1], z[3]),
                  V(z[0], z[4]),
                  V(z[1], z[5]),
                  V(z[2], z[6]),
                  V(z[3], z[7]),
                  V(z[4], z[5]),
                  V(z[6], z[7]),
                  V(z[4], z[6]),
                  V(z[5], z[7]))
              }
              A.restore()
            })
          var E = (x.sizes = new n.Vector3(1, 1, 0.5)),
            T = (x.sides = new n.Vector3(0, 0, 0))
          x.depthAngle = 0.75
          var r = void 0,
            A = void 0,
            L = window.devicePixelRatio ? window.devicePixelRatio : 1,
            R = void 0,
            C = void 0,
            P = void 0,
            O = void 0,
            I = void 0,
            D = void 0,
            B = void 0,
            N = void 0,
            U = void 0,
            z = [],
            a = 5,
            F = 1.5,
            H = 0.7,
            G = 0
          function k(t, e) {
            A.beginPath(),
              A.arc(t.x, t.y, a * e, 0, 2 * Math.PI),
              A.closePath(),
              A.fill()
          }
          function V(t, e) {
            2 < t.distanceTo(e) &&
              (A.beginPath(),
              A.moveTo(t.x, t.y),
              A.lineTo(e.x, e.y),
              A.closePath(),
              A.stroke())
          }
        },
        {
          '../core/properties': 29,
          '../core/settings': 30,
          '../utils/ease': 56,
          '../utils/math': 58,
          '../xr/xr': 67,
          './footer': 49,
          'three': 24,
        },
      ],
      55: [
        function (t, e, o) {
          'use strict'
          var n = t('../core/settings'),
            r = t('../core/properties'),
            i = t('three'),
            a = t('../xr/xr'),
            s = t('../ui/prompt'),
            c = t('../visuals/visuals'),
            l = t('../measurement/measurement'),
            h = t('../utils/math'),
            u = t('../utils/ease')
          ;(o.init = function () {
            ;(G = ht(nt, ot)),
              (k = ht(rt, st)),
              (V = ht(it)),
              (p = document.getElementById('xr-ui')),
              (d = document.querySelector('.xr__close')),
              (f = document.querySelector('.xr__how-to')),
              (m = document.querySelector('.xr__pin')),
              (v = document.querySelector('.xr__pin-spotlight')),
              (g = document.querySelector('.xr__pin-triangle')),
              (b = document.querySelector('.xr__unit-text')),
              (_ = document.querySelector('.xr__unit-btn')),
              (y = document.querySelector('.xr__undo')),
              (x = document.querySelector('.xr__done')),
              a.eventDispatcher.addEventListener('start', ut),
              a.eventDispatcher.addEventListener('end', pt),
              a.eventDispatcher.addEventListener('error', dt)
          }),
            (o.onResize = function (t, e) {}),
            (o.togglePinButton = function (t) {
              m.classList.toggle('is-refresh', !!t)
            }),
            (o.update = function (t) {
              ;(M += t),
                document.body.classList.toggle('reticle-is-visible', !!a.isHit),
                (R = a.isActive
                  ? ((I =
                      r.pinCanShow &&
                      ((l.isEditMode && !!a.isHit) ||
                        (l.isEditMode && 3 <= l.step) ||
                        !l.isEditMode)),
                    (E = 0 < l.step && l.isEditMode),
                    1 < l.step && l.step < 4 && l.isEditMode)
                  : (E = I = !1))
              ;(D = h.saturate(
                D + (I ? 1 : -1) / n.XR_BUTTONS_SHOW_DURATION / 60,
              )),
                (T = h.saturate(
                  T + (E ? 1 : -1) / n.XR_BUTTONS_SHOW_DURATION / 60,
                )),
                (C = h.saturate(
                  C + (R ? 1 : -1) / n.XR_BUTTONS_SHOW_DURATION / 60,
                )),
                (U = h.saturate(
                  U + (S ? -1 : 1) / n.XR_BUTTONS_SHOW_DURATION / 60,
                )),
                (c.reticle.visible = 0 < D),
                (c.reticle.ring.material.uniforms.u_opacity.value = 0.5 * D),
                (B = u.easeOutCubic(h.crange(0.35, 1, D))),
                (N = 1 - B),
                (A = u.easeOutCubic(h.crange(0.35, 1, T))),
                (L = 1 - A),
                (P = u.easeOutCubic(h.crange(0.35, 1, C))),
                (O = 1 - P),
                (z = u.easeOutCubic(h.crange(0.35, 1, U))),
                (F = h.cfit(Math.sin(3 * M), -1, 1, 0.85, 1)),
                (H = h.cfit(Math.sin(3 * M), -1, 1, 0, -35)),
                (m.style.pointerEvents = 0 < I ? 'all' : 'none'),
                (y.style.pointerEvents = 0 < E ? 'all' : 'none'),
                (x.style.pointerEvents = 0 < R ? 'all' : 'none'),
                (m.style.opacity = B),
                (y.style.opacity = A),
                (x.style.opacity = P),
                (v.style.opacity = z),
                (g.style.opacity = z),
                (m.style.transform = 'translate3d(0,' + 10 * N + 'px,0)'),
                (y.style.transform = 'translate3d(0,' + 10 * L + 'px,0)'),
                (x.style.transform = 'translate3d(0,' + 10 * O + 'px,0)'),
                (v.style.transform = 'scale(' + F + ')'),
                (g.style.transform = 'translate3d(0,' + H + 'px,0)'),
                (w = ''),
                l.distances.AB &&
                  ((w += (l.distances.AB * r.unitMultiplier).toFixed(1)),
                  l.distances.BC &&
                    ((w +=
                      ' x ' + (l.distances.BC * r.unitMultiplier).toFixed(1)),
                    l.distances.CD &&
                      (w +=
                        ' x ' +
                        (l.distances.CD * r.unitMultiplier).toFixed(1))))
              ;(b.innerHTML = w),
                (b.style.opacity = null !== l.distances.AB ? 1 : 0)
              var e =
                h.cfit(r.instructionShowRatio, 0.35, 0.55, 0, 1) *
                h.cfit(r.instructionHideRatio, 0, 0.3, 1, 0)
              ;(f.style.opacity = e),
                (f.style.transform =
                  'translateY(' +
                  40 * (1 - e) +
                  'px) translate3d(-50%, -50%, 0)')
            }),
            (o.inputEventDispatcher = new i.EventDispatcher()),
            (o.btnClickEventDispatcher = new i.EventDispatcher())
          var p = void 0,
            d = void 0,
            f = void 0,
            m = void 0,
            v = void 0,
            g = void 0,
            y = void 0,
            x = void 0,
            b = void 0,
            _ = void 0,
            w = '',
            M = 0,
            S = !1,
            E = !1,
            T = 0,
            A = 0,
            L = 0,
            R = !1,
            C = 0,
            P = 0,
            O = 0,
            I = !1,
            D = 0,
            B = 0,
            N = 0,
            U = 0,
            z = 0,
            F = 0,
            H = 0,
            G = void 0,
            k = void 0,
            V = void 0,
            j = !1,
            W = { x: -1, y: -1 },
            q = { x: -1, y: -1 },
            X = { x: -1, y: -1 },
            Y = { x: -1, y: -1 },
            Z = { x: -1, y: -1 },
            J = { x: -1, y: -1 }
          function Q() {
            d.removeEventListener('click', a.end),
              m.removeEventListener('click', K),
              y.removeEventListener('click', $),
              p.removeEventListener('mousedown', nt),
              p.removeEventListener('touchstart', G),
              p.removeEventListener('mousemove', rt),
              p.removeEventListener('touchmove', k),
              p.removeEventListener('mouseup', it),
              p.removeEventListener('touchend', V)
          }
          function K(t) {
            ;(S = !0),
              o.btnClickEventDispatcher.dispatchEvent({ type: 'pin', evt: t })
          }
          function $(t) {
            o.btnClickEventDispatcher.dispatchEvent({ type: 'undo', evt: t })
          }
          function tt(t) {
            o.btnClickEventDispatcher.dispatchEvent({ type: 'done', evt: t })
          }
          function et(t) {
            ;(r.unitIsInch = !r.unitIsInch),
              (_.innerHTML = r.unitIsInch ? 'in' : 'cm'),
              (r.unitMultiplier = r.unitIsInch ? 0.3937 : 1)
          }
          function nt(t) {
            ;(W = at(t)),
              (q = at(t)),
              (j = !0),
              o.inputEventDispatcher.dispatchEvent({
                type: 'down',
                evt: t,
                xy: W,
              }),
              rt(t)
          }
          function rt(t) {
            j &&
              ((q = at(t)),
              o.inputEventDispatcher.dispatchEvent({
                type: 'move',
                evt: t,
                xy: q,
              }))
          }
          function it(t) {
            ;(j = !1),
              o.inputEventDispatcher.dispatchEvent({
                type: 'up',
                evt: t,
                xy: q,
              })
          }
          function at(t) {
            var e = p.getBoundingClientRect()
            return {
              x: ((t.clientX - e.left) / e.width) * 2 - 1,
              y: 1 - ((t.clientY - e.top) / e.height) * 2,
            }
          }
          function ot(t, e) {
            ;(X = at(t)), (Y = at(e)), 0
            var n = ct(X, Y),
              r = lt(X, Y)
            o.inputEventDispatcher.dispatchEvent({
              type: 'multidown',
              evt: evt,
              xy1: X,
              xy2: Y,
              angle: n,
              distance: r,
            }),
              st(t, e)
          }
          function st(t, e) {
            ;(Z = at(t)), (J = at(e))
            var n = ct(X, Y),
              r = lt(X, Y),
              i = ct(Z, J),
              a = lt(Z, J)
            o.inputEventDispatcher.dispatchEvent({
              type: 'multimove',
              evt: evt,
              xy1: Z,
              xy2: J,
              downAngle: n,
              downDistance: r,
              angle: i,
              distance: a,
            })
          }
          function ct(t, e) {
            return Math.atan2(e.y - t.y, e.x - t.x)
          }
          function lt(t, e) {
            var n = e.x - t.x,
              r = e.y - t.y
            return Math.sqrt(n * n + r * r)
          }
          function ht(e, n) {
            return function (t) {
              n && 2 == t.touches.length
                ? n.call(this, t.touches[0], t.touches[1])
                : e.call(this, t.changedTouches[0] || t.touches[0])
            }
          }
          function ut() {
            d.addEventListener('click', a.end),
              m.addEventListener('click', K),
              y.addEventListener('click', $),
              x.addEventListener('click', tt),
              _.addEventListener('click', et),
              p.addEventListener('mousedown', nt),
              p.addEventListener('touchstart', G),
              p.addEventListener('mousemove', rt),
              p.addEventListener('touchmove', k),
              p.addEventListener('mouseup', it),
              p.addEventListener('touchend', V)
          }
          function pt() {
            ;(S = !1), Q()
          }
          function dt(t) {
            Q(), s.show()
          }
        },
        {
          '../core/properties': 29,
          '../core/settings': 30,
          '../measurement/measurement': 39,
          '../ui/prompt': 52,
          '../utils/ease': 56,
          '../utils/math': 58,
          '../visuals/visuals': 66,
          '../xr/xr': 67,
          'three': 24,
        },
      ],
      56: [
        function (t, e, n) {
          'use strict'
          var r = {
            Linear: {
              None: function (t) {
                return t
              },
            },
            Quad: {
              In: function (t) {
                return t * t
              },
              Out: function (t) {
                return t * (2 - t)
              },
              InOut: function (t) {
                return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1)
              },
            },
            Cubic: {
              In: function (t) {
                return t * t * t
              },
              Out: function (t) {
                return --t * t * t + 1
              },
              InOut: function (t) {
                return (t *= 2) < 1
                  ? 0.5 * t * t * t
                  : 0.5 * ((t -= 2) * t * t + 2)
              },
            },
            Quart: {
              In: function (t) {
                return t * t * t * t
              },
              Out: function (t) {
                return 1 - --t * t * t * t
              },
              InOut: function (t) {
                return (t *= 2) < 1
                  ? 0.5 * t * t * t * t
                  : -0.5 * ((t -= 2) * t * t * t - 2)
              },
            },
            Quint: {
              In: function (t) {
                return t * t * t * t * t
              },
              Out: function (t) {
                return --t * t * t * t * t + 1
              },
              InOut: function (t) {
                return (t *= 2) < 1
                  ? 0.5 * t * t * t * t * t
                  : 0.5 * ((t -= 2) * t * t * t * t + 2)
              },
            },
            Sine: {
              In: function (t) {
                return 1 - Math.cos((t * Math.PI) / 2)
              },
              Out: function (t) {
                return Math.sin((t * Math.PI) / 2)
              },
              InOut: function (t) {
                return 0.5 * (1 - Math.cos(Math.PI * t))
              },
            },
            Expo: {
              In: function (t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1)
              },
              Out: function (t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
              },
              InOut: function (t) {
                return 0 === t
                  ? 0
                  : 1 === t
                    ? 1
                    : (t *= 2) < 1
                      ? 0.5 * Math.pow(1024, t - 1)
                      : 0.5 * (2 - Math.pow(2, -10 * (t - 1)))
              },
            },
            Circular: {
              In: function (t) {
                return 1 - Math.sqrt(1 - t * t)
              },
              Out: function (t) {
                return Math.sqrt(1 - --t * t)
              },
              InOut: function (t) {
                return (t *= 2) < 1
                  ? -0.5 * (Math.sqrt(1 - t * t) - 1)
                  : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
              },
            },
            Elastic: {
              In: function (t) {
                return 0 === t
                  ? 0
                  : 1 === t
                    ? 1
                    : -Math.pow(2, 10 * (t - 1)) *
                      Math.sin(5 * (t - 1.1) * Math.PI)
              },
              Out: function (t) {
                return 0 === t
                  ? 0
                  : 1 === t
                    ? 1
                    : Math.pow(2, -10 * t) * Math.sin(5 * (t - 0.1) * Math.PI) +
                      1
              },
              InOut: function (t) {
                return 0 === t
                  ? 0
                  : 1 === t
                    ? 1
                    : (t *= 2) < 1
                      ? -0.5 *
                        Math.pow(2, 10 * (t - 1)) *
                        Math.sin(5 * (t - 1.1) * Math.PI)
                      : 0.5 *
                          Math.pow(2, -10 * (t - 1)) *
                          Math.sin(5 * (t - 1.1) * Math.PI) +
                        1
              },
            },
            Back: {
              In: function (t) {
                return t * t * (2.70158 * t - 1.70158)
              },
              Out: function (t) {
                return --t * t * (2.70158 * t + 1.70158) + 1
              },
              InOut: function (t) {
                var e = 2.5949095
                return (t *= 2) < 1
                  ? t * t * ((1 + e) * t - e) * 0.5
                  : 0.5 * ((t -= 2) * t * ((1 + e) * t + e) + 2)
              },
            },
            Bounce: {
              In: function (t) {
                return 1 - r.Bounce.Out(1 - t)
              },
              Out: function (t) {
                return t < 1 / 2.75
                  ? 7.5625 * t * t
                  : t < 2 / 2.75
                    ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
                    : t < 2.5 / 2.75
                      ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
                      : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375
              },
              InOut: function (t) {
                return t < 0.5
                  ? 0.5 * r.Bounce.In(2 * t)
                  : 0.5 * r.Bounce.Out(2 * t - 1) + 0.5
              },
            },
          }
          n.linear = r.Linear.None
          var i = void 0,
            a = void 0
          for (i in r)
            'Linear' !== i &&
              ((a = r[i]),
              (n['easeIn' + i] = a.In),
              (n['easeOut' + i] = a.Out),
              (n['easeInOut' + i] = a.InOut),
              (n['easeOutIn' + i] = a.OutIn =
                (function (e, n) {
                  return function (t) {
                    return t < 0.5 ? 0.5 * n(2 * t) : 0.5 * e(2 * t - 1) + 0.5
                  }
                })(a.In, a.Out)))
        },
        {},
      ],
      57: [
        function (t, e, n) {
          'use strict'
          n.parseBuf = function (t) {
            for (
              var e = new Uint32Array(t, 0, 1)[0],
                n = JSON.parse(
                  String.fromCharCode.apply(null, new Uint8Array(t, 4, e)),
                ),
                r = n.vertexCount,
                i = n.indexCount,
                a = 4 + e,
                o = new THREE.BufferGeometry(),
                s = n.attributes,
                c = 0,
                l = s.length;
              c < l;
              c++
            ) {
              var h = s[c],
                u = h.id,
                p = 'indices' === u ? i : r,
                d = h.componentSize,
                f = window[h.storageType],
                m = new f(t, a, p * d),
                v = f.BYTES_PER_ELEMENT,
                g = void 0
              if (h.needsPack) {
                var y = h.packedComponents,
                  x = y.length,
                  b = 0 === h.storageType.indexOf('Int'),
                  _ = 1 << (8 * v),
                  w = b ? 0.5 * _ : 0,
                  M = 1 / _
                g = new Float32Array(p * d)
                for (var S = 0, E = 0; S < p; S++)
                  for (var T = 0; T < x; T++) {
                    var A = y[T]
                    ;(g[E] = (m[E] + w) * M * A.delta + A.from), E++
                  }
              } else g = m
              'indices' === u
                ? o.setIndex(new THREE.BufferAttribute(g, 1))
                : o.setAttribute(u, new THREE.BufferAttribute(g, d)),
                (a += p * d * v)
            }
            return o
          }
        },
        {},
      ],
      58: [
        function (t, e, n) {
          'use strict'
          function r(t, e, n) {
            return Math.min(n, Math.max(e, t))
          }
          function i(t) {
            return r(t, 0, 1)
          }
          function o(t, e, n) {
            return n * (e - t) + t
          }
          function s(t, e, n) {
            return (n - t) / (e - t)
          }
          function c(t, e, n) {
            return i(s(t, e, n))
          }
          ;(n.clamp = r),
            (n.saturate = i),
            (n.lerp = o),
            (n.range = s),
            (n.crange = c),
            (n.fit = function (t, e, n, r, i, a) {
              ;(t = s(e, n, t)), a && (t = a(t))
              return o(r, i, t)
            }),
            (n.cfit = function (t, e, n, r, i, a) {
              ;(t = c(e, n, t)), a && (t = a(t))
              return o(r, i, t)
            })
        },
        {},
      ],
      59: [
        function (t, e, n) {
          e.exports =
            'uniform float u_opacity;\r\n\r\nvarying vec3 v_viewNormal;\r\nvarying vec3 v_color;\r\nvarying float v_ao;\r\n\r\nvoid main () {\r\n\r\n\tfloat diff = smoothstep(-2.0, 1.0, dot(normalize(v_viewNormal), vec3(0.57735))) + 0.1;\r\n\r\n\tvec3 color = v_color * diff * (0.85 + v_ao * 0.15);\r\n\tgl_FragColor = vec4(color, u_opacity);\r\n}'
        },
        {},
      ],
      60: [
        function (r, t, e) {
          'use strict'
          var n = r('../../../core/settings'),
            i = r('../../../core/properties'),
            a = r('../../../utils/geom'),
            o = r('../../../xr/xr'),
            s = r('../../../utils/math'),
            c = r('../../../utils/ease')
          ;(e.init = function () {
            ;(u = { value: 0 }),
              (l = e.container = new THREE.Object3D()),
              (h = new THREE.Object3D()),
              l.add(h)
            var t = new XMLHttpRequest()
            t.open('GET', n.MODELS_PATH + 'hand.buf'),
              (t.responseType = 'arraybuffer'),
              (t.onload = function () {
                var t, e, n
                200 === this.status &&
                  ((t = a.parseBuf(this.response)),
                  (e = new THREE.ShaderMaterial({
                    uniforms: {
                      u_handColor: { value: new THREE.Color(16579836) },
                      u_screenColor: { value: new THREE.Color(2169372) },
                      u_opacity: u,
                    },
                    transparent: !0,
                    vertexShader: r('./hand.vert'),
                    fragmentShader: r('./hand.frag'),
                  })),
                  (n = new THREE.Mesh(t, e)).scale
                    .set(1, 1, 1)
                    .multiplyScalar(0.3),
                  h.add(n),
                  (n.renderOrder = 4096))
              }),
              t.send()
          }),
            (e.reset = function () {
              p = 0
            }),
            (e.update = function (t) {
              var e = o.getCamera()
              ;(p += t),
                (h.rotation.x = 0.2 * Math.sin(5 * -p) + 0.3),
                (h.rotation.y = 0.3 * Math.cos(3 * p)),
                (h.rotation.z = 0.1 * Math.cos(2 * p))
              var n =
                s.cfit(i.instructionShowRatio, 0.35, 0.55, 0, 1) *
                s.cfit(i.instructionHideRatio, 0, 0.3, 1, 0)
              ;(u.value = n),
                l.position.copy(e.position),
                l.quaternion.copy(e.quaternion),
                l.translateZ(-0.2),
                l.translateY(0.05 * c.easeOutSine(n) - 0.03),
                (l.visible = 0 < n)
            })
          var l = (e.container = null),
            h = void 0,
            u = void 0,
            p = 0
        },
        {
          '../../../core/properties': 29,
          '../../../core/settings': 30,
          '../../../utils/ease': 56,
          '../../../utils/geom': 57,
          '../../../utils/math': 58,
          '../../../xr/xr': 67,
          './hand.frag': 59,
          './hand.vert': 61,
        },
      ],
      61: [
        function (t, e, n) {
          e.exports =
            'attribute float occlusion;\r\n\r\nuniform vec3 u_handColor;\r\nuniform vec3 u_screenColor;\r\n\r\nvarying vec3 v_viewNormal;\r\nvarying vec3 v_color;\r\nvarying float v_ao;\r\n\r\nvoid main () {\r\n\tfloat isHand = occlusion > 0.05 ? 1.0 : 0.0;\r\n\tv_ao = mix(1.0, (occlusion - 0.1) * 1.11111, isHand);\r\n\tv_color = mix(u_screenColor, u_handColor, isHand);\r\n\r\n\tv_viewNormal = normalMatrix * normalize(normal);\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}'
        },
        {},
      ],
      62: [
        function (e, t, n) {
          'use strict'
          var r = e('three'),
            i = e('../../../xr/xr'),
            a = e('./reticleData'),
            o = e('../../../utils/math'),
            s = e('../../../utils/ease')
          function c() {
            l.constructor.call(this),
              (this.ratio = 0),
              (this.innerRadius = 0.08),
              (this.outerRadius = 0.1),
              (this.spikeRadius = 0.12),
              (this.visible = !1)
            var t = new r.BufferGeometry()
            t.addAttribute('position', new r.BufferAttribute(a.position, 3)),
              t.setIndex(new r.BufferAttribute(a.indices, 1)),
              (this.ring = new r.Mesh(
                t,
                new r.ShaderMaterial({
                  uniforms: {
                    u_innerRadius: { value: 0.08 },
                    u_outerRadius: { value: 0.1 },
                    u_spikeRadius: { value: 0.12 },
                    u_opacity: { value: 0.5 },
                  },
                  vertexShader: e('./reticle.vert'),
                  fragmentShader: e('./reticle.frag'),
                  transparent: !0,
                  side: r.BackSide,
                  depthTest: !1,
                  depthWrite: !1,
                }),
              )),
              this.add(this.ring),
              (this.center = new r.Mesh(
                new r.CircleBufferGeometry(0.01, 16).rotateX(-Math.PI / 2),
                new r.MeshBasicMaterial({
                  transparent: !0,
                  opacity: 1,
                  depthTest: !1,
                  depthWrite: !1,
                }),
              )),
              this.add(this.center),
              (this.renderOrder = 1e4)
          }
          var l = r.Object3D.prototype,
            h = (c.prototype = Object.create(l))
          t.exports = c
          h.update = function (t) {
            this.visible || (this.ratio = 0)
            this.ratio = Math.min(1, this.ratio + 1.5 * t)
            var e = this.ring.material.uniforms
            ;(e.u_innerRadius.value = o.cfit(
              this.ratio,
              0.2,
              0.85,
              0,
              this.innerRadius,
              s.easeInOutSine,
            )),
              (e.u_outerRadius.value = o.cfit(
                this.ratio,
                0,
                0.65,
                0,
                this.outerRadius,
                s.easeInOutSine,
              )),
              (e.u_spikeRadius.value = o.cfit(
                this.ratio,
                0.5,
                1,
                0,
                this.spikeRadius,
                s.easeInOutSine,
              )),
              this.position.copy(i.hitPos),
              this.quaternion.copy(i.hitQuat)
          }
        },
        {
          '../../../utils/ease': 56,
          '../../../utils/math': 58,
          '../../../xr/xr': 67,
          './reticle.frag': 63,
          './reticle.vert': 64,
          './reticleData': 65,
          'three': 24,
        },
      ],
      63: [
        function (t, e, n) {
          e.exports =
            'uniform float u_opacity;\r\nvoid main () {\r\n\tgl_FragColor = vec4(1.0, 1.0, 1.0, u_opacity);\r\n}'
        },
        {},
      ],
      64: [
        function (t, e, n) {
          e.exports =
            'uniform float u_innerRadius;\r\nuniform float u_outerRadius;\r\nuniform float u_spikeRadius;\r\n\r\nfloat PI = 3.141592653589793;\r\nfloat PI2 = 6.283185307179586;\r\n\r\nvoid main () {\r\n\tvec3 pos = position;\r\n\tfloat radius = length(pos);\r\n\r\n\tvec3 isSpike = step(vec3(1.5), abs(position));\r\n\tvec3 spike = isSpike * sign(position);\r\n\r\n\tvec3 basePos = position - spike;\r\n\tfloat angle = atan(basePos.z, basePos.x);\r\n\r\n\tradius = radius < 0.75 ? u_innerRadius : u_outerRadius;\r\n\tpos = vec3(\r\n\t\tcos(angle),\r\n\t\t0.0,\r\n\t\tsin(angle)\r\n\t) * radius;\r\n\r\n\tpos = mix(pos, spike * u_spikeRadius, isSpike);\r\n\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n}'
        },
        {},
      ],
      65: [
        function (t, e, n) {
          'use strict'
          ;(n.position = new Float32Array([
            -0.980785012, 0, 0.195089996, -0.995037973, 0, 0.0990089998, -2, 0,
            0.100000001, -2, 0, 0, -2, 0, -0.100000001, 0.100000001, 0, 2, 0, 0,
            2, -0.0990080014, 0, 0.995037973, -0.100000001, 0, 2, 0.995037973,
            0, -0.0990089998, 0.0990089998, 0, -0.995037973, 0, 0, -2,
            -0.0990089998, 0, -0.995037973, 0.0990089998, 0, 0.995037973,
            -0.995037973, 0, -0.0990089998, 0.100000001, 0, -2, -0.100000001, 0,
            -2, 0.995037973, 0, 0.0990080014, 2, 0, 0.100000001, 2, 0, 0, 2, 0,
            -0.100000001, -0.0975449979, 0, 0.490393013, -0.145142004, 0,
            0.478469998, -0.0490080006, 0, 0.497592002, 0, 0, 0.5, -0.191341996,
            0, 0.461939991, -0.195089996, 0, 0.980785012, -0.235698, 0,
            0.440961003, -0.277785003, 0, 0.415735006, -0.290284991, 0,
            0.956939995, -0.317196995, 0, 0.386505008, -0.353552997, 0,
            0.353552997, -0.382683009, 0, 0.923879981, -0.386505008, 0,
            0.317196995, -0.415735006, 0, 0.277785003, -0.440961003, 0,
            0.235698, -0.461939991, 0, 0.191341996, -0.471397012, 0,
            0.881920993, -0.478469998, 0, 0.145142004, -0.490393013, 0,
            0.0975449979, -0.497592002, 0, 0.049008999, -0.5, 0, 0,
            -0.555570006, 0, 0.831470013, -0.471397012, 0, -0.881920993,
            -0.497592002, 0, -0.049008999, -0.490393013, 0, -0.0975449979,
            -0.478469998, 0, -0.145142004, -0.461939991, 0, -0.191341996,
            -0.382683992, 0, -0.923879981, -0.440961003, 0, -0.235698,
            -0.415735006, 0, -0.277785003, -0.386505008, 0, -0.317196995,
            -0.353552997, 0, -0.353552997, -0.290284991, 0, -0.956939995,
            -0.317196995, 0, -0.386505008, -0.277785003, 0, -0.415735006,
            -0.195089996, 0, -0.980785012, -0.235698, 0, -0.440961003,
            -0.191341996, 0, -0.461939991, -0.145142004, 0, -0.478469998,
            -0.0975449979, 0, -0.490393013, -0.049008999, 0, -0.497592002, 0, 0,
            -0.5, 0.049008999, 0, -0.497592002, 0.0975449979, 0, -0.490393013,
            0.145142004, 0, -0.478469998, 0.195089996, 0, -0.980785012,
            0.191341996, 0, -0.461939991, 0.235698, 0, -0.440961003,
            0.290284991, 0, -0.956939995, 0.277785003, 0, -0.415735006,
            0.317196995, 0, -0.386505008, 0.382683009, 0, -0.923879981,
            0.353552997, 0, -0.353552997, 0.386505008, 0, -0.317196995,
            0.471397012, 0, -0.881920993, 0.415735006, 0, -0.277785003,
            0.440961003, 0, -0.235698, 0.461939991, 0, -0.191341996,
            0.478469998, 0, -0.145142004, 0.555570006, 0, -0.831470013,
            0.490393013, 0, -0.0975449979, 0.497592002, 0, -0.049008999, 0.5, 0,
            0, 0.555570006, 0, 0.831468999, 0.634392977, 0, -0.773010015,
            0.634392977, 0, 0.773010015, 0.707107008, 0, -0.707107008,
            0.707107008, 0, 0.707107008, 0.773010015, 0, -0.634392977,
            0.773011029, 0, 0.634392977, 0.831470013, 0, 0.555570006,
            0.881920993, 0, 0.471397012, 0.923879981, 0, 0.382683009,
            0.956939995, 0, 0.290284008, 0.980785012, 0, 0.195089996,
            0.831470013, 0, -0.555570006, 0.881920993, 0, -0.471397012,
            0.923879981, 0, -0.382683009, 0.956939995, 0, -0.290284991,
            0.980785012, 0, -0.195089996, 0.497592002, 0, 0.0490080006,
            0.490393013, 0, 0.0975449979, 0.478469998, 0, 0.145142004,
            0.471397012, 0, 0.881920993, 0.461939991, 0, 0.191341996,
            0.440961003, 0, 0.235698, 0.415735006, 0, 0.277785003, 0.386505008,
            0, 0.317196995, 0.382683992, 0, 0.923879027, 0.35355401, 0,
            0.353552997, 0.317196995, 0, 0.386505008, 0.290284991, 0,
            0.956939995, 0.277785003, 0, 0.415735006, 0.235698, 0, 0.440961003,
            0.195089996, 0, 0.980785012, 0.191341996, 0, 0.461939991,
            0.145143002, 0, 0.478469998, 0.0975449979, 0, 0.490393013,
            0.049008999, 0, 0.497592002, -0.555570006, 0, -0.831470013,
            -0.634392977, 0, -0.773010015, -0.634392977, 0, 0.773010015,
            -0.707107008, 0, 0.707107008, -0.707107008, 0, -0.707107008,
            -0.773010015, 0, 0.634392977, -0.773010015, 0, -0.634392977,
            -0.831470013, 0, 0.555570006, -0.831470013, 0, -0.555570006,
            -0.881920993, 0, 0.471397012, -0.881920993, 0, -0.471397012,
            -0.923879981, 0, 0.382683009, -0.923879981, 0, -0.382683009,
            -0.956939995, 0, 0.290284991, -0.956939995, 0, -0.290284991,
            -0.980785012, 0, -0.195089996,
          ])),
            (n.indices = new Uint8Array([
              62, 10, 63, 118, 13, 119, 79, 80, 81, 80, 70, 75, 75, 68, 72, 80,
              73, 71, 72, 67, 69, 69, 65, 66, 10, 16, 15, 15, 16, 11, 68, 67,
              72, 66, 64, 10, 79, 78, 80, 71, 70, 80, 78, 77, 80, 77, 76, 80,
              76, 74, 80, 10, 12, 16, 12, 60, 56, 56, 59, 53, 58, 48, 53, 48,
              50, 49, 48, 51, 50, 10, 62, 12, 53, 59, 58, 52, 51, 48, 74, 73,
              80, 48, 54, 52, 48, 55, 54, 70, 68, 75, 48, 57, 55, 48, 58, 57,
              67, 65, 69, 65, 64, 66, 56, 60, 59, 63, 10, 64, 12, 61, 60, 12,
              62, 61, 47, 130, 49, 49, 43, 48, 120, 43, 49, 120, 49, 121, 121,
              49, 124, 124, 49, 126, 126, 49, 128, 49, 130, 128, 130, 47, 132,
              46, 134, 132, 134, 45, 135, 45, 14, 135, 14, 2, 4, 4, 2, 3, 45,
              44, 14, 132, 47, 46, 46, 45, 134, 14, 1, 2, 1, 39, 0, 0, 39, 133,
              1, 40, 39, 133, 38, 131, 131, 36, 129, 129, 35, 127, 127, 34, 125,
              125, 31, 123, 123, 30, 122, 28, 42, 122, 42, 27, 37, 27, 25, 37,
              37, 25, 32, 32, 25, 29, 29, 22, 26, 26, 21, 7, 29, 25, 22, 7, 13,
              8, 8, 5, 6, 13, 5, 8, 13, 118, 115, 115, 118, 112, 13, 7, 24, 112,
              117, 109, 109, 116, 104, 104, 114, 84, 84, 113, 86, 86, 110, 88,
              88, 108, 90, 107, 91, 90, 91, 106, 92, 105, 93, 92, 93, 103, 94,
              102, 95, 94, 95, 102, 17, 101, 83, 17, 17, 20, 18, 18, 20, 19, 20,
              17, 9, 9, 81, 100, 100, 81, 99, 9, 83, 82, 99, 81, 98, 98, 81, 97,
              97, 81, 96, 96, 81, 89, 89, 81, 87, 87, 81, 85, 85, 81, 80, 81, 9,
              82, 94, 103, 102, 17, 102, 101, 90, 108, 107, 92, 106, 105, 118,
              117, 112, 116, 114, 104, 7, 23, 24, 24, 119, 13, 21, 23, 7, 17,
              83, 9, 122, 30, 28, 39, 38, 133, 36, 35, 129, 14, 41, 1, 41, 14,
              44, 40, 1, 41, 42, 28, 27, 93, 105, 103, 26, 22, 21, 38, 36, 131,
              35, 34, 127, 91, 107, 106, 88, 110, 108, 33, 125, 34, 31, 125, 33,
              86, 111, 110, 30, 123, 31, 86, 113, 111, 113, 84, 114, 116, 109,
              117,
            ]))
        },
        {},
      ],
      66: [
        function (t, e, n) {
          'use strict'
          var r = t('../core/settings'),
            i = t('../core/properties'),
            a = t('../utils/math'),
            o = (t('../utils/ease'), t('../xr/xr')),
            s = t('./objects/hand/hand'),
            c = t('three'),
            l = t('../measurement/measurement'),
            h = t('./objects/reticle/Reticle')
          ;(n.container = null),
            (n.reticle = null),
            (n.init = function () {
              ;(n.container = new c.Object3D()),
                l.init(),
                n.container.add(l.container),
                (n.reticle = new h()),
                n.container.add(n.reticle),
                s.init(),
                n.container.add(s.container),
                o.eventDispatcher.addEventListener('start', v),
                o.eventDispatcher.addEventListener('end', g)
            }),
            (n.update = function (t) {
              o.isActive &&
                (u
                  ? (i.instructionShowRatio = a.saturate(
                      i.instructionShowRatio +
                        1 / r.XR_INSTRUCTION_SHOW_DURATION / 60,
                    ))
                  : o.isHit &&
                    !m &&
                    (function () {
                      d && clearTimeout(d)
                      f && clearTimeout(f)
                      ;(m = !0), (i.pinCanShow = !0)
                    })(),
                p &&
                  ((i.instructionHideRatio = a.saturate(
                    i.instructionHideRatio +
                      (o.hasHit ? 1 : -1) / r.XR_INSTRUCTION_HIDE_DURATION / 60,
                  )),
                  (i.pinCanShow = 0.5 < i.instructionHideRatio)),
                n.reticle.update(t),
                l.update(t),
                s.update(t))
            }),
            (n.eventDispatcher = new c.EventDispatcher())
          var u = !1,
            p = !1,
            d = void 0,
            f = void 0,
            m = !1
          function v(t) {
            ;(m = p = u = !1), s.reset(), (d = setTimeout(y, 2500))
          }
          function g(t) {
            ;(i.instructionShowRatio = 0),
              (i.instructionHideRatio = 0),
              (i.pinCanShow = !1)
          }
          function y() {
            ;(u = !0), (f = setTimeout(x, 4e3))
          }
          function x() {
            p = !0
          }
        },
        {
          '../core/properties': 29,
          '../core/settings': 30,
          '../measurement/measurement': 39,
          '../utils/ease': 56,
          '../utils/math': 58,
          '../xr/xr': 67,
          './objects/hand/hand': 60,
          './objects/reticle/Reticle': 62,
          'three': 24,
        },
      ],
      67: [
        function (t, e, s) {
          'use strict'
          var n = t('three'),
            c = t('../core/properties')
          ;(s.checkCompatibility = function (e) {
            null !== s.isSupportAR
              ? e(s.isSupportAR)
              : navigator.xr && navigator.xr.isSessionSupported
                ? navigator.xr
                    .isSessionSupported('immersive-ar')
                    .then(function (t) {
                      ;(s.isSupportAR = t),
                        requestAnimationFrame(function () {
                          e(s.isSupportAR)
                        })
                    })
                    .catch(function () {
                      ;(s.isSupportAR = !1), e(!1)
                    })
                : e(!1)
          }),
            (s.start = function () {
              var t =
                0 < arguments.length && void 0 !== arguments[0]
                  ? arguments[0]
                  : {}
              {
                s.isSupportAR &&
                  !s.isActive &&
                  navigator.xr
                    .requestSession('immersive-ar', t)
                    .then(i)
                    .catch(function (t) {
                      s.eventDispatcher.dispatchEvent({
                        type: 'error',
                        error: 1,
                        caughtError: t,
                      })
                    })
              }
              s.isSupportAR ||
                s.eventDispatcher.dispatchEvent({
                  type: 'error',
                  error: 0,
                  caughtError: null,
                })
            }),
            (s.end = function () {
              s.isSupportAR && s.isActive && s.session.end()
            }),
            (s.getResolution = function (t) {
              var e = c.renderer.xr
              {
                var n
                e.enabled && e.isPresenting
                  ? ((n = e.getSession().renderState.baseLayer),
                    t.set(n.framebufferWidth, n.framebufferHeight))
                  : c.renderer.getSize(t)
              }
            }),
            (s.getCamera = function () {
              var t = c.renderer.xr
              return t.enabled && t.isPresenting
                ? t.getCamera(c.camera)
                : c.camera
            }),
            (s.hitTest = function (t, e) {
              {
                var n, r, i, a, o
                ;(s.wasHit = s.isHit),
                  t && s.isActive
                    ? ((n = c.renderer.xr.getReferenceSpace()),
                      (r = c.renderer.xr.getSession()),
                      !1 === l &&
                        (r.requestReferenceSpace('viewer').then(function (t) {
                          r.requestHitTestSource({ space: t }).then(
                            function (t) {
                              h = t
                            },
                          )
                        }),
                        (l = !0)),
                      h &&
                        ((i = t.getHitTestResults(h)).length
                          ? ((a = i[0]),
                            (o = !0),
                            f.fromArray(a.getPose(n).transform.matrix),
                            f.decompose(u, d, p),
                            p.set(0, 1, 0),
                            p.applyQuaternion(d).normalize(),
                            s.isHorizontalOnly &&
                              (o = p.y > s.isHorizontalOnlyNormalYThreshold),
                            o &&
                              ((s.hasHit = !0),
                              (s.isHit = !0),
                              s.hitMatrix.copy(f),
                              s.hitPos.copy(u),
                              s.hitQuat.copy(d),
                              s.hitPlane.setFromNormalAndCoplanarPoint(
                                p,
                                s.hitPos,
                              )))
                          : (s.isHit = !1)))
                    : (s.isHit = null)
              }
            }),
            (s.isActive = !1),
            (s.session = null),
            (s.isSupportAR = null),
            (s.eventDispatcher = new n.EventDispatcher()),
            (s.hitPos = new n.Vector3()),
            (s.hitQuat = new n.Quaternion()),
            (s.hitMatrix = new n.Matrix4()),
            (s.hitPlane = new n.Plane()),
            (s.isHit = null),
            (s.wasHit = null),
            (s.hasHit = !1),
            (s.isHorizontalOnly = !0)
          var l = !(s.isHorizontalOnlyNormalYThreshold = 0.75),
            h = void 0,
            r = void 0,
            u = new n.Vector3(),
            p = new n.Vector3(),
            d = new n.Quaternion(),
            f = new n.Matrix4()
          function i(t) {
            t.addEventListener('end', o),
              (s.session = t),
              c.renderer.xr.setReferenceSpaceType('local'),
              c.renderer.xr.setSession(t),
              (s.isActive = !0),
              s.eventDispatcher.dispatchEvent({ type: 'start' }),
              r ||
                ((r = c.renderer.xr.getController(0)).addEventListener(
                  'select',
                  a,
                ),
                c.scene.add(r))
          }
          function a() {}
          function o() {
            s.session.removeEventListener('end', o),
              (s.session = null),
              (s.isActive = !1),
              (s.hasHit = !1),
              (s.isHit = !1),
              (l = !1),
              (h = null),
              s.eventDispatcher.dispatchEvent({ type: 'end' })
          }
        },
        { '../core/properties': 29, 'three': 24 },
      ],
    },
    {},
    [31],
  )
}
/*
     FILE ARCHIVED ON 09:55:32 Jun 22, 2022 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 16:11:13 Jan 10, 2025.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
*/
/*
playback timings (ms):
  captures_list: 0.783
  exclusion.robots: 0.044
  exclusion.robots.policy: 0.027
  esindex: 0.019
  cdx.remote: 31.101
  LoadShardBlock: 234.15 (3)
  PetaboxLoader3.datanode: 133.554 (4)
  PetaboxLoader3.resolve: 223.418 (2)
  load_resource: 131.519
*/
